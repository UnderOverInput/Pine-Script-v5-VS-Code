{
  "types": [
    {
      "docs": [
        {
          "name": "type[]",
          "kind": "Type Keyword",
          "desc": "Type keyword for an array of type....",
          "syntax": "array<type>"
        },
        {
          "name": "int[]",
          "kind": "Type Keyword",
          "desc": "1 of 2 Type keywords for an `array` of type `int`",
          "syntax": "array<int>"
        },
        {
          "name": "float[]",
          "kind": "Type Keyword",
          "desc": "1 of 2 Type keywords for an `array` of type `float`",
          "syntax": "array<float>"
        },
        {
          "name": "bool[]",
          "kind": "Type Keyword",
          "desc": "1 of 2 Type keywords for an `array` of type `bool`",
          "syntax": "array<bool>"
        },
        {
          "name": "string[]",
          "kind": "Type Keyword",
          "desc": "1 of 2 Type keywords for an `array` of type `string`",
          "syntax": "array<string>"
        },
        {
          "name": "color[]",
          "kind": "Type Keyword",
          "desc": "1 of 2 Type keywords for an `array` of type `color`",
          "syntax": "array<color>"
        },
        {
          "name": "line[]",
          "kind": "Type Keyword",
          "desc": "1 of 2 Type keywords for an `array` of type `line`",
          "syntax": "array<line>"
        },
        {
          "name": "label[]",
          "kind": "Type Keyword",
          "desc": "1 of 2 Type keywords for an `array` of type `label`",
          "syntax": "array<label>"
        },
        {
          "name": "box[]",
          "kind": "Type Keyword",
          "desc": "1 of 2 Type keywords for an `array` of type `box`",
          "syntax": "array<box>"
        },
        {
          "name": "table[]",
          "kind": "Type Keyword",
          "desc": "1 of 2 Type keywords for an `array` of type `table`",
          "syntax": "array<table>"
        },
        {
          "name": "linefill[]",
          "kind": "Type Keyword",
          "desc": "1 of 2 Type keywords for an `array` of type `linefill`",
          "syntax": "array<linefill>"
        },
        {
          "name": "polyline[]",
          "kind": "Type Keyword",
          "desc": "Type keyword for an `array` of type `polyline`. This indicates a list of `polyline` instances, which can be used to manage multiple polylines in a script.",
          "syntax": "polyline[] or array<polyline>"
        },
        {
          "name": "chart.point[]",
          "kind": "Type Keyword",
          "desc": "Type keyword for an `array` of type `chart.point`. This indicates a list of `chart.point` instances, which can be used to manage multiple chart points in a script, such as for tracking multiple time or index points on a chart.",
          "syntax": "chart.point[] or array<chart.point>"
        },
        {
          "name": "simple",
          "kind": "Type Keyword",
          "desc": "**simple** is a keyword that can be used in a library\\`s exported functions to specify the type form required for a function\\`s arguments.  \nBy default, all arguments of exported functions are automatically converted into the \"series\" type form.  \nIn some cases, this would make arguments unusable with those of built-in functions that do not support the \"series\" form.  \nFor these cases, the `simple` keyword can be used instead.",
          "syntax": "[simple] <type> <variable_name> = <value>",
          "examples": "//@version=5\n//@description Library of debugging functions.\nlibrary(\"Debugging_library\", overlay = true)\nexport emaWrong(float source, int length) =>\n\t// By default, both `source` and `length` will expect values of the `series` type form: `series float` for `source`, `series int` for `length`.\n\t// This function will not compile because `ema()` does not support a \"series int\" argument for `length`. A \"simple int\" is required.\n\tta.ema(source, length)\n\nexport emaRight(float source, simple int length) =>\n\t// This function requires an argument of \"simple int\" type for its `length` parameter.\n\tta.ema(source, length)"
        },
        {
          "name": "series",
          "kind": "Type Keyword",
          "desc": "**series** is a keyword that can be used in a library\\`s exported functions to specify the type form required for a function\\`s arguments.  \nExplicit use of the `series` keyword is usually unnecessary because all arguments of exported functions are automatically converted to the \"series\" form by default.",
          "syntax": "[series] <type> <variable_name> = <value>",
          "examples": "//@version=5\n//@description Library of debugging functions.\nlibrary(\"Debugging_library\", overlay = true)\nexport smaCustom(series float source, series int length) =>\n\tta.sma(source, length)"
        },
        {
          "name": "int",
          "kind": "Type Keyword",
          "desc": "Keyword used to explicitly declare the \"int\" (integer) type of a variable or a parameter.",
          "syntax": "int",
          "remarks": "Explicitly mentioning the type in a variable declaration is optional, except when it is initialized with [na](#var_na).  \nLearn more about Pine Script™ types in the User Manual page on the [Type System](https://www.tradingview.com/pine-script-docs/en/v5/language/Type_system.html).",
          "seeAlso": [
            "[var](#kw_var)",
            "[varip](#kw_varip)",
            "[float](#type_float)",
            "[bool](#type_bool)",
            "[color](#type_color)",
            "[string](#type_string)"
          ],
          "examples": "//@version=5\nindicator(\"int\")\nint i = 14    // Same as `i = 14`\ni := na\nplot(i)"
        },
        {
          "name": "float",
          "kind": "Type Keyword",
          "desc": "Keyword used to explicitly declare the \"float\" (floating point) type of a variable or a parameter.",
          "syntax": "float",
          "remarks": "Explicitly mentioning the type in a variable declaration is optional, except when it is initialized with [na](#var_na).  \nLearn more about Pine Script™ types in the User Manual page on the [Type System](https://www.tradingview.com/pine-script-docs/en/v5/language/Type_system.html).",
          "seeAlso": [
            "[var](#kw_var)",
            "[varip](#kw_varip)",
            "[int](#type_int)",
            "[bool](#type_bool)",
            "[color](#type_color)",
            "[string](#type_string)"
          ],
          "examples": "//@version=5\nindicator(\"float\")\nfloat f = 3.14    // Same as `f = 3.14`\nf := na\nplot(f)"
        },
        {
          "name": "bool",
          "kind": "Type Keyword",
          "desc": "Keyword used to explicitly declare the \"bool\" (boolean) type of a variable or a parameter. \"Bool\" variables can have values [true](#op_true), [false](#op_false) or [na](#var_na).",
          "syntax": "bool",
          "remarks": "Explicitly mentioning the type in a variable declaration is optional, except when it is initialized with [na](#var_na).  \nLearn more about Pine Script™ types in the User Manual page on the [Type System](https://www.tradingview.com/pine-script-docs/en/v5/language/Type_system.html).",
          "seeAlso": [
            "[var](#kw_var)",
            "[varip](#kw_varip)",
            "[int](#type_int)",
            "[float](#type_float)",
            "[color](#type_color)",
            "[string](#type_string)",
            "[true](#kw_true)",
            "[false](#kw_false)"
          ],
          "examples": "//@version=5\nindicator(\"bool\")\nbool b = true    // Same as `b = true`\nb := na\nplot(b ? open : close)"
        },
        {
          "name": "string",
          "kind": "Type Keyword",
          "desc": "Keyword used to explicitly declare the \"string\" type of a variable or a parameter.",
          "syntax": "string",
          "remarks": "Explicitly mentioning the type in a variable declaration is optional, except when it is initialized with [na](#var_na).  \nLearn more about Pine Script™ types in the User Manual page on the [Type System](https://www.tradingview.com/pine-script-docs/en/v5/language/Type_system.html).",
          "seeAlso": [
            "[var](#kw_var)",
            "[varip](#kw_varip)",
            "[int](#type_int)",
            "[float](#type_float)",
            "[bool](#type_bool)",
            "[str.tostring](#fun_str.tostring)",
            "[str.format](#fun_str.format)"
          ],
          "examples": "//@version=5\nindicator(\"string\")\nstring s = \"Hello World!\"    // Same as \\`s = \"Hello world!\"`\n// string s = na // same as \"\" \nplot(na, title=s)"
        },
        {
          "name": "color",
          "kind": "Type Keyword",
          "desc": "Keyword used to explicitly declare the \"color\" type of a variable or a parameter.",
          "syntax": "color",
          "remarks": [
            "Color literals have the following format: #RRGGBB or #RRGGBBAA. The letter pairs represent 00 to FF hexadecimal values (0 to 255 in decimal) where RR, GG and BB pairs are the values for the color\\`s red, green and blue components. AA is an optional value for the color\\`s transparency (or alpha component) where 00 is invisible and FF opaque. When no AA pair is supplied, FF is used. The hexadecimal letters can be upper or lower case.",
            "Explicitly mentioning the type in a variable declaration is optional, except when it is initialized with [na](#var_na). Learn more about Pine Script™ types in the User Manual page on the [Type System](https://www.tradingview.com/pine-script-docs/en/v5/language/Type_system.html)."
          ],
          "seeAlso": [
            "[var](#kw_var)",
            "[varip](#kw_varip)",
            "[int](#type_int)",
            "[float](#type_float)",
            "[string](#type_string)",
            "[color.rgb](#fun_color.rgb)",
            "[color.new](#fun_color.new)"
          ],
          "examples": "//@version=5\nindicator(\"color\", overlay = true)\n\ncolor textColor = color.green   \ncolor labelColor = #FF000080  // Red color (FF0000) with 50% transparency (80 which is half of FF).\nif barstate.islastconfirmedhistory\n\tlabel.new(bar_index, high, text = \"Label\", color = labelColor, textcolor = textColor)\n\n// When declaring variables with color literals, built-in constants(color.green) or functions (color.new(), color.rgb()), the \"color\" keyword for the type can be omitted.\nc = color.rgb(0, 255, 0, 0)\nplot(close, color = c)"
        },
        {
          "name": "line",
          "kind": "Type Keyword",
          "desc": "Keyword used to explicitly declare the \"line\" type of a variable or a parameter.  \nLine objects (or IDs) can be created with the [line.new](#fun_line.new) function.",
          "syntax": "line",
          "remarks": "Line objects are always of \"series\" form.",
          "seeAlso": [
            "[var](#kw_var)",
            "[label](#type_label)",
            "[box](#type_box)",
            "[line.new](#fun_line.new)"
          ],
          "examples": "//@version=5\nindicator(\"line\")\n// Empty `line1` line ID.\nvar line line1 = na\n// `line` type is unnecessary because `line.new()` returns \"line\" type.\nvar line2 = line.new(na, na, na, na)\nline3 = line.new(bar_index - 1, high, bar_index, high, extend = extend.right)"
        },
        {
          "name": "label",
          "kind": "Type Keyword",
          "desc": "Keyword used to explicitly declare the \"label\" type of a variable or a parameter.  \nLabel objects (or IDs) can be created with the [label.new](#fun_label.new) function.",
          "syntax": "label",
          "remarks": "Label objects are always of \"series\" form.",
          "seeAlso": [
            "[var](#kw_var)",
            "[line](#type_line)",
            "[box](#type_box)",
            "[label.new](#fun_label.new)"
          ],
          "examples": "//@version=5\nindicator(\"label\")\n// Empty `label1` label ID.\nvar label label1 = na\n// `label` type is unnecessary because `label.new()` returns \"label\" type.\nvar label2 = label.new(na, na, na)\nif barstate.islastconfirmedhistory\n\tlabel3 = label.new(bar_index, high, text = \"label3 text\")"
        },
        {
          "name": "box",
          "kind": "Type Keyword",
          "desc": "Keyword used to explicitly declare the \"box\" type of a variable or a parameter.  \nBox objects (or IDs) can be created with the [box.new](#fun_box.new) function.",
          "syntax": "box",
          "remarks": "Box objects are always of \"series\" form.",
          "seeAlso": [
            "[var](#kw_var)",
            "[line](#type_line)",
            "[label](#type_label)",
            "[table](#type_table)",
            "[box.new](#fun_box.new)"
          ],
          "examples": "//@version=5\nindicator(\"box\")\n// Empty `box1` box ID.\nvar box box1 = na\n// `box` type is unnecessary because `box.new()` returns a \"box\" type.\nvar box2 = box.new(na, na, na, na)\nbox3 = box.new(time, open, time + 60 * 60 * 24, close, xloc=xloc.bar_time)"
        },
        {
          "name": "table",
          "kind": "Type Keyword",
          "desc": "Keyword used to explicitly declare the \"table\" type of a variable or a parameter.  \nTable objects (or IDs) can be created with the [table.new](#fun_table.new) function.",
          "syntax": "table",
          "remarks": "Table objects are always of \"series\" form.",
          "seeAlso": [
            "[var](#kw_var)",
            "[line](#type_line)",
            "[label](#type_label)",
            "[box](#type_box)",
            "[table.new](#fun_table.new)"
          ],
          "examples": "//@version=5\nindicator(\"table\")\n// Empty `table1` table ID.\nvar table table1 = na\n// `table` type is unnecessary because `table.new()` returns \"table\" type.\nvar table2 = table.new(position.top_left, na, na)\n\nif barstate.islastconfirmedhistory\n\tvar table3 = table.new(position = position.top_right, columns = 1, rows = 1, bgcolor = color.yellow, border_width = 1)\n\ttable.cell(table_id = table3, column = 0, row = 0, text = \"table3 text\")"
        },
        {
          "name": "linefill",
          "kind": "Type Keyword",
          "desc": "Keyword used to explicitly declare the \"linefill\" type of a variable or a parameter.  \nLinefill objects (or IDs) can be created with the [linefill.new](#fun_linefill.new) function.",
          "syntax": "linefill",
          "remarks": "Linefill objects are always of \"series\" form.",
          "seeAlso": [
            "[var](#kw_var)",
            "[line](#type_line)",
            "[label](#type_label)",
            "[table](#type_table)",
            "[box](#type_box)",
            "[linefill.new](#fun_linefill.new)"
          ],
          "examples": "//@version=5\nindicator(\"linefill\", overlay=true)\n// Empty `linefill1` line ID.\nvar linefill linefill1 = na\n// `linefill` type is unnecessary because `linefill.new()` returns \"linefill\" type.\nvar linefill2 = linefill.new(na, na, na)\n\nif barstate.islastconfirmedhistory\n\tline1 = line.new(bar_index - 10, high+1, bar_index, high+1, extend = extend.right)\n\tline2 = line.new(bar_index - 10, low+1, bar_index, low+1, extend = extend.right)\n\tlinefill3 = linefill.new(line1, line2, color = color.new(color.green, 80))"
        },
        {
          "name": "array<type>",
          "kind": "Type Keyword",
          "desc": "Keyword used to explicitly declare the \"array\" type of a variable or a parameter.  \nArray objects (or IDs) can be created with the [array.new<type>](#fun_array.new<type>), [array.from](#fun_array.from) function.",
          "syntax": "array<type>",
          "remarks": "Array objects are always of \"series\" form.",
          "seeAlso": [
            "[var](#kw_var)",
            "[line](#type_line)",
            "[label](#type_label)",
            "[table](#type_table)",
            "[box](#type_box)",
            "[array.new<type>](#fun_array.new%3Ctype%3E)",
            "[array.from](#fun_array.from)"
          ],
          "examples": "//@version=5\nindicator(\"array\", overlay=true)\narray<float> a = na\na := array.new<float>(1, close)\nplot(array.get(a, 0))"
        },
        {
          "name": "array<int>",
          "kind": "Type Keyword",
          "desc": "1 of 2 Type keywords for an `array` of type `int`",
          "syntax": "int[] or array<int>"
        },
        {
          "name": "array<float>",
          "kind": "Type Keyword",
          "desc": "1 of 2 Type keywords for an `array` of type `float`",
          "syntax": "float[] or array<float>"
        },
        {
          "name": "array<bool>",
          "kind": "Type Keyword",
          "desc": "1 of 2 Type keywords for an `array` of type `bool`",
          "syntax": "bool[] or array<bool>"
        },
        {
          "name": "array<string>",
          "kind": "Type Keyword",
          "desc": "1 of 2 Type keywords for an `array` of type `string`",
          "syntax": "string[] or array<string>"
        },
        {
          "name": "array<color>",
          "kind": "Type Keyword",
          "desc": "1 of 2 Type keywords for an `array` of type `color`",
          "syntax": "color[] or array<color>"
        },
        {
          "name": "array<line>",
          "kind": "Type Keyword",
          "desc": "1 of 2 Type keywords for an `array` of type `line`",
          "syntax": "line[] or array<line>"
        },
        {
          "name": "array<label>",
          "kind": "Type Keyword",
          "desc": "1 of 2 Type keywords for an `array` of type `label`",
          "syntax": "label[] or array<label>"
        },
        {
          "name": "array<box>",
          "kind": "Type Keyword",
          "desc": "1 of 2 Type keywords for an `array` of type `box`",
          "syntax": "box[] or array<box>"
        },
        {
          "name": "array<table>",
          "kind": "Type Keyword",
          "desc": "1 of 2 Type keywords for an `array` of type `table`",
          "syntax": "table[] or array<table>"
        },
        {
          "name": "array<linefill>",
          "kind": "Type Keyword",
          "desc": "1 of 2 Type keywords for an `array` of type `linefill`",
          "syntax": "linefill[] or array<linefill>"
        },
        {
          "name": "array<polyline>",
          "kind": "Type Keyword",
          "desc": "1 of 2 Type keywords for an `array` of type `polyline`. This allows for declaration of a variable or parameter as an array holding `polyline` instances.",
          "syntax": "polyline[] or array<polyline>"
        },
        {
          "name": "array<chart.point>",
          "kind": "Type Keyword",
          "desc": "1 of 2 Type keywords for an `array` of type `chart.point`. This allows for declaration of a variable or parameter as an array holding `chart.point` instances, useful for manipulating collections of chart points in trading scripts.",
          "syntax": "chart.point[] or array<chart.point>"
        },
        {
          "name": "matrix<type>",
          "kind": "Type Keyword",
          "desc": "Keyword used to explicitly declare the \"matrix\" type of a variable or a parameter.  \nMatrix objects (or IDs) can be created with the [matrix.new<type>](#fun_matrix.new<type>) function.",
          "syntax": "matrix<type>",
          "remarks": "Matrix objects are always of \"series\" form.",
          "seeAlso": [
            "[var](#kw_var)",
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[array](#op_array)"
          ],
          "examples": "//@version=5\nindicator(\"matrix example\")\n\n// Create `m1` matrix of `int` type.\nmatrix<int> m1 = matrix.new<int>(2, 3, 0)\n\n// `matrix<int>` is unnecessary because the `matrix.new<int>()` function returns an `int` type matrix object.\nm2 = matrix.new<int>(2, 3, 0)\n\n// Display matrix using a label.\nif barstate.islastconfirmedhistory\n\tlabel.new(bar_index, high, str.tostring(m2))"
        },
        {
          "name": "matrix<int>",
          "kind": "Type Keyword",
          "desc": "Type keyword for a `matrix` of type `int`.",
          "syntax": "matrix<int>"
        },
        {
          "name": "matrix<float>",
          "kind": "Type Keyword",
          "desc": "Type keyword for a `matrix` of type `float`.",
          "syntax": "matrix<float>"
        },
        {
          "name": "matrix<bool>",
          "kind": "Type Keyword",
          "desc": "Type keyword for a `matrix` of type `bool`.",
          "syntax": "matrix<bool>"
        },
        {
          "name": "matrix<string>",
          "kind": "Type Keyword",
          "desc": "Type keyword for a `matrix` of type `string`.",
          "syntax": "matrix<string>"
        },
        {
          "name": "matrix<color>",
          "kind": "Type Keyword",
          "desc": "Type keyword for a `matrix` of type `color`.",
          "syntax": "matrix<color>"
        },
        {
          "name": "matrix<line>",
          "kind": "Type Keyword",
          "desc": "Type keyword for a `matrix` of type `line`.",
          "syntax": "matrix<line>"
        },
        {
          "name": "matrix<label>",
          "kind": "Type Keyword",
          "desc": "Type keyword for a `matrix` of type `label`.",
          "syntax": "matrix<label>"
        },
        {
          "name": "matrix<box>",
          "kind": "Type Keyword",
          "desc": "Type keyword for a `matrix` of type `box`.",
          "syntax": "matrix<box>"
        },
        {
          "name": "matrix<table>",
          "kind": "Type Keyword",
          "desc": "Type keyword for a `matrix` of type `table`.",
          "syntax": "matrix<table>"
        },
        {
          "name": "matrix<linefill>",
          "kind": "Type Keyword",
          "desc": "Type keyword for a `matrix` of type `linefill`.",
          "syntax": "matrix<linefill>"
        },
        {
          "name": "matrix<polyline>",
          "kind": "Type Keyword",
          "desc": "Type keyword for a `matrix` of type `polyline`. This represents a two-dimensional array or matrix composed of `polyline` elements, suitable for more complex data structures involving multiple polyline configurations.",
          "syntax": "matrix<polyline>"
        },
        {
          "name": "matrix<chart.point>",
          "kind": "Type Keyword",
          "desc": "Type keyword for a `matrix` of type `chart.point`. This represents a two-dimensional array or matrix composed of `chart.point` elements, suitable for more complex data structures where multiple chart points need to be managed or manipulated simultaneously.",
          "syntax": "matrix<chart.point>"
        },
        {
          "name": "chart.point",
          "kind": "Type Keyword",
          "desc": "Keyword to explicitly declare the type of a variable or parameter as `chart.point`.  \nScripts can produce `chart.point` instances using the [chart.point.from_time](#fun_chart.point.from_time), [chart.point.from_index](#fun_chart.point.from_index), and [chart.point.now](#fun_chart.point.now) functions.",
          "syntax": "chart.point",
          "fields": [
            {
              "name": "time",
              "desc": "The x-coordinate of the point, expressed as a UNIX time value.",
              "type": "series float"
            },
            {
              "name": "index",
              "desc": "The x-coordinate of the point, expressed as a bar index value.",
              "type": "series int"
            },
            {
              "name": "price",
              "desc": "The y-coordinate of the point.",
              "type": "series float"
            }
          ],
          "seeAlso": [
            "[polyline](#type_polyline)"
          ]
        },
        {
          "name": "map<type,type>",
          "kind": "Type Keyword",
          "desc": "Keyword used to explicitly declare the \"map\" type of a variable or a parameter.  \nMap objects (or IDs) can be created with the [map.new<type,type>](#fun_map.new%3Ctype,type%3E) function.",
          "syntax": "map<keyType, valueType>",
          "remarks": "Map objects are always of [series](https://www.tradingview.com/pine-script-docs/en/v5/language/Type_system.html#series) form.",
          "seeAlso": [
            "[map.new<type,type>](#fun_map.new%3Ctype,type%3E)"
          ],
          "examples": "//@version=5\nindicator(\"map\", overlay=true)\nmap<int, float> a = na\na := map.new<int, float>()\na.put(bar_index, close)\nlabel.new(bar_index, a.get(bar_index), \"Current close\")"
        },
        {
          "name": "polyline",
          "kind": "Type Keyword",
          "desc": "Keyword to explicitly declare the type of a variable or parameter as `polyline`. Scripts can produce {backTick_2} instances using the [polyline.new](#fun_polyline.new) function.",
          "seeAlso": [
            "[chart.point](#type_chart.point)"
          ]
        }
      ],
      "title": "Built-in Type"
    }
  ],
  "methods": [
    {
      "docs": [
        {
          "name": "box.copy",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Clones the box object.",
          "args": [],
          "syntax": "box.copy(id) → series box",
          "seeAlso": [
            "[box.new](#fun_box.new)",
            "[box.delete](#fun_box.delete)"
          ],
          "thisType": [
            "series box"
          ],
          "examples": "//@version=5\nindicator('Last 50 bars price ranges', overlay = true)\nLOOKBACK = 50\nhighest = ta.highest(LOOKBACK)\nlowest = ta.lowest(LOOKBACK)\nif barstate.islastconfirmedhistory\n\tvar BoxLast = box.new(bar_index[LOOKBACK], highest, bar_index, lowest, bgcolor = color.new(color.green, 80))\n\tvar BoxPrev = box.copy(BoxLast)\n\tbox.set_lefttop(BoxPrev, bar_index[LOOKBACK * 2], highest[50])\n\tbox.set_rightbottom(BoxPrev, bar_index[LOOKBACK], lowest[50])\n\tbox.set_bgcolor(BoxPrev, color.new(color.red, 80))",
          "methodName": "copy",
          "originalName": "box.copy",
          "methodSyntax": "box.copy() → series box",
          "returnedType": "box",
          "returnedTypes": [
            "series box"
          ]
        },
        {
          "name": "line.copy",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Clones the line object.",
          "args": [],
          "syntax": "line.copy(id) → series line",
          "returns": "New line ID object which may be passed to line.setXXX and line.getXXX functions.",
          "seeAlso": [
            "[line.new](#fun_line.new)",
            "[line.delete](#fun_line.delete)"
          ],
          "thisType": [
            "series line"
          ],
          "examples": "//@version=5\nindicator('Last 100 bars price range', overlay = true)\nLOOKBACK = 100\nhighest = ta.highest(LOOKBACK)\nlowest = ta.lowest(LOOKBACK)\nif barstate.islastconfirmedhistory\n\tvar lineTop = line.new(bar_index[LOOKBACK], highest, bar_index, highest, color = color.green)\n\tvar lineBottom = line.copy(lineTop)\n\tline.set_y1(lineBottom, lowest)\n\tline.set_y2(lineBottom, lowest)\n\tline.set_color(lineBottom, color.red)",
          "methodName": "copy",
          "originalName": "line.copy",
          "methodSyntax": "line.copy() → series line",
          "returnedType": "line",
          "returnedTypes": [
            "series line"
          ]
        },
        {
          "name": "label.copy",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Clones the label object.",
          "args": [],
          "syntax": "label.copy(id) → series label",
          "returns": "New label ID object which may be passed to label.setXXX and label.getXXX functions.",
          "seeAlso": [
            "[label.new](#fun_label.new)",
            "[label.delete](#fun_label.delete)"
          ],
          "thisType": [
            "series label"
          ],
          "examples": "//@version=5\nindicator('Last 100 bars highest/lowest', overlay = true)\nLOOKBACK = 100\nhighest = ta.highest(LOOKBACK)\nhighestBars = ta.highestbars(LOOKBACK)\nlowest = ta.lowest(LOOKBACK)\nlowestBars = ta.lowestbars(LOOKBACK)\nif barstate.islastconfirmedhistory\n\tvar labelHigh = label.new(bar_index + highestBars, highest, str.tostring(highest), color = color.green)\n\tvar labelLow = label.copy(labelHigh)\n\tlabel.set_xy(labelLow, bar_index + lowestBars, lowest)\n\tlabel.set_text(labelLow, str.tostring(lowest))\n\tlabel.set_color(labelLow, color.red)\n\tlabel.set_style(labelLow, label.style_label_up)",
          "methodName": "copy",
          "originalName": "label.copy",
          "methodSyntax": "label.copy() → series label",
          "returnedType": "label",
          "returnedTypes": [
            "series label"
          ]
        },
        {
          "name": "array.copy",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function creates a copy of an existing array.",
          "args": [],
          "syntax": "array.copy(id) → type[]",
          "returns": "A copy of an array.",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.get](#fun_array.get)",
            "[array.slice](#fun_array.slice)",
            "[array.sort](#fun_array.sort)"
          ],
          "thisType": [
            "array"
          ],
          "examples": "//@version=5\nindicator(\"array.copy example\")\nlength = 5\na = array.new_float(length, close)\nb = array.copy(a)\na := array.new_float(length, open)\nplot(array.sum(a) / length)\nplot(array.sum(b) / length)",
          "methodName": "copy",
          "originalName": "array.copy",
          "returnedType": "array",
          "methodSyntax": "array.copy() → type[]",
          "returnedTypes": [
            "array"
          ]
        },
        {
          "name": "matrix.copy",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function creates a new matrix which is a copy of the original.",
          "args": [],
          "syntax": "matrix.copy(id) → matrix<type>",
          "returns": "A new matrix object of the copied `id` matrix.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.get](#fun_matrix.get)",
            "[matrix.set](#fun_matrix.set)",
            "[matrix.columns](#fun_matrix.columns)",
            "[matrix.rows](#fun_matrix.rows)"
          ],
          "thisType": [
            "matrix"
          ],
          "examples": "//@version=5\nindicator(\"`matrix.copy()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x3 \"float\" matrix with `1` values.\n\tvar m1 = matrix.new<float>(2, 3, 1)\n\t\n\t// Copy the matrix to a new one.\n\t// Note that unlike what `matrix.copy()` does, \n\t// the simple assignment operation `m2 = m1`\n\t// would NOT create a new copy of the `m1` matrix.\n\t// It would merely create a copy of its ID referencing the same matrix.\n\tvar m2 = matrix.copy(m1)\n\t\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 5, 2, color.green)\n\ttable.cell(t, 0, 0, \"Original Matrix:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 0, \"Matrix Copy:\")\n\ttable.cell(t, 1, 1, str.tostring(m2))",
          "methodName": "copy",
          "originalName": "matrix.copy",
          "methodSyntax": "matrix.copy() → matrix<type>",
          "returnedType": "matrix",
          "returnedTypes": [
            "matrix"
          ]
        },
        {
          "name": "map.copy",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Creates a copy of an existing map.",
          "args": [],
          "syntax": "map.copy(id) → map<keyType, valueType>",
          "returns": "A copy of the `id` map.",
          "seeAlso": [
            "[map.new<type,type>](#fun_map.new%3Ctype,type%3E)",
            "[map.put](#fun_map.put)",
            "[map.keys](#fun_map.keys)",
            "[map.values](#fun_map.values)",
            "[map.get](#fun_map.get)",
            "[map.size](#fun_map.size)"
          ],
          "thisType": [
            "map"
          ],
          "examples": "//@version=5\nindicator(\"map.copy example\")\na = map.new<string, int>()\na.put(\"example\", 1)\nb = map.copy(a)\na := map.new<string, int>()\na.put(\"example\", 2)\nplot(a.get(\"example\"))\nplot(b.get(\"example\"))",
          "methodName": "copy",
          "originalName": "map.copy",
          "returnedType": "map",
          "methodSyntax": "map.copy() → map<keyType, valueType>",
          "returnedTypes": [
            "map"
          ]
        },
        {
          "name": "box.delete",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Deletes the specified box object. If it has already been deleted, does nothing.",
          "args": [],
          "syntax": "box.delete(id) → void",
          "seeAlso": [
            "[box.new](#fun_box.new)"
          ],
          "thisType": [
            "series box"
          ],
          "methodName": "delete",
          "originalName": "box.delete",
          "methodSyntax": "box.delete() → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "line.delete",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Deletes the specified line object. If it has already been deleted, does nothing.",
          "args": [],
          "syntax": "line.delete(id) → void",
          "seeAlso": [
            "[line.new](#fun_line.new)"
          ],
          "thisType": [
            "series line"
          ],
          "methodName": "delete",
          "originalName": "line.delete",
          "methodSyntax": "line.delete() → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "linefill.delete",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Deletes the specified linefill object. If it has already been deleted, does nothing.",
          "args": [],
          "syntax": "linefill.delete(id) → void",
          "thisType": [
            "series linefill"
          ],
          "methodName": "delete",
          "originalName": "linefill.delete",
          "methodSyntax": "linefill.delete() → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "label.delete",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Deletes the specified label object. If it has already been deleted, does nothing.",
          "args": [],
          "syntax": "label.delete(id) → void",
          "seeAlso": [
            "[label.new](#fun_label.new)"
          ],
          "thisType": [
            "series label"
          ],
          "methodName": "delete",
          "originalName": "label.delete",
          "methodSyntax": "label.delete() → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "table.delete",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function deletes a table.",
          "args": [],
          "syntax": "table.delete(table_id) → void",
          "seeAlso": [
            "[table.new](#fun_table.new)",
            "[table.clear](#fun_table.clear)"
          ],
          "thisType": [
            "series table"
          ],
          "examples": "//@version=5\nindicator(\"table.delete example\")\nvar testTable = table.new(position = position.top_right, columns = 2, rows = 1, bgcolor = color.yellow, border_width = 1)\nif barstate.islast\n    table.cell(table_id = testTable, column = 0, row = 0, text = \"Open is \" + str.tostring(open))\n    table.cell(table_id = testTable, column = 1, row = 0, text = \"Close is \" + str.tostring(close), bgcolor=color.teal)\nif barstate.isrealtime\n    table.delete(testTable)",
          "methodName": "delete",
          "originalName": "table.delete",
          "methodSyntax": "table.delete() → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "polyline.delete",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Deletes the specified [polyline](#op_polyline) object. It has no effect if the `id` doesn't exist.",
          "args": [],
          "syntax": "polyline.delete(id) → void",
          "thisType": [
            "series polyline"
          ],
          "methodName": "delete",
          "originalName": "polyline.delete",
          "methodSyntax": "polyline.delete() → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "box.get_left",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Returns the bar index or the UNIX time (depending on the last value used for 'xloc') of the left border of the box.",
          "args": [],
          "syntax": "box.get_left(id) → series int",
          "returns": "A bar index or a UNIX timestamp (in milliseconds).",
          "seeAlso": [
            "[box.new](#fun_box.new)",
            "[box.set_left](#fun_box.set_left)"
          ],
          "thisType": [
            "series box"
          ],
          "methodName": "get_left",
          "originalName": "box.get_left",
          "methodSyntax": "box.get_left() → series int",
          "returnedType": "int",
          "returnedTypes": [
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "name": "box.get_right",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Returns the bar index or the UNIX time (depending on the last value used for 'xloc') of the right border of the box.",
          "args": [],
          "syntax": "box.get_right(id) → series int",
          "returns": "A bar index or a UNIX timestamp (in milliseconds).",
          "seeAlso": [
            "[box.new](#fun_box.new)",
            "[box.set_right](#fun_box.set_right)"
          ],
          "thisType": [
            "series box"
          ],
          "methodName": "get_right",
          "originalName": "box.get_right",
          "methodSyntax": "box.get_right() → series int",
          "returnedType": "int",
          "returnedTypes": [
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "name": "box.get_top",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Returns the price value of the top border of the box.",
          "args": [],
          "syntax": "box.get_top(id) → series float",
          "returns": "The price value.",
          "seeAlso": [
            "[box.new](#fun_box.new)",
            "[box.set_top](#fun_box.set_top)"
          ],
          "thisType": [
            "series box"
          ],
          "methodName": "get_top",
          "originalName": "box.get_top",
          "methodSyntax": "box.get_top() → series float",
          "returnedType": "float",
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "name": "box.get_bottom",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Returns the price value of the bottom border of the box.",
          "args": [],
          "syntax": "box.get_bottom(id) → series float",
          "returns": "The price value.",
          "seeAlso": [
            "[box.new](#fun_box.new)",
            "[box.set_bottom](#fun_box.set_bottom)"
          ],
          "thisType": [
            "series box"
          ],
          "methodName": "get_bottom",
          "originalName": "box.get_bottom",
          "methodSyntax": "box.get_bottom() → series float",
          "returnedType": "float",
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "name": "box.set_left",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Sets the left coordinate of the box.",
          "args": [
            {
              "name": "left",
              "desc": "Bar index or bar time of the left border. Note that objects positioned using [xloc.bar_index](#var_xloc.bar_index) cannot be drawn further than 500 bars into the future.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "bar_index",
                "time"
              ]
            }
          ],
          "syntax": "box.set_left(id, left) → void",
          "seeAlso": [
            "[box.new](#fun_box.new)",
            "[box.get_left](#fun_box.get_left)"
          ],
          "thisType": [
            "series box"
          ],
          "methodName": "set_left",
          "originalName": "box.set_left",
          "methodSyntax": "box.set_left(left) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "box.set_lefttop",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Sets the left and top coordinates of the box.",
          "args": [
            {
              "name": "left",
              "desc": "Bar index or bar time of the left border.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "time",
                "bar_index",
                "time_close",
                "last_bar_index",
                "last_bar_time"
              ]
            },
            {
              "name": "top",
              "desc": "Price value of the top border.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "high",
                "low",
                "open",
                "close",
                "hl2"
              ]
            }
          ],
          "syntax": "box.set_lefttop(id, left, top) → void",
          "seeAlso": [
            "[box.new](#fun_box.new)",
            "[box.get_left](#fun_box.get_left)",
            "[box.get_top](#fun_box.get_top)"
          ],
          "thisType": [
            "series box"
          ],
          "methodName": "set_lefttop",
          "originalName": "box.set_lefttop",
          "methodSyntax": "box.set_lefttop(left, top) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "box.set_right",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Sets the right coordinate of the box.",
          "args": [
            {
              "name": "right",
              "desc": "Bar index or bar time of the right border. Note that objects positioned using [xloc.bar_index](#var_xloc.bar_index) cannot be drawn further than 500 bars into the future.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "bar_index",
                "time"
              ]
            }
          ],
          "syntax": "box.set_right(id, right) → void",
          "seeAlso": [
            "[box.new](#fun_box.new)",
            "[box.get_right](#fun_box.get_right)"
          ],
          "thisType": [
            "series box"
          ],
          "methodName": "set_right",
          "originalName": "box.set_right",
          "methodSyntax": "box.set_right(right) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "box.set_rightbottom",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Sets the right and bottom coordinates of the box.",
          "args": [
            {
              "name": "right",
              "desc": "Bar index or bar time of the right border.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "time",
                "bar_index",
                "time_close",
                "last_bar_index",
                "last_bar_time"
              ]
            },
            {
              "name": "bottom",
              "desc": "Price value of the bottom border.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "box.set_rightbottom(id, right, bottom) → void",
          "seeAlso": [
            "[box.new](#fun_box.new)",
            "[box.get_right](#fun_box.get_right)",
            "[box.get_bottom](#fun_box.get_bottom)"
          ],
          "thisType": [
            "series box"
          ],
          "methodName": "set_rightbottom",
          "originalName": "box.set_rightbottom",
          "methodSyntax": "box.set_rightbottom(right, bottom) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "box.set_top",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Sets the top coordinate of the box.",
          "args": [
            {
              "name": "top",
              "desc": "Price value of the top border.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "box.set_top(id, top) → void",
          "seeAlso": [
            "[box.new](#fun_box.new)",
            "[box.get_top](#fun_box.get_top)"
          ],
          "thisType": [
            "series box"
          ],
          "methodName": "set_top",
          "originalName": "box.set_top",
          "methodSyntax": "box.set_top(top) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "box.set_bottom",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Sets the bottom coordinate of the box.",
          "args": [
            {
              "name": "bottom",
              "desc": "Price value of the bottom border.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "box.set_bottom(id, bottom) → void",
          "seeAlso": [
            "[box.new](#fun_box.new)",
            "[box.get_bottom](#fun_box.get_bottom)"
          ],
          "thisType": [
            "series box"
          ],
          "methodName": "set_bottom",
          "originalName": "box.set_bottom",
          "methodSyntax": "box.set_bottom(bottom) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "box.set_border_color",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Sets the border color of the box.",
          "args": [
            {
              "name": "color",
              "desc": "New border color.",
              "default": null,
              "required": true,
              "displayType": "series color",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "possibleValues": [
                "colors"
              ]
            }
          ],
          "syntax": "box.set_border_color(id, color) → void",
          "seeAlso": [
            "[box.new](#fun_box.new)"
          ],
          "thisType": [
            "series box"
          ],
          "methodName": "set_border_color",
          "originalName": "box.set_border_color",
          "methodSyntax": "box.set_border_color(color) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "table.set_border_color",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function sets the color of the borders (excluding the outer frame) of the table\\`s cells.",
          "args": [
            {
              "name": "border_color",
              "desc": "The color of the borders.",
              "default": null,
              "required": false,
              "displayType": "series color",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "possibleValues": [
                "colors"
              ]
            }
          ],
          "syntax": "table.set_border_color(table_id, border_color) → void",
          "seeAlso": [
            "[table.clear](#fun_table.clear)",
            "[table.delete](#fun_table.delete)",
            "[table.new](#fun_table.new)",
            "[table.set_frame_color](#fun_table.set_frame_color)",
            "[table.set_border_width](#fun_table.set_border_width)",
            "[table.set_bgcolor](#fun_table.set_bgcolor)",
            "[table.set_frame_width](#fun_table.set_frame_width)",
            "[table.set_position](#fun_table.set_position)"
          ],
          "thisType": [
            "series table"
          ],
          "methodName": "set_border_color",
          "originalName": "table.set_border_color",
          "methodSyntax": "table.set_border_color(border_color) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "box.set_bgcolor",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Sets the background color of the box.",
          "args": [
            {
              "name": "color",
              "desc": "New background color.",
              "default": null,
              "required": true,
              "displayType": "series color",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "possibleValues": [
                "colors"
              ]
            }
          ],
          "syntax": "box.set_bgcolor(id, color) → void",
          "seeAlso": [
            "[box.new](#fun_box.new)"
          ],
          "thisType": [
            "series box"
          ],
          "methodName": "set_bgcolor",
          "originalName": "box.set_bgcolor",
          "methodSyntax": "box.set_bgcolor(color) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "table.set_bgcolor",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function sets the background color of a table.",
          "args": [
            {
              "name": "bgcolor",
              "desc": "The background color of the table",
              "default": null,
              "required": false,
              "displayType": "series color",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "possibleValues": [
                "colors"
              ]
            }
          ],
          "syntax": "table.set_bgcolor(table_id, bgcolor) → void",
          "seeAlso": [
            "[table.clear](#fun_table.clear)",
            "[table.delete](#fun_table.delete)",
            "[table.new](#fun_table.new)",
            "[table.set_border_color](#fun_table.set_border_color)",
            "[table.set_border_width](#fun_table.set_border_width)",
            "[table.set_frame_color](#fun_table.set_frame_color)",
            "[table.set_frame_width](#fun_table.set_frame_width)",
            "[table.set_position](#fun_table.set_position)"
          ],
          "thisType": [
            "series table"
          ],
          "methodName": "set_bgcolor",
          "originalName": "table.set_bgcolor",
          "methodSyntax": "table.set_bgcolor(bgcolor) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "box.set_border_width",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Sets the border width of the box.",
          "args": [
            {
              "name": "width",
              "desc": "Width of the four borders, in pixels.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            }
          ],
          "syntax": "box.set_border_width(id, width) → void",
          "seeAlso": [
            "[box.new](#fun_box.new)"
          ],
          "thisType": [
            "series box"
          ],
          "methodName": "set_border_width",
          "originalName": "box.set_border_width",
          "methodSyntax": "box.set_border_width(width) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "table.set_border_width",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function sets the width of the borders (excluding the outer frame) of the table\\`s cells.",
          "args": [
            {
              "name": "border_width",
              "desc": "The width of the borders. Optional. The default is 0.",
              "default": "0",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            }
          ],
          "syntax": "table.set_border_width(table_id, border_width) → void",
          "seeAlso": [
            "[table.clear](#fun_table.clear)",
            "[table.delete](#fun_table.delete)",
            "[table.new](#fun_table.new)",
            "[table.set_frame_color](#fun_table.set_frame_color)",
            "[table.set_frame_width](#fun_table.set_frame_width)",
            "[table.set_bgcolor](#fun_table.set_bgcolor)",
            "[table.set_border_color](#fun_table.set_border_color)",
            "[table.set_position](#fun_table.set_position)"
          ],
          "thisType": [
            "series table"
          ],
          "methodName": "set_border_width",
          "originalName": "table.set_border_width",
          "methodSyntax": "table.set_border_width(border_width) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "box.set_border_style",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Sets the border style of the box.",
          "args": [
            {
              "name": "style",
              "desc": "New border style.",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "line.style_solid",
                "line.style_dotted",
                "line.style_dashed"
              ]
            }
          ],
          "syntax": "box.set_border_style(id, style) → void",
          "seeAlso": [
            "[box.new](#fun_box.new)",
            "[line.style_solid](#const_line.style_solid)",
            "[line.style_dotted](#const_line.style_dotted)",
            "[line.style_dashed](#const_line.style_dashed)"
          ],
          "thisType": [
            "series box"
          ],
          "methodName": "set_border_style",
          "originalName": "box.set_border_style",
          "methodSyntax": "box.set_border_style(style) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "box.set_extend",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Sets extending type of the border of this box object. When [extend.none](#var_extend.none) is used, the horizontal borders start at the left border and end at the right border.  \nWith [extend.left](#var_extend.left) or [extend.right](#var_extend.right), the horizontal borders are extended indefinitely to the left or right of the box, respectively.  \nWith [extend.both](#var_extend.both), the horizontal borders are extended on both sides.",
          "args": [
            {
              "name": "extend",
              "desc": "New extending type.",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "extend.none",
                "extend.right",
                "extend.left",
                "extend.both"
              ]
            }
          ],
          "syntax": "box.set_extend(id, extend) → void",
          "seeAlso": [
            "[box.new](#fun_box.new)",
            "[extend.none](#const_extend.none)",
            "[extend.right](#const_extend.right)",
            "[extend.left](#const_extend.left)",
            "[extend.both](#const_extend.both)"
          ],
          "thisType": [
            "series box"
          ],
          "methodName": "set_extend",
          "originalName": "box.set_extend",
          "methodSyntax": "box.set_extend(extend) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "line.set_extend",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Sets extending type of this line object. If extend=[extend.none](#var_extend.none), draws segment starting at point (x1, y1) and ending at point (x2, y2).  \nIf extend is equal to [extend.right](#var_extend.right) or [extend.left](#var_extend.left), draws a ray starting at point (x1, y1) or (x2, y2), respectively.  \nIf extend=[extend.both](#var_extend.both), draws a straight line that goes through these points.",
          "args": [
            {
              "name": "extend",
              "desc": "New extending type.",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "extend.none",
                "extend.right",
                "extend.left",
                "extend.both"
              ]
            }
          ],
          "syntax": "line.set_extend(id, extend) → void",
          "seeAlso": [
            "[extend.none](#const_extend.none)",
            "[extend.right](#const_extend.right)",
            "[extend.left](#const_extend.left)",
            "[extend.both](#const_extend.both)",
            "[line.new](#fun_line.new)"
          ],
          "thisType": [
            "series line"
          ],
          "methodName": "set_extend",
          "originalName": "line.set_extend",
          "methodSyntax": "line.set_extend(extend) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "box.set_text_font_family",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function sets the font family of the text inside the box.",
          "args": [
            {
              "name": "text_font_family",
              "desc": "The font family of the text. \nPossible values: [font.family_default](#var_font.family_default), [font.family_monospace](#var_font.family_monospace).",
              "default": "font.family_default",
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "font.family_default",
                "font.family_monospace"
              ]
            }
          ],
          "syntax": "box.set_text_font_family(id, text_font_family) → void",
          "seeAlso": [
            "[box.new](#fun_box.new)",
            "[font.family_default](#const_font.family_default)",
            "[font.family_monospace](#const_font.family_monospace)"
          ],
          "thisType": [
            "series box"
          ],
          "examples": "//@version=5\nindicator(\"Example of setting the box font\")\nif barstate.islastconfirmedhistory\n    b = box.new(bar_index, open-ta.tr, bar_index-50, open-ta.tr*5, text=\"monospace\")\n    box.set_text_font_family(b, font.family_monospace)",
          "methodName": "set_text_font_family",
          "originalName": "box.set_text_font_family",
          "methodSyntax": "box.set_text_font_family(text_font_family) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "label.set_text_font_family",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function sets the font family of the text inside the label.",
          "args": [
            {
              "name": "text_font_family",
              "desc": "The font family of the text. \nPossible values: [font.family_default](#var_font.family_default), [font.family_monospace](#var_font.family_monospace).",
              "default": "font.family_default",
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "font.family_default",
                "font.family_monospace"
              ]
            }
          ],
          "syntax": "label.set_text_font_family(id, text_font_family) → void",
          "seeAlso": [
            "[label.new](#fun_label.new)",
            "[font.family_default](#const_font.family_default)",
            "[font.family_monospace](#const_font.family_monospace)"
          ],
          "thisType": [
            "series label"
          ],
          "examples": "//@version=5\nindicator(\"Example of setting the label font\")\nif barstate.islastconfirmedhistory\n    l = label.new(bar_index, 0, \"monospace\", yloc=yloc.abovebar)\n    label.set_text_font_family(l, font.family_monospace)",
          "methodName": "set_text_font_family",
          "originalName": "label.set_text_font_family",
          "methodSyntax": "label.set_text_font_family(text_font_family) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "box.set_text_halign",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function sets the horizontal alignment of the box\\`s text.",
          "args": [
            {
              "name": "text_halign",
              "desc": "The horizontal alignment of a box\\`s text. \nPossible values: [text.align_left](#var_text.align_left), [text.align_center](#var_text.align_center), [text.align_right](#var_text.align_right).",
              "default": "text.align_left",
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "text.align_left",
                "text.align_center",
                "text.align_right"
              ]
            }
          ],
          "syntax": "box.set_text_halign(id, text_halign) → void",
          "seeAlso": [
            "[box.set_text](#fun_box.set_text)",
            "[box.set_text_size](#fun_box.set_text_size)",
            "[box.set_text_valign](#fun_box.set_text_valign)",
            "[box.set_text_color](#fun_box.set_text_color)"
          ],
          "thisType": [
            "series box"
          ],
          "methodName": "set_text_halign",
          "originalName": "box.set_text_halign",
          "methodSyntax": "box.set_text_halign(text_halign) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "box.set_text_valign",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function sets the vertical alignment of a box\\`s text.",
          "args": [
            {
              "name": "text_valign",
              "desc": "The vertical alignment of the box\\`s text. \nPossible values: [text.align_top](#var_text.align_top), [text.align_center](#var_text.align_center), [text.align_bottom](#var_text.align_bottom).",
              "default": "text.align_center",
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "text.align_top",
                "text.align_center",
                "text.align_bottom"
              ]
            }
          ],
          "syntax": "box.set_text_valign(id, text_valign) → void",
          "seeAlso": [
            "[box.set_text](#fun_box.set_text)",
            "[box.set_text_size](#fun_box.set_text_size)",
            "[box.set_text_color](#fun_box.set_text_color)",
            "[box.set_text_halign](#fun_box.set_text_halign)"
          ],
          "thisType": [
            "series box"
          ],
          "methodName": "set_text_valign",
          "originalName": "box.set_text_valign",
          "methodSyntax": "box.set_text_valign(text_valign) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "box.set_text_size",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function sets the size of the box\\`s text.",
          "args": [
            {
              "name": "text_size",
              "desc": "The size of the text. \nPossible values: [size.auto](#var_size.auto), [size.tiny](#var_size.tiny), [size.small](#var_size.small), [size.normal](#var_size.normal), [size.large](#var_size.large), [size.huge](#var_size.huge).",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "size.auto",
                "size.tiny",
                "size.small",
                "size.normal",
                "size.large",
                "size.huge"
              ]
            }
          ],
          "syntax": "box.set_text_size(id, text_size) → void",
          "seeAlso": [
            "[box.set_text](#fun_box.set_text)",
            "[box.set_text_color](#fun_box.set_text_color)",
            "[box.set_text_valign](#fun_box.set_text_valign)",
            "[box.set_text_halign](#fun_box.set_text_halign)"
          ],
          "thisType": [
            "series box"
          ],
          "methodName": "set_text_size",
          "originalName": "box.set_text_size",
          "methodSyntax": "box.set_text_size(text_size) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "box.set_text",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function sets the text in the box.",
          "args": [
            {
              "name": "text",
              "desc": "The text to be displayed inside the box.",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "box.set_text(id, text) → void",
          "seeAlso": [
            "[box.set_text_color](#fun_box.set_text_color)",
            "[box.set_text_size](#fun_box.set_text_size)",
            "[box.set_text_valign](#fun_box.set_text_valign)",
            "[box.set_text_halign](#fun_box.set_text_halign)"
          ],
          "thisType": [
            "series box"
          ],
          "methodName": "set_text",
          "originalName": "box.set_text",
          "methodSyntax": "box.set_text(text) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "label.set_text",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Sets label text",
          "args": [
            {
              "name": "text",
              "desc": "New label text.",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "label.set_text(id, text) → void",
          "seeAlso": [
            "[label.new](#fun_label.new)"
          ],
          "thisType": [
            "series label"
          ],
          "methodName": "set_text",
          "originalName": "label.set_text",
          "methodSyntax": "label.set_text(text) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "box.set_text_color",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function sets the color of the text inside the box.",
          "args": [
            {
              "name": "text_color",
              "desc": "The color of the text.",
              "default": null,
              "required": true,
              "displayType": "series color",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "possibleValues": [
                "colors"
              ]
            }
          ],
          "syntax": "box.set_text_color(id, text_color) → void",
          "seeAlso": [
            "[box.set_text](#fun_box.set_text)",
            "[box.set_text_size](#fun_box.set_text_size)",
            "[box.set_text_valign](#fun_box.set_text_valign)",
            "[box.set_text_halign](#fun_box.set_text_halign)"
          ],
          "thisType": [
            "series box"
          ],
          "methodName": "set_text_color",
          "originalName": "box.set_text_color",
          "methodSyntax": "box.set_text_color(text_color) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "box.set_text_wrap",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function sets the mode of wrapping of the text inside the box.",
          "args": [
            {
              "name": "text_wrap",
              "desc": "The mode of the wrapping. \nPossible values: [text.wrap_auto](#var_text.wrap_auto), [text.wrap_none](#var_text.wrap_none).",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "text.wrap_auto",
                "text.wrap_none"
              ]
            }
          ],
          "syntax": "box.set_text_wrap(id, text_wrap) → void",
          "seeAlso": [
            "[box.set_text](#fun_box.set_text)",
            "[box.set_text_size](#fun_box.set_text_size)",
            "[box.set_text_valign](#fun_box.set_text_valign)",
            "[box.set_text_halign](#fun_box.set_text_halign)",
            "[box.set_text_color](#fun_box.set_text_color)"
          ],
          "thisType": [
            "series box"
          ],
          "methodName": "set_text_wrap",
          "originalName": "box.set_text_wrap",
          "methodSyntax": "box.set_text_wrap(text_wrap) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "line.set_x1",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Sets bar index or bar time (depending on the xloc) of the first point.",
          "args": [
            {
              "name": "x",
              "desc": "Bar index or bar time. Note that objects positioned using [xloc.bar_index](#var_xloc.bar_index) cannot be drawn further than 500 bars into the future.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "time",
                "bar_index",
                "time_close",
                "last_bar_index",
                "last_bar_time"
              ]
            }
          ],
          "syntax": "line.set_x1(id, x) → void",
          "seeAlso": [
            "[line.new](#fun_line.new)"
          ],
          "thisType": [
            "series line"
          ],
          "methodName": "set_x1",
          "originalName": "line.set_x1",
          "methodSyntax": "line.set_x1(x) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "line.set_y1",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Sets price of the first point",
          "args": [
            {
              "name": "y",
              "desc": "Price.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "high",
                "low",
                "open",
                "close",
                "close[1]"
              ]
            }
          ],
          "syntax": "line.set_y1(id, y) → void",
          "seeAlso": [
            "[line.new](#fun_line.new)"
          ],
          "thisType": [
            "series line"
          ],
          "methodName": "set_y1",
          "originalName": "line.set_y1",
          "methodSyntax": "line.set_y1(y) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "line.set_xy1",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Sets bar index/time and price of the first point.",
          "args": [
            {
              "name": "x",
              "desc": "Bar index or bar time. Note that objects positioned using [xloc.bar_index](#var_xloc.bar_index) cannot be drawn further than 500 bars into the future.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "time",
                "bar_index",
                "time_close",
                "last_bar_index",
                "last_bar_time"
              ]
            },
            {
              "name": "y",
              "desc": "Price.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "line.set_xy1(id, x, y) → void",
          "seeAlso": [
            "[line.new](#fun_line.new)"
          ],
          "thisType": [
            "series line"
          ],
          "methodName": "set_xy1",
          "originalName": "line.set_xy1",
          "methodSyntax": "line.set_xy1(x, y) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "line.set_x2",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Sets bar index or bar time (depending on the xloc) of the second point.",
          "args": [
            {
              "name": "x",
              "desc": "Bar index or bar time. Note that objects positioned using [xloc.bar_index](#var_xloc.bar_index) cannot be drawn further than 500 bars into the future.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "time",
                "bar_index",
                "time_close",
                "last_bar_index",
                "last_bar_time"
              ]
            }
          ],
          "syntax": "line.set_x2(id, x) → void",
          "seeAlso": [
            "[line.new](#fun_line.new)"
          ],
          "thisType": [
            "series line"
          ],
          "methodName": "set_x2",
          "originalName": "line.set_x2",
          "methodSyntax": "line.set_x2(x) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "line.set_y2",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Sets price of the second point.",
          "args": [
            {
              "name": "y",
              "desc": "Price.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "line.set_y2(id, y) → void",
          "seeAlso": [
            "[line.new](#fun_line.new)"
          ],
          "thisType": [
            "series line"
          ],
          "methodName": "set_y2",
          "originalName": "line.set_y2",
          "methodSyntax": "line.set_y2(y) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "line.set_xy2",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Sets bar index/time and price of the second point",
          "args": [
            {
              "name": "x",
              "desc": "Bar index or bar time.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "bar_index",
                "time",
                "time_close",
                "last_bar_index",
                "last_bar_time"
              ]
            },
            {
              "name": "y",
              "desc": "Price.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "high",
                "low",
                "open",
                "close",
                "close[1]"
              ]
            }
          ],
          "syntax": "line.set_xy2(id, x, y) → void",
          "seeAlso": [
            "[line.new](#fun_line.new)"
          ],
          "thisType": [
            "series line"
          ],
          "methodName": "set_xy2",
          "originalName": "line.set_xy2",
          "methodSyntax": "line.set_xy2(x, y) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "line.set_xloc",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Sets x-location and new bar index/time values.",
          "args": [
            {
              "name": "x1",
              "desc": "Bar index or bar time of the first point.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "time",
                "bar_index",
                "time_close",
                "last_bar_index",
                "last_bar_time"
              ]
            },
            {
              "name": "x2",
              "desc": "Bar index or bar time of the second point.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "time",
                "bar_index",
                "time_close",
                "last_bar_index",
                "last_bar_time"
              ]
            },
            {
              "name": "xloc",
              "desc": "New x-location value.",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "xloc.bar_index",
                "xloc.bar_time"
              ]
            }
          ],
          "syntax": "line.set_xloc(id, x1, x2, xloc) → void",
          "seeAlso": [
            "[xloc.bar_index](#const_xloc.bar_index)",
            "[xloc.bar_time](#const_xloc.bar_time)",
            "[line.new](#fun_line.new)"
          ],
          "thisType": [
            "series line"
          ],
          "methodName": "set_xloc",
          "originalName": "line.set_xloc",
          "methodSyntax": "line.set_xloc(x1, x2, xloc) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "label.set_xloc",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Sets x-location and new bar index/time value.",
          "args": [
            {
              "name": "x",
              "desc": "New bar index or bar time of the label position.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "bar_index",
                "time"
              ]
            },
            {
              "name": "xloc",
              "desc": "New x-location value.",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "xloc.bar_index",
                "xloc.bar_time"
              ]
            }
          ],
          "syntax": "label.set_xloc(id, x, xloc) → void",
          "seeAlso": [
            "[xloc.bar_index](#const_xloc.bar_index)",
            "[xloc.bar_time](#const_xloc.bar_time)",
            "[label.new](#fun_label.new)"
          ],
          "thisType": [
            "series label"
          ],
          "methodName": "set_xloc",
          "originalName": "label.set_xloc",
          "methodSyntax": "label.set_xloc(x, xloc) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "line.set_color",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Sets the line color",
          "args": [
            {
              "name": "color",
              "desc": "New line color",
              "default": null,
              "required": true,
              "displayType": "series color",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "possibleValues": [
                "colors"
              ]
            }
          ],
          "syntax": "line.set_color(id, color) → void",
          "seeAlso": [
            "[line.new](#fun_line.new)"
          ],
          "thisType": [
            "series line"
          ],
          "methodName": "set_color",
          "originalName": "line.set_color",
          "methodSyntax": "line.set_color(color) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "linefill.set_color",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function sets the color of the linefill object passed to it.",
          "args": [
            {
              "name": "color",
              "desc": "The color of the linefill object.",
              "default": null,
              "required": true,
              "displayType": "series color",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "possibleValues": [
                "colors"
              ]
            }
          ],
          "syntax": "linefill.set_color(id, color) → void",
          "thisType": [
            "series linefill"
          ],
          "methodName": "set_color",
          "originalName": "linefill.set_color",
          "methodSyntax": "linefill.set_color(color) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "label.set_color",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Sets label bgcolor",
          "args": [
            {
              "name": "color",
              "desc": "New label bgcolor",
              "default": null,
              "required": true,
              "displayType": "series color",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "possibleValues": [
                "colors"
              ]
            }
          ],
          "syntax": "label.set_color(id, color) → void",
          "seeAlso": [
            "[label.new](#fun_label.new)"
          ],
          "thisType": [
            "series label"
          ],
          "methodName": "set_color",
          "originalName": "label.set_color",
          "methodSyntax": "label.set_color(color) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "line.set_style",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Sets the line style",
          "args": [
            {
              "name": "style",
              "desc": "New line style.",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "line.style_solid",
                "line.style_dotted",
                "line.style_dashed",
                "line.style_arrow_left",
                "line.style_arrow_right",
                "line.style_arrow_both"
              ]
            }
          ],
          "syntax": "line.set_style(id, style) → void",
          "seeAlso": [
            "[line.style_solid](#const_line.style_solid)",
            "[line.style_dotted](#const_line.style_dotted)",
            "[line.style_dashed](#const_line.style_dashed)",
            "[line.style_arrow_left](#const_line.style_arrow_left)",
            "[line.style_arrow_right](#const_line.style_arrow_right)",
            "[line.style_arrow_both](#const_line.style_arrow_both)",
            "[line.new](#fun_line.new)"
          ],
          "thisType": [
            "series line"
          ],
          "methodName": "set_style",
          "originalName": "line.set_style",
          "methodSyntax": "line.set_style(style) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "label.set_style",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Sets label style.",
          "args": [
            {
              "name": "style",
              "desc": "New label style. \nPossible values: [label.style_none](#var_label.style_none), [label.style_xcross](#var_label.style_xcross), [label.style_cross](#var_label.style_cross), [label.style_triangleup](#var_label.style_triangleup), [label.style_triangledown](#var_label.style_triangledown), [label.style_flag](#var_label.style_flag), [label.style_circle](#var_label.style_circle), [label.style_arrowup](#var_label.style_arrowup), [label.style_arrowdown](#var_label.style_arrowdown), [label.style_label_up](#var_label.style_label_up), [label.style_label_down](#var_label.style_label_down), [label.style_label_left](#var_label.style_label_left), [label.style_label_right](#var_label.style_label_right), [label.style_label_lower_left](#var_label.style_label_lower_left), [label.style_label_lower_right](#var_label.style_label_lower_right), [label.style_label_upper_left](#var_label.style_label_upper_left), [label.style_label_upper_right](#var_label.style_label_upper_right), [label.style_label_center](#var_label.style_label_center), [label.style_square](#var_label.style_square), [label.style_diamond](#var_label.style_diamond), [label.style_text_outline](#var_label.style_text_outline).",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "label.style_none",
                "label.style_xcross",
                "label.style_cross",
                "label.style_triangleup",
                "label.style_triangledown",
                "label.style_flag",
                "label.style_circle",
                "label.style_arrowup",
                "label.style_arrowdown",
                "label.style_label_up",
                "label.style_label_down",
                "label.style_label_left",
                "label.style_label_right",
                "label.style_label_lower_left",
                "label.style_label_lower_right",
                "label.style_label_upper_left",
                "label.style_label_upper_right",
                "label.style_label_center",
                "label.style_square",
                "label.style_diamond",
                "label.style_text_outline"
              ]
            }
          ],
          "syntax": "label.set_style(id, style) → void",
          "seeAlso": [
            "[label.new](#fun_label.new)"
          ],
          "thisType": [
            "series label"
          ],
          "methodName": "set_style",
          "originalName": "label.set_style",
          "methodSyntax": "label.set_style(style) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "line.set_width",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Sets the line width.",
          "args": [
            {
              "name": "width",
              "desc": "New line width in pixels.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            }
          ],
          "syntax": "line.set_width(id, width) → void",
          "seeAlso": [
            "[line.new](#fun_line.new)"
          ],
          "thisType": [
            "series line"
          ],
          "methodName": "set_width",
          "originalName": "line.set_width",
          "methodSyntax": "line.set_width(width) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "line.get_x1",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Returns UNIX time or bar index (depending on the last xloc value set) of the first point of the line.",
          "args": [],
          "syntax": "line.get_x1(id) → series int",
          "returns": "UNIX timestamp (in milliseconds) or bar index.",
          "seeAlso": [
            "[line.new](#fun_line.new)"
          ],
          "thisType": [
            "series line"
          ],
          "examples": "//@version=5\nindicator(\"line.get_x1\")\nmy_line = line.new(time, open, time + 60 * 60 * 24, close, xloc=xloc.bar_time)\na = line.get_x1(my_line)\nplot(time - line.get_x1(my_line)) //draws zero plot",
          "methodName": "get_x1",
          "originalName": "line.get_x1",
          "methodSyntax": "line.get_x1() → series int",
          "returnedType": "int",
          "returnedTypes": [
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "name": "line.get_y1",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Returns price of the first point of the line.",
          "args": [],
          "syntax": "line.get_y1(id) → series float",
          "returns": "Price value.",
          "seeAlso": [
            "[line.new](#fun_line.new)"
          ],
          "thisType": [
            "series line"
          ],
          "methodName": "get_y1",
          "originalName": "line.get_y1",
          "methodSyntax": "line.get_y1() → series float",
          "returnedType": "float",
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "name": "line.get_x2",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Returns UNIX time or bar index (depending on the last xloc value set) of the second point of the line.",
          "args": [],
          "syntax": "line.get_x2(id) → series int",
          "returns": "UNIX timestamp (in milliseconds) or bar index.",
          "seeAlso": [
            "[line.new](#fun_line.new)"
          ],
          "thisType": [
            "series line"
          ],
          "methodName": "get_x2",
          "originalName": "line.get_x2",
          "methodSyntax": "line.get_x2() → series int",
          "returnedType": "int",
          "returnedTypes": [
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "name": "line.get_y2",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Returns price of the second point of the line.",
          "args": [],
          "syntax": "line.get_y2(id) → series float",
          "returns": "Price value.",
          "seeAlso": [
            "[line.new](#fun_line.new)"
          ],
          "thisType": [
            "series line"
          ],
          "methodName": "get_y2",
          "originalName": "line.get_y2",
          "methodSyntax": "line.get_y2() → series float",
          "returnedType": "float",
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "name": "line.get_price",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Returns the price level of a line at a given bar index.",
          "args": [
            {
              "name": "x",
              "desc": "Bar index for which price is required.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "bar_index"
              ]
            }
          ],
          "syntax": "line.get_price(id, x) → series float",
          "remarks": "The line is considered to have been created using 'extend=extend.both'.\nThis function can only be called for lines created using 'xloc.bar_index'.  \nIf you try to call it for a line created with 'xloc.bar_time', it will generate an error.",
          "returns": "Price value of line 'id' at bar index 'x'.",
          "seeAlso": [
            "[line.new](#fun_line.new)"
          ],
          "thisType": [
            "series line"
          ],
          "examples": "//@version=5\nindicator(\"GetPrice\", overlay=true)\nvar line l = na\nif bar_index == 10\n    l := line.new(0, high[5], bar_index, high)\nplot(line.get_price(l, bar_index), color=color.green)",
          "methodName": "get_price",
          "originalName": "line.get_price",
          "methodSyntax": "line.get_price(x) → series float",
          "returnedType": "float",
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "name": "linefill.get_line1",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Returns the ID of the first line used in the `id` linefill.",
          "args": [],
          "syntax": "linefill.get_line1(id) → series line",
          "thisType": [
            "series linefill"
          ],
          "methodName": "get_line1",
          "originalName": "linefill.get_line1",
          "methodSyntax": "linefill.get_line1() → series line",
          "returnedType": "line",
          "returnedTypes": [
            "series line"
          ]
        },
        {
          "name": "linefill.get_line2",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Returns the ID of the second line used in the `id` linefill.",
          "args": [],
          "syntax": "linefill.get_line2(id) → series line",
          "thisType": [
            "series linefill"
          ],
          "methodName": "get_line2",
          "originalName": "linefill.get_line2",
          "methodSyntax": "linefill.get_line2() → series line",
          "returnedType": "line",
          "returnedTypes": [
            "series line"
          ]
        },
        {
          "name": "label.set_x",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Sets bar index or bar time (depending on the xloc) of the label position.",
          "args": [
            {
              "name": "x",
              "desc": "New bar index or bar time of the label position. Note that objects positioned using [xloc.bar_index](#var_xloc.bar_index) cannot be drawn further than 500 bars into the future.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "time",
                "bar_index",
                "time_close",
                "last_bar_index",
                "last_bar_time"
              ]
            }
          ],
          "syntax": "label.set_x(id, x) → void",
          "seeAlso": [
            "[label.new](#fun_label.new)"
          ],
          "thisType": [
            "series label"
          ],
          "methodName": "set_x",
          "originalName": "label.set_x",
          "methodSyntax": "label.set_x(x) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "label.set_y",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Sets price of the label position",
          "args": [
            {
              "name": "y",
              "desc": "New price of the label position.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "label.set_y(id, y) → void",
          "seeAlso": [
            "[label.new](#fun_label.new)"
          ],
          "thisType": [
            "series label"
          ],
          "methodName": "set_y",
          "originalName": "label.set_y",
          "methodSyntax": "label.set_y(y) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "label.set_xy",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Sets bar index/time and price of the label position.",
          "args": [
            {
              "name": "x",
              "desc": "New bar index or bar time of the label position. Note that objects positioned using [xloc.bar_index](#var_xloc.bar_index) cannot be drawn further than 500 bars into the future.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "time",
                "bar_index",
                "time_close",
                "last_bar_index",
                "last_bar_time"
              ]
            },
            {
              "name": "y",
              "desc": "New price of the label position.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "label.set_xy(id, x, y) → void",
          "seeAlso": [
            "[label.new](#fun_label.new)"
          ],
          "thisType": [
            "series label"
          ],
          "methodName": "set_xy",
          "originalName": "label.set_xy",
          "methodSyntax": "label.set_xy(x, y) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "label.set_yloc",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Sets new y-location calculation algorithm.",
          "args": [
            {
              "name": "yloc",
              "desc": "New y-location value.",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "yloc.price",
                "yloc.abovebar",
                "yloc.belowbar"
              ]
            }
          ],
          "syntax": "label.set_yloc(id, yloc) → void",
          "seeAlso": [
            "[yloc.price](#const_yloc.price)",
            "[yloc.abovebar](#const_yloc.abovebar)",
            "[yloc.belowbar](#const_yloc.belowbar)",
            "[label.new](#fun_label.new)"
          ],
          "thisType": [
            "series label"
          ],
          "methodName": "set_yloc",
          "originalName": "label.set_yloc",
          "methodSyntax": "label.set_yloc(yloc) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "label.set_textcolor",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Sets color of the label text.",
          "args": [
            {
              "name": "textcolor",
              "desc": "New text color.",
              "default": null,
              "required": true,
              "displayType": "series color",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "possibleValues": [
                "colors"
              ]
            }
          ],
          "syntax": "label.set_textcolor(id, textcolor) → void",
          "seeAlso": [
            "[label.new](#fun_label.new)"
          ],
          "thisType": [
            "series label"
          ],
          "methodName": "set_textcolor",
          "originalName": "label.set_textcolor",
          "methodSyntax": "label.set_textcolor(textcolor) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "label.set_size",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Sets arrow and text size of the specified label object.",
          "args": [
            {
              "name": "size",
              "desc": "\nPossible values: [size.auto](#var_size.auto), [size.tiny](#var_size.tiny), [size.small](#var_size.small), [size.normal](#var_size.normal), [size.large](#var_size.large), [size.huge](#var_size.huge).  \nDefault value is [size.auto](#var_size.auto).",
              "default": "size.auto",
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "size.auto",
                "size.tiny",
                "size.small",
                "size.normal",
                "size.large",
                "size.huge"
              ]
            }
          ],
          "syntax": "label.set_size(id, size) → void",
          "seeAlso": [
            "[size.auto](#const_size.auto)",
            "[size.tiny](#const_size.tiny)",
            "[size.small](#const_size.small)",
            "[size.normal](#const_size.normal)",
            "[size.large](#const_size.large)",
            "[size.huge](#const_size.huge)",
            "[label.new](#fun_label.new)"
          ],
          "thisType": [
            "series label"
          ],
          "methodName": "set_size",
          "originalName": "label.set_size",
          "methodSyntax": "label.set_size(size) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "label.set_textalign",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Sets the alignment for the label text.",
          "args": [
            {
              "name": "textalign",
              "desc": "Label text alignment. \nPossible values: [text.align_left](#var_text.align_left), [text.align_center](#var_text.align_center), [text.align_right](#var_text.align_right).",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "text.align_left",
                "text.align_center",
                "text.align_right"
              ]
            }
          ],
          "syntax": "label.set_textalign(id, textalign) → void",
          "seeAlso": [
            "[text.align_left](#const_text.align_left)",
            "[text.align_center](#const_text.align_center)",
            "[text.align_right](#const_text.align_right)",
            "[label.new](#fun_label.new)"
          ],
          "thisType": [
            "series label"
          ],
          "methodName": "set_textalign",
          "originalName": "label.set_textalign",
          "methodSyntax": "label.set_textalign(textalign) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "label.set_tooltip",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Sets the tooltip text.",
          "args": [
            {
              "name": "tooltip",
              "desc": "Tooltip text.",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "label.set_tooltip(id, tooltip) → void",
          "seeAlso": [
            "[label.new](#fun_label.new)"
          ],
          "thisType": [
            "series label"
          ],
          "methodName": "set_tooltip",
          "originalName": "label.set_tooltip",
          "methodSyntax": "label.set_tooltip(tooltip) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "label.get_x",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Returns UNIX time or bar index (depending on the last xloc value set) of this label\\`s position.",
          "args": [],
          "syntax": "label.get_x(id) → series int",
          "returns": "UNIX timestamp (in milliseconds) or bar index.",
          "seeAlso": [
            "[label.new](#fun_label.new)"
          ],
          "thisType": [
            "series label"
          ],
          "examples": "//@version=5\nindicator(\"label.get_x\")\nmy_label = label.new(time, open, text=\"Open bar text\", xloc=xloc.bar_time)\na = label.get_x(my_label)\nplot(time - label.get_x(my_label)) //draws zero plot",
          "methodName": "get_x",
          "originalName": "label.get_x",
          "methodSyntax": "label.get_x() → series int",
          "returnedType": "int",
          "returnedTypes": [
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "name": "label.get_y",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Returns price of this label\\`s position.",
          "args": [],
          "syntax": "label.get_y(id) → series float",
          "returns": "Floating point value representing price.",
          "seeAlso": [
            "[label.new](#fun_label.new)"
          ],
          "thisType": [
            "series label"
          ],
          "methodName": "get_y",
          "originalName": "label.get_y",
          "methodSyntax": "label.get_y() → series float",
          "returnedType": "float",
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "name": "label.get_text",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Returns the text of this label object.",
          "args": [],
          "syntax": "label.get_text(id) → series string",
          "returns": "String object containing the text of this label.",
          "seeAlso": [
            "[label.new](#fun_label.new)"
          ],
          "thisType": [
            "series label"
          ],
          "examples": "//@version=5\nindicator(\"label.get_text\")\nmy_label = label.new(time, open, text=\"Open bar text\", xloc=xloc.bar_time)\na = label.get_text(my_label)\nlabel.new(time, close, text = a + \" new\", xloc=xloc.bar_time)",
          "methodName": "get_text",
          "originalName": "label.get_text",
          "methodSyntax": "label.get_text() → series string",
          "returnedType": "string",
          "returnedTypes": [
            "series string",
            "simple string",
            "input string",
            "const string"
          ]
        },
        {
          "name": "array.slice",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function creates a slice from an existing array. If an object from the slice changes, the changes are applied to both the new and the original arrays.",
          "args": [
            {
              "name": "index_from",
              "desc": "Zero-based index at which to begin extraction.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "index_to",
              "desc": "Zero-based index before which to end extraction. The function extracts up to but not including the element with this index.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "array.slice(id, index_from, index_to) → type[]",
          "returns": "A shallow copy of an array\\`s slice.",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.get](#fun_array.get)",
            "[array.slice](#fun_array.slice)",
            "[array.sort](#fun_array.sort)"
          ],
          "thisType": [
            "array"
          ],
          "examples": "//@version=5\nindicator(\"array.slice example\")\na = array.new_float(0)\nfor i = 0 to 9\n\tarray.push(a, close[i])\n// take elements from 0 to 4\n// *note that changes in slice also modify original array \nslice = array.slice(a, 0, 5)\nplot(array.sum(a) / 10)\nplot(array.sum(slice) / 5)",
          "methodName": "slice",
          "originalName": "array.slice",
          "methodSyntax": "array.slice(index_from, index_to) → type[]"
        },
        {
          "name": "array.size",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function returns the number of elements in an array.",
          "args": [],
          "syntax": "array.size(id) → series int",
          "returns": "The number of elements in the array.",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.sum](#fun_array.sum)",
            "[array.slice](#fun_array.slice)",
            "[array.sort](#fun_array.sort)"
          ],
          "thisType": [
            "array"
          ],
          "examples": "//@version=5\nindicator(\"array.size example\")\na = array.new_float(0)\nfor i = 0 to 9\n\tarray.push(a, close[i])\n// note that changes in slice also modify original array\nslice = array.slice(a, 0, 5)\narray.push(slice, open)\n// size was changed in slice and in original array\nplot(array.size(a))\nplot(array.size(slice))",
          "methodName": "size",
          "originalName": "array.size",
          "methodSyntax": "array.size() → series int",
          "returnedType": "int",
          "returnedTypes": [
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "name": "map.size",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Returns the number of key-value pairs in the `id` map.",
          "args": [],
          "syntax": "map.size(id) → series int",
          "seeAlso": [
            "[map.new<type",
            "type>](#fun_map.new%3Ctype,type%3E)",
            "[map.put](#fun_map.put)",
            "[map.keys](#fun_map.keys)",
            "[map.values](#fun_map.values)",
            "[map.get](#fun_map.get)"
          ],
          "thisType": [
            "map"
          ],
          "examples": "//@version=5\nindicator(\"map.size example\")\na = map.new<int, int>()\nsize = 10\nfor i = 0 to size\n\ta.put(i, size-i)\nplot(map.size(a))",
          "methodName": "size",
          "originalName": "map.size",
          "methodSyntax": "map.size() → series int",
          "returnedType": "int",
          "returnedTypes": [
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "name": "array.first",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Returns the array\\`s first element. Throws a runtime error if the array is empty.",
          "args": [],
          "syntax": "array.first(id) → series type",
          "seeAlso": [
            "[array.last](#fun_array.last)",
            "[array.get](#fun_array.get)"
          ],
          "thisType": [
            "array"
          ],
          "examples": "//@version=5\nindicator(\"array.first example\")\narr = array.new_int(3, 10)\nplot(array.first(arr))",
          "methodName": "first",
          "originalName": "array.first",
          "methodSyntax": "array.first() → series type"
        },
        {
          "name": "array.last",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Returns the array\\`s last element. Throws a runtime error if the array is empty.",
          "args": [],
          "syntax": "array.last(id) → series type",
          "seeAlso": [
            "[array.first](#fun_array.first)",
            "[array.get](#fun_array.get)"
          ],
          "thisType": [
            "array"
          ],
          "examples": "//@version=5\nindicator(\"array.last example\")\narr = array.new_int(3, 10)\nplot(array.last(arr))",
          "methodName": "last",
          "originalName": "array.last",
          "methodSyntax": "array.last() → series type"
        },
        {
          "name": "array.every",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Returns [true](#op_true) if all elements of the `id` array are [true](#op_true), [false](#op_false) otherwise.",
          "args": [],
          "syntax": "array.every(id) → series bool",
          "remarks": "This function also works with arrays of [int](#op_int) and [float](#op_float) types, in which case zero values are considered [false](#op_false), and all others [true](#op_true).",
          "seeAlso": [
            "[array.some](#fun_array.some)",
            "[array.get](#fun_array.get)"
          ],
          "thisType": [
            "array<bool>"
          ],
          "methodName": "every",
          "originalName": "array.every",
          "methodSyntax": "array.every() → series bool",
          "returnedType": "bool",
          "returnedTypes": [
            "series bool",
            "simple bool",
            "input bool",
            "const bool"
          ]
        },
        {
          "name": "array.some",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Returns [true](#op_true) if at least one element of the `id` array is [true](#op_true), [false](#op_false) otherwise.",
          "args": [],
          "syntax": "array.some(id) → series bool",
          "remarks": "This function also works with arrays of [int](#op_int) and [float](#op_float) types, in which case zero values are considered [false](#op_false), and all others [true](#op_true).",
          "seeAlso": [
            "[array.every](#fun_array.every)",
            "[array.get](#fun_array.get)"
          ],
          "thisType": [
            "array<bool>"
          ],
          "methodName": "some",
          "originalName": "array.some",
          "methodSyntax": "array.some() → series bool",
          "returnedType": "bool",
          "returnedTypes": [
            "series bool",
            "simple bool",
            "input bool",
            "const bool"
          ]
        },
        {
          "name": "array.get",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function returns the value of the element at the specified index.",
          "args": [
            {
              "name": "index",
              "desc": "The index of the element whose value is to be returned.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "array.get(id, index) → series type",
          "returns": "The array element\\`s value.",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.set](#fun_array.set)",
            "[array.slice](#fun_array.slice)",
            "[array.sort](#fun_array.sort)"
          ],
          "thisType": [
            "array"
          ],
          "examples": "//@version=5\nindicator(\"array.get example\")\na = array.new_float(0)\nfor i = 0 to 9\n\tarray.push(a, close[i] - open[i])\nplot(array.get(a, 9))",
          "methodName": "get",
          "originalName": "array.get",
          "methodSyntax": "array.get(index) → series type"
        },
        {
          "name": "matrix.get",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function returns the element with the specified index of the matrix.",
          "args": [
            {
              "name": "row",
              "desc": "Index of the required row.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            },
            {
              "name": "column",
              "desc": "Index of the required column.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            }
          ],
          "syntax": "matrix.get(id, row, column) → <matrix_type>",
          "remarks": "Indexing of the rows and columns starts at zero.",
          "returns": "The value of the element at the `row` and `column` index of the `id` matrix.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.set](#fun_matrix.set)",
            "[matrix.columns](#fun_matrix.columns)",
            "[matrix.rows](#fun_matrix.rows)"
          ],
          "thisType": [
            "matrix"
          ],
          "examples": "//@version=5\nindicator('matrix.get() example', \"\", true)\n\n// Create a 2x3 \"float\" matrix from the `hl2` values.\nm = matrix.new<float>(2, 3, hl2)\n\n// Return the value of the element at index [0, 0] of matrix `m`.\nx = matrix.get(m, 0, 0)\n\nplot(x)",
          "methodName": "get",
          "originalName": "matrix.get",
          "methodSyntax": "matrix.get(row, column) → <matrix_type>",
          "returnedType": [],
          "returnedTypes": []
        },
        {
          "name": "map.get",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Returns the value associated with the specified `key` in the `id` map.",
          "args": [
            {
              "name": "key",
              "desc": "The key of the value to retrieve.",
              "default": null,
              "required": true,
              "displayType": "map< *keyType* ,valueType>",
              "allowedTypeIDs": [],
              "possibleValues": null
            }
          ],
          "syntax": "map.get(id, key) → series valueType",
          "seeAlso": [
            "[map.new<type",
            "type>](#fun_map.new%3Ctype,type%3E)",
            "[map.put](#fun_map.put)",
            "[map.keys](#fun_map.keys)",
            "[map.values](#fun_map.values)",
            "[map.contains](#fun_map.contains)"
          ],
          "thisType": [
            "map"
          ],
          "examples": "//@version=5\nindicator(\"map.get example\")\na = map.new<int, int>()\nsize = 10\nfor i = 0 to size\n\ta.put(i, size-i)\nplot(map.get(a, 1))",
          "methodName": "get",
          "originalName": "map.get",
          "methodSyntax": "map.get(key) → series valueType",
          "returnedType": [],
          "returnedTypes": []
        },
        {
          "name": "array.min",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function returns the smallest value, or the nth smallest value in a given array.",
          "args": [
            {
              "name": "nth",
              "desc": "The nth smallest value to return, where zero is the smallest. Optional. The default is 0.",
              "default": "0",
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "array.min(id, nth) → series float|int",
          "returns": "The smallest or the nth smallest value in the array.",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.max](#fun_array.max)",
            "[array.sum](#fun_array.sum)"
          ],
          "thisType": [
            "array<float>",
            "array<int>"
          ],
          "examples": "//@version=5\nindicator(\"array.min\")\na = array.from(5, -2, 0, 9, 1)\nsecondLowest = array.min(a, 1) // 0\nplot(secondLowest)",
          "methodName": "min",
          "originalName": "array.min",
          "methodSyntax": "array.min(nth) → series float|int",
          "returnedType": [
            "float",
            "int"
          ],
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float",
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "name": "matrix.min",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function returns the smallest value from the matrix elements.",
          "args": [],
          "syntax": "matrix.min(id) → series float|int",
          "returns": "The smallest value from the `id` matrix.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.max](#fun_matrix.max)",
            "[matrix.avg](#fun_matrix.avg)",
            "[matrix.sort](#fun_matrix.sort)"
          ],
          "thisType": [
            "matrix<float>",
            "matrix<int>"
          ],
          "examples": "//@version=5\nindicator(\"`matrix.min()` Example\")\n\n// Create a 2x2 matrix.\nvar m = matrix.new<int>(2, 2, na)\n// Fill the matrix with values.\nmatrix.set(m, 0, 0, 1)\nmatrix.set(m, 0, 1, 2)\nmatrix.set(m, 1, 0, 3)\nmatrix.set(m, 1, 1, 4)\n\n// Get the minimum value from the matrix.\nvar x = matrix.min(m)\n\nplot(x, 'Matrix minimum value')",
          "methodName": "min",
          "originalName": "matrix.min",
          "methodSyntax": "matrix.min() → series float|int",
          "returnedType": [
            "float",
            "int"
          ],
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float",
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "name": "array.max",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function returns the greatest value, or the nth greatest value in a given array.",
          "args": [
            {
              "name": "nth",
              "desc": "The nth greatest value to return, where zero is the greatest. Optional. The default is 0.",
              "default": "0",
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "array.max(id, nth) → series float|int",
          "returns": "The greatest or the nth greatest value in the array.",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.min](#fun_array.min)",
            "[array.sum](#fun_array.sum)"
          ],
          "thisType": [
            "array<float>",
            "array<int>"
          ],
          "examples": "//@version=5\nindicator(\"array.max\")\na = array.from(5, -2, 0, 9, 1)\nthirdHighest = array.max(a, 2) // 1\nplot(thirdHighest)",
          "methodName": "max",
          "originalName": "array.max",
          "methodSyntax": "array.max(nth) → series float|int",
          "returnedType": [
            "float",
            "int"
          ],
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float",
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "name": "matrix.max",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function returns the largest value from the matrix elements.",
          "args": [],
          "syntax": "matrix.max(id) → series float|int",
          "returns": "The maximum value from the `id` matrix.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.min](#fun_matrix.min)",
            "[matrix.avg](#fun_matrix.avg)",
            "[matrix.sort](#fun_matrix.sort)"
          ],
          "thisType": [
            "matrix<float>",
            "matrix<int>"
          ],
          "examples": "//@version=5\nindicator(\"`matrix.max()` Example\")\n\n// Create a 2x2 matrix.\nvar m = matrix.new<int>(2, 2, na)\n// Fill the matrix with values.\nmatrix.set(m, 0, 0, 1)\nmatrix.set(m, 0, 1, 2)\nmatrix.set(m, 1, 0, 3)\nmatrix.set(m, 1, 1, 4)\n\n// Get the maximum value in the matrix.\nvar x = matrix.max(m)\n\nplot(x, 'Matrix maximum value')",
          "methodName": "max",
          "originalName": "matrix.max",
          "methodSyntax": "matrix.max() → series float|int",
          "returnedType": [
            "float",
            "int"
          ],
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float",
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "name": "array.range",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function returns the difference between the min and max values from a given array.",
          "args": [],
          "syntax": "array.range(id) → series float|int",
          "returns": "The difference between the min and max values in the array.",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.min](#fun_array.min)",
            "[array.max](#fun_array.max)",
            "[array.sum](#fun_array.sum)"
          ],
          "thisType": [
            "array<float>",
            "array<int>"
          ],
          "examples": "//@version=5\nindicator(\"array.range example\")\na = array.new_float(0)\nfor i = 0 to 9\n\tarray.push(a, close[i])\nplot(array.range(a))",
          "methodName": "range",
          "originalName": "array.range",
          "methodSyntax": "array.range() → series float|int",
          "returnedType": [
            "float",
            "int"
          ],
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float",
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "name": "array.sum",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function returns the sum of an array\\`s elements.",
          "args": [],
          "syntax": "array.sum(id) → series float|int",
          "returns": "The sum of the array\\`s elements.",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.max](#fun_array.max)",
            "[array.min](#fun_array.min)"
          ],
          "thisType": [
            "array<float>",
            "array<int>"
          ],
          "examples": "//@version=5\nindicator(\"array.sum example\")\na = array.new_float(0)\nfor i = 0 to 9\n\tarray.push(a, close[i])\nplot(array.sum(a))",
          "methodName": "sum",
          "originalName": "array.sum",
          "methodSyntax": "array.sum() → series float|int",
          "returnedType": [
            "float",
            "int"
          ],
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float",
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "name": "matrix.sum",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function returns a new matrix resulting from the [sum](https://en.wikipedia.org/wiki/Matrix_addition) of two matrices `id1` and `id2`, or of an `id1` matrix and an `id2` scalar (a numerical value).",
          "args": [
            {
              "name": "id2",
              "desc": "Second matrix object, or scalar value.",
              "default": null,
              "required": true,
              "displayType": "series int|float|matrix<int|float>",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float",
                "matrix<int>",
                "matrix<float>"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "matrix.sum(id1, id2) → matrix<int|float>",
          "returns": "A new matrix object containing the sum of `id2` and `id1`.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.get](#fun_matrix.get)",
            "[matrix.set](#fun_matrix.set)",
            "[matrix.columns](#fun_matrix.columns)",
            "[matrix.rows](#fun_matrix.rows)"
          ],
          "thisType": [
            "matrix<int>",
            "matrix<float>"
          ],
          "methodName": "sum",
          "originalName": "matrix.sum",
          "methodSyntax": "matrix.sum(id2) → matrix<int|float>",
          "detailedDesc": [
            {
              "desc": "Sum of two matrices",
              "examples": "//@version=5\nindicator(\"`matrix.sum()` Example 1\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x3 matrix containing values `5`.\n\tvar m1 = matrix.new<float>(2, 3, 5) \n\t// Create a 2x3 matrix containing values `4`.\n\tvar m2 = matrix.new<float>(2, 3, 4) \n\t// Create a new matrix that sums matrices `m1` and `m2`.\n\tvar m3 = matrix.sum(m1, m2) \n\t\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 1, 2, color.green)\n\ttable.cell(t, 0, 0, \"Sum of two matrices:\")\n\ttable.cell(t, 0, 1, str.tostring(m3))"
            },
            {
              "desc": "Sum of a matrix and scalar",
              "examples": "//@version=5\nindicator(\"`matrix.sum()` Example 2\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x3 matrix with values `4`.\n\tvar m1 = matrix.new<float>(2, 3, 4)\n\t\n\t// Create a new matrix containing the sum of the `m1` matrix with the \"int\" value `1`.\n\tvar m2 = matrix.sum(m1, 1)\n\t\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 1, 2, color.green)\n\ttable.cell(t, 0, 0, \"Sum of a matrix and a scalar:\")\n\ttable.cell(t, 0, 1, str.tostring(m2))"
            }
          ],
          "returnedType": [
            "matrix<float>",
            "matrix<int>"
          ],
          "returnedTypes": [
            "matrix<int>",
            "matrix<float>"
          ]
        },
        {
          "name": "array.set",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function sets the value of the element at the specified index.",
          "args": [
            {
              "name": "index",
              "desc": "The index of the element to be modified.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "value",
              "desc": "The new value to be set.",
              "default": null,
              "required": true,
              "displayType": "any",
              "allowedTypeIDs": [],
              "possibleValues": null
            }
          ],
          "syntax": "array.set(id, index, value) → void",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.get](#fun_array.get)",
            "[array.slice](#fun_array.slice)"
          ],
          "thisType": [
            "array"
          ],
          "examples": "//@version=5\nindicator(\"array.set example\")\na = array.new_float(10)\nfor i = 0 to 9\n\tarray.set(a, i, close[i])\nplot(array.sum(a) / 10)",
          "methodName": "set",
          "originalName": "array.set",
          "methodSyntax": "array.set(index, value) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "matrix.set",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function assigns `value` to the element at the `row` and `column` of the `id` matrix.",
          "args": [
            {
              "name": "row",
              "desc": "The row index of the element to be modified.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            },
            {
              "name": "column",
              "desc": "The column index of the element to be modified.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            },
            {
              "name": "value",
              "desc": "The new value to be set.",
              "default": null,
              "required": true,
              "displayType": "any",
              "allowedTypeIDs": [],
              "possibleValues": null
            }
          ],
          "syntax": "matrix.set(id, row, column, value) → void",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.get](#fun_matrix.get)",
            "[matrix.columns](#fun_matrix.columns)",
            "[matrix.rows](#fun_matrix.rows)"
          ],
          "thisType": [
            "matrix"
          ],
          "examples": "//@version=5\nindicator(\"`matrix.set()` Example\")\n\n// Create a 2x3 \"int\" matrix containing values `4`.\nm = matrix.new<int>(2, 3, 4)\n\n// Replace the value of element at row 1 and column 2 with value `3`.\nmatrix.set(m, 0, 1, 3)\n\n// Display using a label.\nif barstate.islastconfirmedhistory\n\tlabel.new(bar_index, high, str.tostring(m))",
          "methodName": "set",
          "originalName": "matrix.set",
          "methodSyntax": "matrix.set(row, column, value) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "array.fill",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function sets elements of an array to a single value. If no index is specified, all elements are set. If only a start index (default 0) is supplied, the elements starting at that index are set. If both index parameters are used, the elements from the starting index up to but not including the end index (default na) are set.",
          "args": [
            {
              "name": "value",
              "desc": "Value to fill the array with.",
              "default": null,
              "required": true,
              "displayType": "any",
              "allowedTypeIDs": [],
              "possibleValues": [
                "close",
                "open",
                "high",
                "low",
                "volume"
              ]
            },
            {
              "name": "index_from",
              "desc": "Start index, default is 0.",
              "default": "0",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "index_to",
              "desc": "End index, default is na. Must be one greater than the index of the last element to set.",
              "default": "na",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "array.fill(id, value, index_from, index_to) → void",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.set](#fun_array.set)",
            "[array.slice](#fun_array.slice)"
          ],
          "thisType": [
            "array"
          ],
          "examples": "//@version=5\nindicator(\"array.fill example\")\na = array.new_float(10)\narray.fill(a, close)\nplot(array.sum(a))",
          "methodName": "fill",
          "originalName": "array.fill",
          "methodSyntax": "array.fill(value, index_from, index_to) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "matrix.fill",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function fills a rectangular area of the `id` matrix defined by the indices `from_column` to `to_column` (not including it) and `from_row` to `to_row`(not including it) with the `value`.",
          "args": [
            {
              "name": "value",
              "desc": "The value to fill with.",
              "default": null,
              "required": true,
              "displayType": "any",
              "allowedTypeIDs": [],
              "possibleValues": null
            },
            {
              "name": "from_row",
              "desc": "Row index from which the fill will begin (inclusive). Optional. The default value is 0.",
              "default": "0",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "to_row",
              "desc": "Row index where the fill will end (not inclusive). Optional. The default value is [matrix.rows](#fun_matrix.rows).",
              "default": "matrix.rows()",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "from_column",
              "desc": "Column index from which the fill will begin (inclusive). Optional. The default value is 0.",
              "default": "0",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "to_column",
              "desc": "Column index where the fill will end (non inclusive). Optional. The default value is [matrix.columns](#fun_matrix.columns).",
              "default": "matrix.columns()",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "matrix.fill(id, value, from_row, to_row, from_column, to_column) → void",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.get](#fun_matrix.get)",
            "[matrix.set](#fun_matrix.set)",
            "[matrix.columns](#fun_matrix.columns)",
            "[matrix.rows](#fun_matrix.rows)"
          ],
          "thisType": [
            "matrix"
          ],
          "examples": "//@version=5\nindicator(\"`matrix.fill()` Example\")\n\n// Create a 4x5 \"int\" matrix containing values `0`.\nm = matrix.new<float>(4, 5, 0)\n\n// Fill the intersection of rows 1 to 2 and columns 2 to 3 of the matrix with `hl2` values.\nmatrix.fill(m, hl2, 0, 2, 1, 3)\n\n// Display using a label.\nif barstate.islastconfirmedhistory\n\tlabel.new(bar_index, high, str.tostring(m))",
          "methodName": "fill",
          "originalName": "matrix.fill",
          "methodSyntax": "matrix.fill(value, from_row, to_row, from_column, to_column) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "array.insert",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function changes the contents of an array by adding new elements in place.",
          "args": [
            {
              "name": "index",
              "desc": "The index at which to insert the value.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "value",
              "desc": "The value to add to the array.",
              "default": null,
              "required": true,
              "displayType": "any",
              "allowedTypeIDs": [],
              "possibleValues": null
            }
          ],
          "syntax": "array.insert(id, index, value) → void",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.set](#fun_array.set)",
            "[array.push](#fun_array.push)",
            "[array.remove](#fun_array.remove)",
            "[array.pop](#fun_array.pop)",
            "[array.unshift](#fun_array.unshift)"
          ],
          "thisType": [
            "array"
          ],
          "examples": "//@version=5\nindicator(\"array.insert example\")\na = array.new_float(5, close)\narray.insert(a, 0, open)\nplot(array.get(a, 5))",
          "methodName": "insert",
          "originalName": "array.insert",
          "methodSyntax": "array.insert(index, value) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "array.join",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function creates and returns a new string by concatenating all the elements of an array, separated by the specified separator string.",
          "args": [
            {
              "name": "separator",
              "desc": "The string used to separate each array element.",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "isString": true,
              "possibleValues": [
                "\\n",
                ",",
                ";",
                "|",
                "-",
                "."
              ]
            }
          ],
          "syntax": "array.join(id, separator) → series string",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.set](#fun_array.set)",
            "[array.insert](#fun_array.insert)",
            "[array.remove](#fun_array.remove)",
            "[array.pop](#fun_array.pop)",
            "[array.unshift](#fun_array.unshift)"
          ],
          "thisType": [
            "array<float>",
            "array<int>",
            "array<string>"
          ],
          "examples": "//@version=5\nindicator(\"array.join example\")\na = array.new_float(5, 5)\nlabel.new(bar_index, close, array.join(a, \", \"))",
          "methodName": "join",
          "originalName": "array.join",
          "methodSyntax": "array.join(separator) → series string",
          "returnedType": "string",
          "returnedTypes": [
            "series string",
            "simple string",
            "input string",
            "const string"
          ]
        },
        {
          "name": "array.push",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function appends a value to an array.",
          "args": [
            {
              "name": "value",
              "desc": "The value of the element added to the end of the array.",
              "default": null,
              "required": true,
              "displayType": "any",
              "allowedTypeIDs": [],
              "possibleValues": null
            }
          ],
          "syntax": "array.push(id, value) → void",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.set](#fun_array.set)",
            "[array.insert](#fun_array.insert)",
            "[array.remove](#fun_array.remove)",
            "[array.pop](#fun_array.pop)",
            "[array.unshift](#fun_array.unshift)"
          ],
          "thisType": [
            "array"
          ],
          "examples": "//@version=5\nindicator(\"array.push example\")\na = array.new_float(5, 0)\narray.push(a, open)\nplot(array.get(a, 5))",
          "methodName": "push",
          "originalName": "array.push",
          "methodSyntax": "array.push(value) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "array.remove",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function changes the contents of an array by removing the element with the specified index.",
          "args": [
            {
              "name": "index",
              "desc": "The index of the element to remove.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "array.remove(id, index) → series type",
          "returns": "The value of the removed element.",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.set](#fun_array.set)",
            "[array.push](#fun_array.push)",
            "[array.insert](#fun_array.insert)",
            "[array.pop](#fun_array.pop)",
            "[array.shift](#fun_array.shift)"
          ],
          "thisType": [
            "array"
          ],
          "examples": "//@version=5\nindicator(\"array.remove example\")\na = array.new_float(5, high)\nremovedEl = array.remove(a, 0)\nplot(array.size(a))\nplot(removedEl)",
          "methodName": "remove",
          "originalName": "array.remove",
          "methodSyntax": "array.remove(index) → series type"
        },
        {
          "name": "map.remove",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Removes a key-value pair from the `id` map.",
          "args": [
            {
              "name": "key",
              "desc": "The key of the pair to remove from the map.",
              "default": null,
              "required": true,
              "displayType": "map<type>",
              "allowedTypeIDs": [],
              "possibleValues": null
            }
          ],
          "syntax": "map.remove(id, key) → series valueType",
          "returns": "The previous value associated with `key` if the key was present in the map, or [na](#var_na) if there was no such key.",
          "seeAlso": [
            "[map.new<type",
            "type>](#fun_map.new%3Ctype,type%3E)",
            "[map.put](#fun_map.put)",
            "[map.keys](#fun_map.keys)",
            "[map.values](#fun_map.values)",
            "[map.clear](#fun_map.clear)"
          ],
          "thisType": [
            "map"
          ],
          "examples": "//@version=5\nindicator(\"map.remove example\")\na = map.new<string, color>()\na.put(\"firstColor\", color.green)\noldColorValue = map.remove(a, \"firstColor\")\nplot(close, color = oldColorValue)",
          "methodName": "remove",
          "originalName": "map.remove",
          "methodSyntax": "map.remove(key) → series valueType",
          "returnedType": [],
          "returnedTypes": []
        },
        {
          "name": "array.pop",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function removes the last element from an array and returns its value.",
          "args": [],
          "syntax": "array.pop(id) → series type",
          "returns": "The value of the removed element.",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.set](#fun_array.set)",
            "[array.push](#fun_array.push)",
            "[array.remove](#fun_array.remove)",
            "[array.insert](#fun_array.insert)",
            "[array.shift](#fun_array.shift)"
          ],
          "thisType": [
            "array"
          ],
          "examples": "//@version=5\nindicator(\"array.pop example\")\na = array.new_float(5, high)\nremovedEl = array.pop(a)\nplot(array.size(a))\nplot(removedEl)",
          "methodName": "pop",
          "originalName": "array.pop",
          "methodSyntax": "array.pop() → series type"
        },
        {
          "name": "array.clear",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function removes all elements from an array.",
          "args": [],
          "syntax": "array.clear(id) → void",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.insert](#fun_array.insert)",
            "[array.push](#fun_array.push)",
            "[array.remove](#fun_array.remove)",
            "[array.pop](#fun_array.pop)"
          ],
          "thisType": [
            "array"
          ],
          "methodName": "clear",
          "originalName": "array.clear",
          "methodSyntax": "array.clear() → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "map.clear",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Clears the map, removing all key-value pairs from it.",
          "args": [],
          "syntax": "map.clear(id) → void",
          "seeAlso": [
            "[map.new<type",
            "type>](#fun_map.new%3Ctype,type%3E)",
            "[map.put_all](#fun_map.put_all)",
            "[map.keys](#fun_map.keys)",
            "[map.values](#fun_map.values)",
            "[map.remove](#fun_map.remove)"
          ],
          "thisType": [
            "map"
          ],
          "examples": "//@version=5\nindicator(\"map.clear example\")\noddMap = map.new<int, bool>()\noddMap.put(1, true)\noddMap.put(2, false)\noddMap.put(3, true)\nmap.clear(oddMap)\nplot(oddMap.size())",
          "methodName": "clear",
          "originalName": "map.clear",
          "methodSyntax": "map.clear() → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "table.clear",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function removes a cell or a sequence of cells from the table. The cells are removed in a rectangle shape where the start_column and start_row specify the top-left corner, and end_column and end_row specify the bottom-right corner.",
          "args": [
            {
              "name": "start_column",
              "desc": "The index of the column of the first cell to delete. Numbering starts at 0.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "start_row",
              "desc": "The index of the row of the first cell to delete. Numbering starts at 0.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "end_column",
              "desc": "The index of the column of the last cell to delete. Optional. The default is the argument used for start_column.  \nNumbering starts at 0.",
              "default": "'start_column'",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "end_row",
              "desc": "The index of the row of the last cell to delete. Optional. The default is the argument used for start_row.  \nNumbering starts at 0.",
              "default": "'start_row'",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "table.clear(table_id, start_column, start_row, end_column, end_row) → void",
          "seeAlso": [
            "[table.delete](#fun_table.delete)",
            "[table.new](#fun_table.new)"
          ],
          "thisType": [
            "series table"
          ],
          "methodName": "clear",
          "originalName": "table.clear",
          "methodSyntax": "table.clear(start_column, start_row, end_column, end_row) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "array.sort",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function sorts the elements of an array.",
          "args": [
            {
              "name": "order",
              "desc": "The sort order: order.ascending (default) or order.descending.",
              "default": "order.ascending",
              "required": false,
              "displayType": "simple sort_order",
              "allowedTypeIDs": [
                "simple sort_order",
                "series sort_order"
              ],
              "possibleValues": [
                "order.ascending",
                "order.descending"
              ]
            }
          ],
          "syntax": "array.sort(id, order) → void",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.insert](#fun_array.insert)",
            "[array.slice](#fun_array.slice)",
            "[array.reverse](#fun_array.reverse)",
            "[order.ascending](#const_order.ascending)",
            "[order.descending](#const_order.descending)"
          ],
          "thisType": [
            "array<float>",
            "array<int>",
            "array<string>"
          ],
          "examples": "//@version=5\nindicator(\"array.sort example\")\na = array.new_float(0, 0)\nfor i = 0 to 5\n\tarray.push(a, high[i])\narray.sort(a, order.descending)\nif barstate.islast\n\tlabel.new(bar_index, close, str.tostring(a))",
          "methodName": "sort",
          "originalName": "array.sort",
          "methodSyntax": "array.sort(order) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "matrix.sort",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function rearranges the rows in the `id` matrix following the sorted order of the values in the `column`.",
          "args": [
            {
              "name": "column",
              "desc": "Index of the column whose sorted values determine the new order of rows. Optional. The default value is 0.",
              "default": "0",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            },
            {
              "name": "order",
              "desc": "The sort order. \nPossible values: [order.ascending](#var_order.ascending) (default), [order.descending](#var_order.descending).",
              "default": "order.ascending",
              "required": false,
              "displayType": "simple sort_order",
              "allowedTypeIDs": [
                "simple sort_order"
              ],
              "possibleValues": [
                "order.ascending",
                "order.descending"
              ]
            }
          ],
          "syntax": "matrix.sort(id, column, order) → void",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.max](#fun_matrix.max)",
            "[matrix.min](#fun_matrix.min)",
            "[matrix.avg](#fun_matrix.avg)"
          ],
          "thisType": [
            "matrix<int>",
            "matrix<float>",
            "matrix<string>"
          ],
          "examples": "//@version=5\nindicator(\"`matrix.sort()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x2 matrix. \n\tvar m1 = matrix.new<float>(2, 2, na)\n\t// Fill the matrix with values.\n\tmatrix.set(m1, 0, 0, 3)\n\tmatrix.set(m1, 0, 1, 4)\n\tmatrix.set(m1, 1, 0, 1)\n\tmatrix.set(m1, 1, 1, 2)\n\t\n\t// Copy the matrix to a new one.\n\tvar m2 = matrix.copy(m1)\n\t// Sort the rows of `m2` using the default arguments (first column and ascending order).\n\tmatrix.sort(m2)\n\t\n\t// Display using a table.\n\tif barstate.islastconfirmedhistory\n\t\tvar t = table.new(position.top_right, 2, 2, color.green)\n\t\ttable.cell(t, 0, 0, \"Original matrix:\")\n\t\ttable.cell(t, 0, 1, str.tostring(m1))\n\t\ttable.cell(t, 1, 0, \"Sorted matrix:\")\n\t\ttable.cell(t, 1, 1, str.tostring(m2))",
          "methodName": "sort",
          "originalName": "matrix.sort",
          "methodSyntax": "matrix.sort(column, order) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "array.sort_indices",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Returns an array of indices which, when used to index the original array, will access its elements in their sorted order. It does not modify the original array.",
          "args": [
            {
              "name": "order",
              "desc": "The sort order: order.ascending or order.descending. Optional. The default is order.ascending.",
              "default": "order.ascending",
              "required": false,
              "displayType": "series sort_order",
              "allowedTypeIDs": [
                "series sort_order"
              ],
              "possibleValues": [
                "order.ascending",
                "order.descending"
              ]
            }
          ],
          "syntax": "array.sort_indices(id, order) → array<int>",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.insert](#fun_array.insert)",
            "[array.slice](#fun_array.slice)",
            "[array.reverse](#fun_array.reverse)",
            "[order.ascending](#const_order.ascending)",
            "[order.descending](#const_order.descending)"
          ],
          "thisType": [
            "array<float>",
            "array<int>",
            "array<string>"
          ],
          "examples": "//@version=5\nindicator(\"array.sort_indices\")\na = array.from(5, -2, 0, 9, 1)\nsortedIndices = array.sort_indices(a) // [1, 2, 4, 0, 3]\nindexOfSmallestValue = array.get(sortedIndices, 0) // 1\nsmallestValue = array.get(a, indexOfSmallestValue) // -2\nplot(smallestValue)",
          "methodName": "sort_indices",
          "originalName": "array.sort_indices",
          "methodSyntax": "array.sort_indices(order) → array<int>",
          "returnedType": "array<int>",
          "returnedTypes": [
            "array<int>"
          ]
        },
        {
          "name": "array.percentrank",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Returns the percentile rank of the element at the specified `index`.",
          "args": [
            {
              "name": "index",
              "desc": "The index of the element for which the percentile rank should be calculated.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "array.percentrank(id, index) → series float|int",
          "remarks": "Percentile rank is the percentage of how many elements in the array are less than or equal to the reference value.",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.insert](#fun_array.insert)",
            "[array.slice](#fun_array.slice)",
            "[array.reverse](#fun_array.reverse)",
            "[order.ascending](#const_order.ascending)",
            "[order.descending](#const_order.descending)"
          ],
          "thisType": [
            "array<float>",
            "array<int>"
          ],
          "methodName": "percentrank",
          "originalName": "array.percentrank",
          "methodSyntax": "array.percentrank(index) → series float|int",
          "returnedType": [
            "float",
            "int"
          ],
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float",
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "name": "array.percentile_nearest_rank",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Returns the value for which the specified percentage of array values (percentile) are less than or equal to it, using the nearest-rank method.",
          "args": [
            {
              "name": "percentage",
              "desc": "The percentage of values that must be equal or less than the returned value.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                0,
                25,
                50,
                75,
                100
              ]
            }
          ],
          "syntax": "array.percentile_nearest_rank(id, percentage) → series float|int",
          "remarks": "In statistics, the percentile is the percent of ranking items that appear at or below a certain score.  \nThis measurement shows the percentage of scores within a standard frequency distribution that is lower than the percentile rank you're measuring.",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.insert](#fun_array.insert)",
            "[array.slice](#fun_array.slice)",
            "[array.reverse](#fun_array.reverse)",
            "[order.ascending](#const_order.ascending)",
            "[order.descending](#const_order.descending)"
          ],
          "thisType": [
            "array<float>",
            "array<int>"
          ],
          "methodName": "percentile_nearest_rank",
          "originalName": "array.percentile_nearest_rank",
          "methodSyntax": "array.percentile_nearest_rank(percentage) → series float|int",
          "returnedType": [
            "float",
            "int"
          ],
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float",
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "name": "array.percentile_linear_interpolation",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Returns the value for which the specified percentage of array values (percentile) are less than or equal to it, using linear interpolation.",
          "args": [
            {
              "name": "percentage",
              "desc": "The percentage of values that must be equal or less than the returned value.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                0,
                25,
                50,
                75,
                100
              ]
            }
          ],
          "syntax": "array.percentile_linear_interpolation(id, percentage) → int|float",
          "remarks": "In statistics, the percentile is the percent of ranking items that appear at or below a certain score.  \nThis measurement shows the percentage of scores within a standard frequency distribution that is lower than the percentile rank you're measuring.  \nLinear interpolation estimates the value between two ranks.",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.insert](#fun_array.insert)",
            "[array.slice](#fun_array.slice)",
            "[array.reverse](#fun_array.reverse)",
            "[order.ascending](#const_order.ascending)",
            "[order.descending](#const_order.descending)"
          ],
          "thisType": [
            "array<float>",
            "array<int>"
          ],
          "methodName": "percentile_linear_interpolation",
          "originalName": "array.percentile_linear_interpolation",
          "methodSyntax": "array.percentile_linear_interpolation(percentage) → float|int",
          "returnedType": [
            "float",
            "int"
          ],
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float",
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "name": "array.abs",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Returns an array containing the absolute value of each element in the original array.",
          "args": [],
          "syntax": "array.abs(id) → array<float|int>",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.insert](#fun_array.insert)",
            "[array.slice](#fun_array.slice)",
            "[array.reverse](#fun_array.reverse)",
            "[order.ascending](#const_order.ascending)",
            "[order.descending](#const_order.descending)"
          ],
          "thisType": [
            "array<float>",
            "array<int>"
          ],
          "methodName": "abs",
          "originalName": "array.abs",
          "methodSyntax": "array.abs() → array<float|int>",
          "returnedType": [
            "array<int>",
            "array<float>"
          ],
          "returnedTypes": [
            "array<float>",
            "array<int>"
          ]
        },
        {
          "name": "array.binary_search",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function returns the index of the value, or -1 if the value is not found. The array to search must be sorted in ascending order.",
          "args": [
            {
              "name": "val",
              "desc": "The value to search for in the array.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "array.binary_search(id, val) → series int",
          "remarks": "A binary search works on arrays pre-sorted in ascending order. It begins by comparing an element in the middle of the array with the target value.  \nIf the element matches the target value, its position in the array is returned.  \nIf the element\\`s value is greater than the target value, the search continues in the lower half of the array.  \nIf the element\\`s value is less than the target value, the search continues in the upper half of the array.  \nBy doing this recursively, the algorithm progressively eliminates smaller and smaller portions of the array in which the target value cannot lie.",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.insert](#fun_array.insert)",
            "[array.slice](#fun_array.slice)",
            "[array.reverse](#fun_array.reverse)",
            "[order.ascending](#const_order.ascending)",
            "[order.descending](#const_order.descending)"
          ],
          "thisType": [
            "array<float>",
            "array<int>"
          ],
          "examples": "//@version=5\nindicator(\"array.binary_search\")\na = array.from(5, -2, 0, 9, 1)\narray.sort(a) // [-2, 0, 1, 5, 9]\nposition = array.binary_search(a, 0) // 1\nplot(position)",
          "methodName": "binary_search",
          "originalName": "array.binary_search",
          "methodSyntax": "array.binary_search(val) → series int",
          "returnedType": "int",
          "returnedTypes": [
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "name": "array.binary_search_leftmost",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function returns the index of the value if it is found. When the value is not found, the function returns the index of the next smallest element to the left of where the value would lie if it was in the array. The array to search must be sorted in ascending order.",
          "args": [
            {
              "name": "val",
              "desc": "The value to search for in the array.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "array.binary_search_leftmost(id, val) → series int",
          "remarks": "A binary search works on arrays pre-sorted in ascending order. It begins by comparing an element in the middle of the array with the target value.  \nIf the element matches the target value, its position in the array is returned.  \nIf the element\\`s value is greater than the target value, the search continues in the lower half of the array.  \nIf the element\\`s value is less than the target value, the search continues in the upper half of the array.  \nBy doing this recursively, the algorithm progressively eliminates smaller and smaller portions of the array in which the target value cannot lie.",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.insert](#fun_array.insert)",
            "[array.slice](#fun_array.slice)",
            "[array.reverse](#fun_array.reverse)",
            "[order.ascending](#const_order.ascending)",
            "[order.descending](#const_order.descending)"
          ],
          "thisType": [
            "array<float>",
            "array<int>"
          ],
          "methodName": "binary_search_leftmost",
          "originalName": "array.binary_search_leftmost",
          "methodSyntax": "array.binary_search_leftmost(val) → series int",
          "detailedDesc": [
            {
              "desc": "",
              "examples": "//@version=5\nindicator(\"array.binary_search_leftmost\")\na = array.from(5, -2, 0, 9, 1)\narray.sort(a) // [-2, 0, 1, 5, 9]\nposition = array.binary_search_leftmost(a, 3) // 2\nplot(position)"
            },
            {
              "desc": "",
              "examples": "//@version=5\nindicator(\"array.binary_search_leftmost, repetitive elements\")\na = array.from(4, 5, 5, 5)\n// Returns the index of the first instance.\nposition = array.binary_search_leftmost(a, 5) \nplot(position) // Plots 1"
            }
          ],
          "returnedType": "int",
          "returnedTypes": [
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "name": "array.binary_search_rightmost",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function returns the index of the value if it is found. When the value is not found, the function returns the index of the element to the right of where the value would lie if it was in the array. The array must be sorted in ascending order.",
          "args": [
            {
              "name": "val",
              "desc": "The value to search for in the array.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "array.binary_search_rightmost(id, val) → series int",
          "remarks": "A binary search works on sorted arrays in ascending order. It begins by comparing an element in the middle of the array with the target value.  \nIf the element matches the target value, its position in the array is returned.  \nIf the element\\`s value is greater than the target value, the search continues in the lower half of the array.  \nIf the element\\`s value is less than the target value, the search continues in the upper half of the array.  \nBy doing this recursively, the algorithm progressively eliminates smaller and smaller portions of the array in which the target value cannot lie.",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.insert](#fun_array.insert)",
            "[array.slice](#fun_array.slice)",
            "[array.reverse](#fun_array.reverse)",
            "[order.ascending](#const_order.ascending)",
            "[order.descending](#const_order.descending)"
          ],
          "thisType": [
            "array<float>",
            "array<int>"
          ],
          "methodName": "binary_search_rightmost",
          "originalName": "array.binary_search_rightmost",
          "methodSyntax": "array.binary_search_rightmost(val) → series int",
          "detailedDesc": [
            {
              "desc": "",
              "examples": "//@version=5\nindicator(\"array.binary_search_rightmost\")\na = array.from(5, -2, 0, 9, 1)\narray.sort(a) // [-2, 0, 1, 5, 9]\nposition = array.binary_search_rightmost(a, 3) // 3\nplot(position)"
            },
            {
              "desc": "",
              "examples": "//@version=5\nindicator(\"array.binary_search_rightmost, repetitive elements\")\na = array.from(4, 5, 5, 5)\n// Returns the index of the last instance.\nposition = array.binary_search_rightmost(a, 5) \nplot(position) // Plots 3"
            }
          ],
          "returnedType": "int",
          "returnedTypes": [
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "name": "array.concat",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function is used to merge two arrays. It pushes all elements from the second array to the first array, and returns the first array.",
          "args": [
            {
              "name": "id2",
              "desc": "The second array object.",
              "default": null,
              "required": true,
              "displayType": "any[]",
              "allowedTypeIDs": "array",
              "possibleValues": null
            }
          ],
          "syntax": "array.concat(id1, id2) → type[]",
          "returns": "The first array with merged elements from the second array.",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.insert](#fun_array.insert)",
            "[array.slice](#fun_array.slice), "
          ],
          "thisType": [
            "array"
          ],
          "examples": "//@version=5\nindicator(\"array.concat example\")\na = array.new_float(0, 0)\nb = array.new_float(0, 0)\nfor i = 0 to 4\n    array.push(a, high[i])\n    array.push(b, low[i])\nc = array.concat(a, b)\nplot(array.size(a))\nplot(array.size(b))\nplot(array.size(c))",
          "methodName": "concat",
          "originalName": "array.concat",
          "methodSyntax": "array.concat(id2) → type[]"
        },
        {
          "name": "matrix.concat",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function appends the `m2` matrix to the `m1` matrix.",
          "args": [
            {
              "name": "id2",
              "desc": "Matrix object whose elements will be appended to `id1`.",
              "default": null,
              "required": true,
              "displayType": "matrix<any>",
              "allowedTypeIDs": "matrix",
              "possibleValues": null
            }
          ],
          "syntax": "matrix.concat(id1, id2) → matrix<type>",
          "remarks": "The number of columns in both matrices must be identical.",
          "returns": "Returns the `id1` matrix concatenated with the `id2` matrix.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.get](#fun_matrix.get)",
            "[matrix.set](#fun_matrix.set)",
            "[matrix.columns](#fun_matrix.columns)",
            "[matrix.rows](#fun_matrix.rows)"
          ],
          "thisType": [
            "matrix"
          ],
          "examples": "//@version=5\nindicator(\"`matrix.concat()` Example\")\n\n// Create a 2x4 \"int\" matrix containing values `0`.\nm1 = matrix.new<int>(2, 4, 0)\n// Create a 2x4 \"int\" matrix containing values `1`.\nm2 = matrix.new<int>(2, 4, 1)\n\n// Append matrix `m2` to `m1`.\nmatrix.concat(m1, m2)\n\n// Display matrix elements.\nif barstate.islastconfirmedhistory\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Matrix Elements:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))",
          "methodName": "concat",
          "originalName": "matrix.concat",
          "methodSyntax": "matrix.concat(id2) → matrix<type>",
          "returnedType": "matrix",
          "returnedTypes": [
            "matrix"
          ]
        },
        {
          "name": "array.avg",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function returns the mean of an array\\`s elements.",
          "args": [],
          "syntax": "array.avg(id) → series float|int",
          "returns": "Mean of array\\`s elements.",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.max](#fun_array.max)",
            "[array.min](#fun_array.min)",
            "[array.stdev](#fun_array.stdev)"
          ],
          "thisType": [
            "array<float>",
            "array<int>"
          ],
          "examples": "//@version=5\nindicator(\"array.avg example\")\na = array.new_float(0)\nfor i = 0 to 9\n\tarray.push(a, close[i])\nplot(array.avg(a))",
          "methodName": "avg",
          "originalName": "array.avg",
          "methodSyntax": "array.avg() → series float|int",
          "returnedType": [
            "float",
            "int"
          ],
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float",
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "name": "matrix.avg",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function calculates the average of all elements in the matrix.",
          "args": [],
          "syntax": "matrix.avg(id) → series float|int",
          "returns": "The average value from the `id` matrix.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.get](#fun_matrix.get)",
            "[matrix.set](#fun_matrix.set)",
            "[matrix.columns](#fun_matrix.columns)",
            "[matrix.rows](#fun_matrix.rows)"
          ],
          "thisType": [
            "matrix<float>",
            "matrix<int>"
          ],
          "examples": "//@version=5\nindicator(\"`matrix.avg()` Example\")\n\n// Create a 2x2 matrix.\nvar m = matrix.new<int>(2, 2, na)\n// Fill the matrix with values.\nmatrix.set(m, 0, 0, 1)\nmatrix.set(m, 0, 1, 2)\nmatrix.set(m, 1, 0, 3)\nmatrix.set(m, 1, 1, 4)\n\n// Get the average value of the matrix.\nvar x = matrix.avg(m)\n\nplot(x, 'Matrix average value')",
          "methodName": "avg",
          "originalName": "matrix.avg",
          "methodSyntax": "matrix.avg() → series float|int",
          "returnedType": [
            "float",
            "int"
          ],
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float",
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "name": "array.stdev",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function returns the standard deviation of an array\\`s elements.",
          "args": [
            {
              "name": "biased",
              "desc": "Determines which estimate should be used. Optional. The default is true.",
              "default": "true",
              "required": false,
              "displayType": "series bool",
              "allowedTypeIDs": [
                "series bool",
                "simple bool",
                "input bool",
                "const bool"
              ],
              "possibleValues": [
                "true",
                "false"
              ]
            }
          ],
          "syntax": "array.stdev(id, biased) → series float|int",
          "remarks": "If `biased` is true, function will calculate using a biased estimate of the entire population, if false - unbiased estimate of a sample.",
          "returns": "The standard deviation of the array\\`s elements.",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.max](#fun_array.max)",
            "[array.min](#fun_array.min)",
            "[array.avg](#fun_array.avg)"
          ],
          "thisType": [
            "array<float>",
            "array<int>"
          ],
          "examples": "//@version=5\nindicator(\"array.stdev example\")\na = array.new_float(0)\nfor i = 0 to 9\n\tarray.push(a, close[i])\nplot(array.stdev(a))",
          "methodName": "stdev",
          "originalName": "array.stdev",
          "methodSyntax": "array.stdev(biased) → series float|int",
          "returnedType": [
            "float",
            "int"
          ],
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float",
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "name": "array.variance",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function returns the variance of an array\\`s elements.",
          "args": [
            {
              "name": "biased",
              "desc": "Determines which estimate should be used. Optional. The default is true.",
              "default": "true",
              "required": false,
              "displayType": "series bool",
              "allowedTypeIDs": [
                "series bool",
                "simple bool",
                "input bool",
                "const bool"
              ],
              "possibleValues": [
                "true",
                "false"
              ]
            }
          ],
          "syntax": "array.variance(id, biased) → series float|int",
          "remarks": "If `biased` is true, function will calculate using a biased estimate of the entire population, if false - unbiased estimate of a sample.",
          "returns": "The variance of the array\\`s elements.",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.stdev](#fun_array.stdev)",
            "[array.min](#fun_array.min)",
            "[array.avg](#fun_array.avg)",
            "[array.covariance](#fun_array.covariance)"
          ],
          "thisType": [
            "array<float>",
            "array<int>"
          ],
          "examples": "//@version=5\nindicator(\"array.variance example\")\na = array.new_float(0)\nfor i = 0 to 9\n\tarray.push(a, close[i])\nplot(array.variance(a))",
          "methodName": "variance",
          "originalName": "array.variance",
          "methodSyntax": "array.variance(biased) → series float|int",
          "returnedType": [
            "float",
            "int"
          ],
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float",
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "name": "array.covariance",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function returns the covariance of two arrays.",
          "args": [
            {
              "name": "id2",
              "desc": "An array object.",
              "default": null,
              "required": true,
              "displayType": "array<int|float>",
              "allowedTypeIDs": [
                "array<int>",
                "array<float>"
              ],
              "possibleValues": null
            },
            {
              "name": "biased",
              "desc": "Determines which estimate should be used. Optional. The default is true.",
              "default": "true",
              "required": false,
              "displayType": "series bool",
              "allowedTypeIDs": [
                "series bool",
                "simple bool",
                "input bool",
                "const bool"
              ],
              "possibleValues": [
                "true",
                "false"
              ]
            }
          ],
          "syntax": "array.covariance(id1, id2, biased) → series float",
          "remarks": "If `biased` is true, function will calculate using a biased estimate of the entire population, if false - unbiased estimate of a sample.",
          "returns": "The covariance of two arrays.",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.max](#fun_array.max)",
            "[array.stdev](#fun_array.stdev)",
            "[array.avg](#fun_array.avg)",
            "[array.variance](#fun_array.variance)"
          ],
          "thisType": [
            "array<int>",
            "array<float>"
          ],
          "examples": "//@version=5\nindicator(\"array.covariance example\")\na = array.new_float(0)\nb = array.new_float(0)\nfor i = 0 to 9\n\tarray.push(a, close[i])\n\tarray.push(b, open[i])\nplot(array.covariance(a, b))",
          "methodName": "covariance",
          "originalName": "array.covariance",
          "methodSyntax": "array.covariance(id2, biased) → series float",
          "returnedType": "float",
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "name": "array.mode",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function returns the mode of an array\\`s elements. If there are several values with the same frequency, it returns the smallest value.",
          "args": [],
          "syntax": "array.mode(id) → series float|int",
          "returns": "The most frequently occurring value from the `id` array. If none exists, returns the smallest value instead.",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[ta.mode](#fun_ta.mode)",
            "[matrix.mode](#fun_matrix.mode)",
            "[array.avg](#fun_array.avg)",
            "[array.variance](#fun_array.variance)",
            "[array.min](#fun_array.min)"
          ],
          "thisType": [
            "array<float>",
            "array<int>"
          ],
          "examples": "//@version=5\nindicator(\"array.mode example\")\na = array.new_float(0)\nfor i = 0 to 9\n\tarray.push(a, close[i])\nplot(array.mode(a))",
          "methodName": "mode",
          "originalName": "array.mode",
          "methodSyntax": "array.mode() → series float|int",
          "returnedType": [
            "float",
            "int"
          ],
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float",
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "name": "matrix.mode",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function calculates the [mode](https://en.wikipedia.org/wiki/Mode_(statistics)) of the matrix, which is the most frequently occurring value from the matrix elements.  \nWhen there are multiple values occurring equally frequently, the function returns the smallest of those values.",
          "args": [],
          "syntax": "matrix.mode(id) → series float|int",
          "remarks": "Note that [na](#var_na) elements of the matrix are not considered when calculating the mode.",
          "returns": "The most frequently occurring value from the `id` matrix. If none exists, returns the smallest value instead.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.set](#fun_matrix.set)",
            "[matrix.median](#fun_matrix.median)",
            "[matrix.sort](#fun_matrix.sort)",
            "[matrix.avg](#fun_matrix.avg)"
          ],
          "thisType": [
            "matrix<float>",
            "matrix<int>"
          ],
          "examples": "//@version=5\nindicator(\"`matrix.mode()` Example\")\n\n// Create a 2x2 matrix.\nvar m = matrix.new<int>(2, 2, na)\n// Fill the matrix with values.\nmatrix.set(m, 0, 0, 0)\nmatrix.set(m, 0, 1, 0)\nmatrix.set(m, 1, 0, 1)\nmatrix.set(m, 1, 1, 1)\n\n// Get the mode of the matrix.\nvar x = matrix.mode(m)\n\nplot(x, 'Mode of the matrix')",
          "methodName": "mode",
          "originalName": "matrix.mode",
          "methodSyntax": "matrix.mode() → series float|int",
          "returnedType": [
            "float",
            "int"
          ],
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float",
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "name": "array.median",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function returns the median of an array\\`s elements.",
          "args": [],
          "syntax": "array.median(id) → series float|int",
          "returns": "The median of the array\\`s elements.",
          "seeAlso": [
            "[array.median](#fun_array.median)",
            "[array.avg](#fun_array.avg)",
            "[array.variance](#fun_array.variance)",
            "[array.min](#fun_array.min)"
          ],
          "thisType": [
            "array<float>",
            "array<int>"
          ],
          "examples": "//@version=5\nindicator(\"array.median example\")\na = array.new_float(0)\nfor i = 0 to 9\n\tarray.push(a, close[i])\nplot(array.median(a))",
          "methodName": "median",
          "originalName": "array.median",
          "methodSyntax": "array.median() → series float|int",
          "returnedType": [
            "float",
            "int"
          ],
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float",
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "name": "matrix.median",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function calculates the [median](https://en.wikipedia.org/wiki/Median) (\"the middle\" value) of matrix elements.",
          "args": [],
          "syntax": "matrix.median(id) → series float|int",
          "remarks": "Note that [na](#var_na) elements of the matrix are not considered when calculating the median.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.mode](#fun_matrix.mode)",
            "[matrix.sort](#fun_matrix.sort)",
            "[matrix.avg](#fun_matrix.avg)"
          ],
          "thisType": [
            "matrix<float>",
            "matrix<int>"
          ],
          "examples": "//@version=5\nindicator(\"`matrix.median()` Example\")\n\n// Create a 2x2 matrix.\nm = matrix.new<int>(2, 2, na)\n// Fill the matrix with values.\nmatrix.set(m, 0, 0, 1)\nmatrix.set(m, 0, 1, 2)\nmatrix.set(m, 1, 0, 3)\nmatrix.set(m, 1, 1, 4)\n\n// Get the median of the matrix.\nx = matrix.median(m)\n\nplot(x, 'Median of the matrix')",
          "methodName": "median",
          "originalName": "matrix.median",
          "methodSyntax": "matrix.median() → series float|int",
          "returnedType": [
            "float",
            "int"
          ],
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float",
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "name": "array.standardize",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function returns the array of standardized elements.",
          "args": [],
          "syntax": "array.standardize(id) → array<float|int>",
          "returns": "The array of standardized elements.",
          "seeAlso": [
            "[array.max](#fun_array.max)",
            "[array.min](#fun_array.min)",
            "[array.mode](#fun_array.mode)",
            "[array.avg](#fun_array.avg)",
            "[array.variance](#fun_array.variance)",
            "[array.stdev](#fun_array.stdev)"
          ],
          "thisType": [
            "array<float>",
            "array<int>"
          ],
          "examples": "//@version=5\nindicator(\"array.standardize example\")\na = array.new_float(0)\nfor i = 0 to 9\n\tarray.push(a, close[i])\nb = array.standardize(a)\nplot(array.min(b))\nplot(array.max(b))",
          "methodName": "standardize",
          "originalName": "array.standardize",
          "methodSyntax": "array.standardize() → array<float|int>",
          "returnedType": [
            "array<int>",
            "array<float>"
          ],
          "returnedTypes": [
            "array<float>",
            "array<int>"
          ]
        },
        {
          "name": "array.indexof",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function returns the index of the first occurrence of the value, or -1 if the value is not found.",
          "args": [
            {
              "name": "value",
              "desc": "The value to search in the array.",
              "default": null,
              "required": true,
              "displayType": "any",
              "allowedTypeIDs": [],
              "possibleValues": null
            }
          ],
          "syntax": "array.indexof(id, value) → series int",
          "returns": "The index of an element.",
          "seeAlso": [
            "[array.lastindexof](#fun_array.lastindexof)",
            "[array.get](#fun_array.get)",
            "[array.lastindexof](#fun_array.lastindexof)",
            "[array.remove](#fun_array.remove)",
            "[array.insert](#fun_array.insert)"
          ],
          "thisType": [
            "array"
          ],
          "examples": "//@version=5\nindicator(\"array.indexof example\")\na = array.new_float(5, high)\nindex = array.indexof(a, high)\nplot(index)",
          "methodName": "indexof",
          "originalName": "array.indexof",
          "methodSyntax": "array.indexof(value) → series int",
          "returnedType": "int",
          "returnedTypes": [
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "name": "array.lastindexof",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function returns the index of the last occurrence of the value, or -1 if the value is not found.",
          "args": [
            {
              "name": "value",
              "desc": "The value to search in the array.",
              "default": null,
              "required": true,
              "displayType": "any",
              "allowedTypeIDs": [],
              "possibleValues": null
            }
          ],
          "syntax": "array.lastindexof(id, value) → series int",
          "returns": "The index of an element.",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.set](#fun_array.set)",
            "[array.push](#fun_array.push)",
            "[array.remove](#fun_array.remove)",
            "[array.insert](#fun_array.insert)"
          ],
          "thisType": [
            "array"
          ],
          "examples": "//@version=5\nindicator(\"array.lastindexof example\")\na = array.new_float(5, high)\nindex = array.lastindexof(a, high)\nplot(index)",
          "methodName": "lastindexof",
          "originalName": "array.lastindexof",
          "methodSyntax": "array.lastindexof(value) → series int",
          "returnedType": "int",
          "returnedTypes": [
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "name": "array.includes",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function returns true if the value was found in an array, false otherwise.",
          "args": [
            {
              "name": "value",
              "desc": "The value to search in the array.",
              "default": null,
              "required": true,
              "displayType": "any",
              "allowedTypeIDs": [],
              "possibleValues": null
            }
          ],
          "syntax": "array.includes(id, value) → series bool",
          "returns": "True if the value was found in the array, false otherwise.",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.indexof](#fun_array.indexof)",
            "[array.shift](#fun_array.shift)",
            "[array.remove](#fun_array.remove)",
            "[array.insert](#fun_array.insert)"
          ],
          "thisType": [
            "array"
          ],
          "examples": "//@version=5\nindicator(\"array.includes example\")\na = array.new_float(5, high)\np = close\nif array.includes(a, high)\n\tp := open\nplot(p)",
          "methodName": "includes",
          "originalName": "array.includes",
          "methodSyntax": "array.includes(value) → series bool",
          "returnedType": "bool",
          "returnedTypes": [
            "series bool",
            "simple bool",
            "input bool",
            "const bool"
          ]
        },
        {
          "name": "array.shift",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function removes an array\\`s first element and returns its value.",
          "args": [],
          "syntax": "array.shift(id) → series type",
          "returns": "The value of the removed element.",
          "seeAlso": [
            "[array.unshift](#fun_array.unshift)",
            "[array.set](#fun_array.set)",
            "[array.push](#fun_array.push)",
            "[array.remove](#fun_array.remove)",
            "[array.includes](#fun_array.includes)"
          ],
          "thisType": [
            "array"
          ],
          "examples": "//@version=5\nindicator(\"array.shift example\")\na = array.new_float(5, high)\nremovedEl = array.shift(a)\nplot(array.size(a))\nplot(removedEl)",
          "methodName": "shift",
          "originalName": "array.shift",
          "methodSyntax": "array.shift() → series type"
        },
        {
          "name": "array.unshift",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function inserts the value at the beginning of the array.",
          "args": [
            {
              "name": "value",
              "desc": "The value to add to the start of the array.",
              "default": null,
              "required": true,
              "displayType": "any",
              "allowedTypeIDs": [],
              "possibleValues": null
            }
          ],
          "syntax": "array.unshift(id, value) → void",
          "seeAlso": [
            "[array.shift](#fun_array.shift)",
            "[array.set](#fun_array.set)",
            "[array.insert](#fun_array.insert)",
            "[array.remove](#fun_array.remove)",
            "[array.indexof](#fun_array.indexof)"
          ],
          "thisType": [
            "array"
          ],
          "examples": "//@version=5\nindicator(\"array.unshift example\")\na = array.new_float(5, 0)\narray.unshift(a, open)\nplot(array.get(a, 0))",
          "methodName": "unshift",
          "originalName": "array.unshift",
          "methodSyntax": "array.unshift(value) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "array.reverse",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function reverses an array. The first array element becomes the last, and the last array element becomes the first.",
          "args": [],
          "syntax": "array.reverse(id) → void",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.sort](#fun_array.sort)",
            "[array.push](#fun_array.push)",
            "[array.set](#fun_array.set)",
            "[array.avg](#fun_array.avg)"
          ],
          "thisType": [
            "array"
          ],
          "examples": "//@version=5\nindicator(\"array.reverse example\")\na = array.new_float(0)\nfor i = 0 to 9\n\tarray.push(a, close[i])\nplot(array.get(a, 0))\narray.reverse(a)\nplot(array.get(a, 0))",
          "methodName": "reverse",
          "originalName": "array.reverse",
          "methodSyntax": "array.reverse() → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "matrix.reverse",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function reverses the order of rows and columns in the matrix `id`. The first row and first column become the last, and the last become the first.",
          "args": [],
          "syntax": "matrix.reverse(id) → void",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.set](#fun_matrix.set)",
            "[matrix.columns](#fun_matrix.columns)",
            "[matrix.rows](#fun_matrix.rows)",
            "[matrix.reshape](#fun_matrix.reshape)"
          ],
          "thisType": [
            "matrix"
          ],
          "examples": "//@version=5\nindicator(\"`matrix.reverse()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Copy the matrix to a new one.\n\tvar m1 = matrix.new<int>(2, 2, na)\n\t// Fill the matrix with values.\n\tmatrix.set(m1, 0, 0, 1)\n\tmatrix.set(m1, 0, 1, 2)\n\tmatrix.set(m1, 1, 0, 3)\n\tmatrix.set(m1, 1, 1, 4)\n\t\n\t// Copy matrix elements to a new matrix.\n\tvar m2 = matrix.copy(m1)\n\t\n\t// Reverse the `m2` copy of the original matrix. \n\tmatrix.reverse(m2)\n\t\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Original matrix:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 0, \"Reversed matrix:\")\n\ttable.cell(t, 1, 1, str.tostring(m2))",
          "methodName": "reverse",
          "originalName": "matrix.reverse",
          "methodSyntax": "matrix.reverse() → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "table.set_position",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function sets the position of a table.",
          "args": [
            {
              "name": "position",
              "desc": "Position of the table. Possible values are: [position.top_left](#var_position.top_left), [position.top_center](#var_position.top_center), [position.top_right](#var_position.top_right), [position.middle_left](#var_position.middle_left), [position.middle_center](#var_position.middle_center), [position.middle_right](#var_position.middle_right), [position.bottom_left](#var_position.bottom_left), [position.bottom_center](#var_position.bottom_center), [position.bottom_right](#var_position.bottom_right).",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "position.top_left",
                "position.top_center",
                "position.top_right",
                "position.middle_left",
                "position.middle_center",
                "position.middle_right",
                "position.bottom_left",
                "position.bottom_center",
                "position.bottom_right"
              ]
            }
          ],
          "syntax": "table.set_position(table_id, position) → void",
          "seeAlso": [
            "[table.clear](#fun_table.clear)",
            "[table.delete](#fun_table.delete)",
            "[table.new](#fun_table.new)",
            "[table.set_bgcolor](#fun_table.set_bgcolor)",
            "[table.set_border_color](#fun_table.set_border_color)",
            "[table.set_border_width](#fun_table.set_border_width)",
            "[table.set_frame_color](#fun_table.set_frame_color)",
            "[table.set_frame_width](#fun_table.set_frame_width)"
          ],
          "thisType": [
            "series table"
          ],
          "methodName": "set_position",
          "originalName": "table.set_position",
          "methodSyntax": "table.set_position(position) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "table.set_frame_color",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function sets the color of the outer frame of a table.",
          "args": [
            {
              "name": "frame_color",
              "desc": "The color of the frame of the table. Optional.",
              "default": null,
              "required": false,
              "displayType": "series color",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "possibleValues": [
                "colors"
              ]
            }
          ],
          "syntax": "table.set_frame_color(table_id, frame_color) → void",
          "seeAlso": [
            "[table.clear](#fun_table.clear)",
            "[table.delete](#fun_table.delete)",
            "[table.new](#fun_table.new)",
            "[table.set_border_color](#fun_table.set_border_color)",
            "[table.set_border_width](#fun_table.set_border_width)",
            "[table.set_bgcolor](#fun_table.set_bgcolor)",
            "[table.set_frame_width](#fun_table.set_frame_width)",
            "[table.set_position](#fun_table.set_position)"
          ],
          "thisType": [
            "series table"
          ],
          "methodName": "set_frame_color",
          "originalName": "table.set_frame_color",
          "methodSyntax": "table.set_frame_color(frame_color) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "table.set_frame_width",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function set the width of the outer frame of a table.",
          "args": [
            {
              "name": "frame_width",
              "desc": "The width of the outer frame of the table. Optional. The default is 0.",
              "default": "0",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            }
          ],
          "syntax": "table.set_frame_width(table_id, frame_width) → void",
          "seeAlso": [
            "[table.clear](#fun_table.clear)",
            "[table.delete](#fun_table.delete)",
            "[table.new](#fun_table.new)",
            "[table.set_frame_color](#fun_table.set_frame_color)",
            "[table.set_border_width](#fun_table.set_border_width)",
            "[table.set_bgcolor](#fun_table.set_bgcolor)",
            "[table.set_border_color](#fun_table.set_border_color)",
            "[table.set_position](#fun_table.set_position)"
          ],
          "thisType": [
            "series table"
          ],
          "methodName": "set_frame_width",
          "originalName": "table.set_frame_width",
          "methodSyntax": "table.set_frame_width(frame_width) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "table.cell",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function defines a cell in the table and sets its attributes.",
          "args": [
            {
              "name": "column",
              "desc": "The index of the cell\\`s column. Numbering starts at 0.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            },
            {
              "name": "row",
              "desc": "The index of the cell\\`s row. Numbering starts at 0.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            },
            {
              "name": "text",
              "desc": "The text to be displayed inside the cell. Optional. The default is empty string.",
              "default": "\"\"",
              "required": false,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "text_font_family",
              "desc": "The font family of the text. Optional. The default value is [font.family_default](#var_font.family_default).  \n\nPossible values: [font.family_default](#var_font.family_default), [font.family_monospace](#var_font.family_monospace).",
              "default": "font.family_default",
              "required": false,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "font.family_default",
                "font.family_monospace"
              ]
            },
            {
              "name": "width",
              "desc": "The width of the cell as a % of the indicator\\`s visual space. Optional. By default, auto-adjusts the width based on the text inside the cell.  \nValue 0 has the same effect.",
              "default": "0",
              "required": false,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                0,
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            },
            {
              "name": "height",
              "desc": "The height of the cell as a % of the indicator\\`s visual space. Optional. By default, auto-adjusts the height based on the text inside of the cell.  \nValue 0 has the same effect.",
              "default": "0",
              "required": false,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                0,
                10,
                20,
                30,
                40
              ]
            },
            {
              "name": "text_color",
              "desc": "The color of the text. Optional. The default is [color.black](#var_color.black).",
              "default": "color.black",
              "required": false,
              "displayType": "series color",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "possibleValues": [
                "colors"
              ]
            },
            {
              "name": "text_halign",
              "desc": "The horizontal alignment of the cell\\`s text. Optional. The default value is [text.align_center](#var_text.align_center).  \n\nPossible values: [text.align_left](#var_text.align_left), [text.align_center](#var_text.align_center), [text.align_right](#var_text.align_right).",
              "default": "text.align_center",
              "required": false,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "text.align_left",
                "text.align_center",
                "text.align_right"
              ]
            },
            {
              "name": "text_valign",
              "desc": "The vertical alignment of the cell\\`s text. Optional. The default value is [text.align_center](#var_text.align_center). \nPossible values: [text.align_top](#var_text.align_top), [text.align_center](#var_text.align_center), [text.align_bottom](#var_text.align_bottom).",
              "default": "text.align_center",
              "required": false,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "text.align_top",
                "text.align_center",
                "text.align_bottom"
              ]
            },
            {
              "name": "text_size",
              "desc": "The size of the text. An optional parameter, the default value is [size.normal](#var_size.normal). \nPossible values: [size.auto](#var_size.auto), [size.tiny](#var_size.tiny), [size.small](#var_size.small), [size.normal](#var_size.normal), [size.large](#var_size.large), [size.huge](#var_size.huge).",
              "default": "size.normal",
              "required": false,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "size.auto",
                "size.tiny",
                "size.small",
                "size.normal",
                "size.large",
                "size.huge"
              ]
            },
            {
              "name": "bgcolor",
              "desc": "The background color of the text. Optional. The default is no color.",
              "default": "na",
              "required": false,
              "displayType": "series color",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "possibleValues": [
                "colors"
              ]
            },
            {
              "name": "tooltip",
              "desc": "The tooltip to be displayed inside the cell. Optional.",
              "default": null,
              "required": false,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "table.cell(table_id, column, row, text, width, height, text_color, text_halign, text_valign, text_size, bgcolor, tooltip, text_font_family) → void",
          "remarks": "This function does not create the table itself, but defines the table’s cells. To use it, you first need to create a table object with [table.new](#fun_table.new).\nEach [table.cell](#fun_table.cell) call overwrites all previously defined properties of a cell.  \nIf you call [table.cell](#fun_table.cell) twice in a row, e.g., the first time with text='Test Text', and the second time with text_color=[color.red](#var_color.red) but without a new text argument, the default value of the 'text' being an empty string, it will overwrite 'Test Text', and your cell will display an empty string.  \nIf you want, instead, to modify any of the cell\\`s properties, use the table.cell_set_*() functions.\nA single script can only display one table in each of the possible locations.  \nIf [table.cell](#fun_table.cell) is used on several bars to change the same attribute of a cell (e.g.  \nchange the background color of the cell to red on the first bar, then to yellow on the second bar), only the last change will be reflected in the table, i.e., the cell’s background will be yellow.  \nAvoid unnecessary setting of cell properties by enclosing function calls in an [if](#op_if) [barstate.islast](#var_barstate.islast) block whenever possible, to restrict their execution to the last bar of the series.",
          "seeAlso": [
            "[table.cell_set_bgcolor](#fun_table.cell_set_bgcolor)",
            "[table.cell_set_height](#fun_table.cell_set_height)",
            "[table.cell_set_text](#fun_table.cell_set_text)",
            "[table.cell_set_text_color](#fun_table.cell_set_text_color)",
            "[table.cell_set_text_halign](#fun_table.cell_set_text_halign)",
            "[table.cell_set_text_size](#fun_table.cell_set_text_size)",
            "[table.cell_set_text_valign](#fun_table.cell_set_text_valign)",
            "[table.cell_set_width](#fun_table.cell_set_width)",
            "[table.cell_set_tooltip](#fun_table.cell_set_tooltip)"
          ],
          "thisType": [
            "series table"
          ],
          "methodName": "cell",
          "originalName": "table.cell",
          "methodSyntax": "table.cell(column, row, text, width, height, text_color, text_halign, text_valign, text_size, bgcolor, tooltip, text_font_family) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "table.cell_set_text",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function sets the text in the specified cell.",
          "args": [
            {
              "name": "column",
              "desc": "The index of the cell\\`s column. Numbering starts at 0.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            },
            {
              "name": "row",
              "desc": "The index of the cell\\`s row. Numbering starts at 0.",
              "default": "0",
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            },
            {
              "name": "text",
              "desc": "The text to be displayed inside the cell.",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "table.cell_set_text(table_id, column, row, text) → void",
          "seeAlso": [
            "[table.cell_set_bgcolor](#fun_table.cell_set_bgcolor)",
            "[table.cell_set_height](#fun_table.cell_set_height)",
            "[table.cell_set_text_color](#fun_table.cell_set_text_color)",
            "[table.cell_set_text_halign](#fun_table.cell_set_text_halign)",
            "[table.cell_set_text_size](#fun_table.cell_set_text_size)",
            "[table.cell_set_text_valign](#fun_table.cell_set_text_valign)",
            "[table.cell_set_width](#fun_table.cell_set_width)",
            "[table.cell_set_tooltip](#fun_table.cell_set_tooltip)"
          ],
          "thisType": [
            "series table"
          ],
          "examples": "//@version=5\nindicator(\"TABLE example\")\nvar tLog = table.new(position = position.top_left, rows = 1, columns = 2, bgcolor = color.yellow, border_width=1)\ntable.cell(tLog, row = 0, column = 0, text = \"sometext\", text_color = color.blue)\ntable.cell_set_text(tLog, row = 0, column = 0, text = \"sometext\")",
          "methodName": "cell_set_text",
          "originalName": "table.cell_set_text",
          "methodSyntax": "table.cell_set_text(column, row, text) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "table.cell_set_text_font_family",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function sets the font family of the text inside the cell.",
          "args": [
            {
              "name": "column",
              "desc": "The index of the cell\\`s column. Numbering starts at 0.",
              "default": "0",
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            },
            {
              "name": "row",
              "desc": "The index of the cell\\`s row. Numbering starts at 0.",
              "default": "0",
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            },
            {
              "name": "text_font_family",
              "desc": "The font family of the text.  \nPossible values: [font.family_default](#var_font.family_default), [font.family_monospace](#var_font.family_monospace).",
              "default": "font.family_default",
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "font.family_default",
                "font.family_monospace"
              ]
            }
          ],
          "syntax": "table.cell_set_text_font_family(table_id, column, row, text_font_family) → void",
          "seeAlso": [
            "[table.new](#fun_table.new)",
            "[font.family_default](#const_font.family_default)",
            "[font.family_monospace](#const_font.family_monospace)"
          ],
          "thisType": [
            "series table"
          ],
          "examples": "//@version=5\nindicator(\"Example of setting the table cell font\")\nvar t = table.new(position.top_left, rows = 1, columns = 1)\ntable.cell(t, 0, 0, \"monospace\", text_color = color.blue)\ntable.cell_set_text_font_family(t, 0, 0, font.family_monospace)",
          "methodName": "cell_set_text_font_family",
          "originalName": "table.cell_set_text_font_family",
          "methodSyntax": "table.cell_set_text_font_family(column, row, text_font_family) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "table.cell_set_tooltip",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function sets the tooltip in the specified cell.",
          "args": [
            {
              "name": "column",
              "desc": "The index of the cell\\`s column. Numbering starts at 0.",
              "default": "0",
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            },
            {
              "name": "row",
              "desc": "The index of the cell\\`s row. Numbering starts at 0.",
              "default": "0",
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            },
            {
              "name": "tooltip",
              "desc": "The tooltip to be displayed inside the cell.",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "table.cell_set_tooltip(table_id, column, row, tooltip) → void",
          "seeAlso": [
            "[table.cell_set_bgcolor](#fun_table.cell_set_bgcolor)",
            "[table.cell_set_height](#fun_table.cell_set_height)",
            "[table.cell_set_text_color](#fun_table.cell_set_text_color)",
            "[table.cell_set_text_halign](#fun_table.cell_set_text_halign)",
            "[table.cell_set_text_size](#fun_table.cell_set_text_size)",
            "[table.cell_set_text_valign](#fun_table.cell_set_text_valign)",
            "[table.cell_set_width](#fun_table.cell_set_width)",
            "[table.cell_set_text](#fun_table.cell_set_text)"
          ],
          "thisType": [
            "series table"
          ],
          "examples": "//@version=5\nindicator(\"TABLE example\")\nvar tLog = table.new(position = position.top_left, rows = 1, columns = 2, bgcolor = color.yellow, border_width=1)\ntable.cell(tLog, row = 0, column = 0, text = \"sometext\", text_color = color.blue)\ntable.cell_set_tooltip(tLog, row = 0, column = 0, tooltip = \"sometext\")",
          "methodName": "cell_set_tooltip",
          "originalName": "table.cell_set_tooltip",
          "methodSyntax": "table.cell_set_tooltip(column, row, tooltip) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "table.cell_set_width",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function sets the width of the cell.",
          "args": [
            {
              "name": "column",
              "desc": "The index of the cell\\`s column. Numbering starts at 0.",
              "default": "0",
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            },
            {
              "name": "row",
              "desc": "The index of the cell\\`s row. Numbering starts at 0.",
              "default": "0",
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            },
            {
              "name": "width",
              "desc": "The width of the cell as a % of the chart window. Passing 0 auto-adjusts the width based on the text inside of the cell.",
              "default": "0",
              "required": false,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            }
          ],
          "syntax": "table.cell_set_width(table_id, column, row, width) → void",
          "seeAlso": [
            "[table.cell_set_bgcolor](#fun_table.cell_set_bgcolor)",
            "[table.cell_set_height](#fun_table.cell_set_height)",
            "[table.cell_set_text](#fun_table.cell_set_text)",
            "[table.cell_set_text_color](#fun_table.cell_set_text_color)",
            "[table.cell_set_text_halign](#fun_table.cell_set_text_halign)",
            "[table.cell_set_text_size](#fun_table.cell_set_text_size)",
            "[table.cell_set_text_valign](#fun_table.cell_set_text_valign)",
            "[table.cell_set_tooltip](#fun_table.cell_set_tooltip)"
          ],
          "thisType": [
            "series table"
          ],
          "methodName": "cell_set_width",
          "originalName": "table.cell_set_width",
          "methodSyntax": "table.cell_set_width(column, row, width) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "table.cell_set_height",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function sets the height of cell.",
          "args": [
            {
              "name": "column",
              "desc": "The index of the cell\\`s column. Numbering starts at 0.",
              "default": "0",
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            },
            {
              "name": "row",
              "desc": "The index of the cell\\`s row. Numbering starts at 0.",
              "default": "0",
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            },
            {
              "name": "height",
              "desc": "The height of the cell as a % of the chart window. Passing 0 auto-adjusts the height based on the text inside of the cell.",
              "default": "0",
              "required": false,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                0,
                25,
                50,
                75,
                100
              ]
            }
          ],
          "syntax": "table.cell_set_height(table_id, column, row, height) → void",
          "seeAlso": [
            "[table.cell_set_bgcolor](#fun_table.cell_set_bgcolor)",
            "[table.cell_set_text](#fun_table.cell_set_text)",
            "[table.cell_set_text_color](#fun_table.cell_set_text_color)",
            "[table.cell_set_text_halign](#fun_table.cell_set_text_halign)",
            "[table.cell_set_text_size](#fun_table.cell_set_text_size)",
            "[table.cell_set_text_valign](#fun_table.cell_set_text_valign)",
            "[table.cell_set_width](#fun_table.cell_set_width)",
            "[table.cell_set_tooltip](#fun_table.cell_set_tooltip)"
          ],
          "thisType": [
            "series table"
          ],
          "methodName": "cell_set_height",
          "originalName": "table.cell_set_height",
          "methodSyntax": "table.cell_set_height(column, row, height) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "table.cell_set_text_color",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function sets the color of the text inside the cell.",
          "args": [
            {
              "name": "column",
              "desc": "The index of the cell\\`s column. Numbering starts at 0.",
              "default": "0",
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            },
            {
              "name": "row",
              "desc": "The index of the cell\\`s row. Numbering starts at 0.",
              "default": "0",
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            },
            {
              "name": "text_color",
              "desc": "The color of the text.",
              "default": null,
              "required": true,
              "displayType": "series color",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "possibleValues": [
                "colors"
              ]
            }
          ],
          "syntax": "table.cell_set_text_color(table_id, column, row, text_color) → void",
          "seeAlso": [
            "[table.cell_set_bgcolor](#fun_table.cell_set_bgcolor)",
            "[table.cell_set_height](#fun_table.cell_set_height)",
            "[table.cell_set_text](#fun_table.cell_set_text)",
            "[table.cell_set_text_halign](#fun_table.cell_set_text_halign)",
            "[table.cell_set_text_size](#fun_table.cell_set_text_size)",
            "[table.cell_set_text_valign](#fun_table.cell_set_text_valign)",
            "[table.cell_set_width](#fun_table.cell_set_width)",
            "[table.cell_set_tooltip](#fun_table.cell_set_tooltip)"
          ],
          "thisType": [
            "series table"
          ],
          "methodName": "cell_set_text_color",
          "originalName": "table.cell_set_text_color",
          "methodSyntax": "table.cell_set_text_color(column, row, text_color) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "table.cell_set_text_halign",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function sets the horizontal alignment of the cell\\`s text.",
          "args": [
            {
              "name": "column",
              "desc": "The index of the cell\\`s column. Numbering starts at 0.",
              "default": "0",
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            },
            {
              "name": "row",
              "desc": "The index of the cell\\`s row. Numbering starts at 0.",
              "default": "0",
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            },
            {
              "name": "text_halign",
              "desc": "The horizontal alignment of a cell\\`s text.  \nPossible values: [text.align_left](#var_text.align_left), [text.align_center](#var_text.align_center), [text.align_right](#var_text.align_right).",
              "default": "text.align_left",
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "text.align_left",
                "text.align_center",
                "text.align_right"
              ]
            }
          ],
          "syntax": "table.cell_set_text_halign(table_id, column, row, text_halign) → void",
          "seeAlso": [
            "[table.cell_set_bgcolor](#fun_table.cell_set_bgcolor)",
            "[table.cell_set_height](#fun_table.cell_set_height)",
            "[table.cell_set_text](#fun_table.cell_set_text)",
            "[table.cell_set_text_color](#fun_table.cell_set_text_color)",
            "[table.cell_set_text_size](#fun_table.cell_set_text_size)",
            "[table.cell_set_text_valign](#fun_table.cell_set_text_valign)",
            "[table.cell_set_width](#fun_table.cell_set_width)",
            "[table.cell_set_tooltip](#fun_table.cell_set_tooltip)"
          ],
          "thisType": [
            "series table"
          ],
          "methodName": "cell_set_text_halign",
          "originalName": "table.cell_set_text_halign",
          "methodSyntax": "table.cell_set_text_halign(column, row, text_halign) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "table.cell_set_text_valign",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function sets the vertical alignment of a cell\\`s text.",
          "args": [
            {
              "name": "column",
              "desc": "The index of the cell\\`s column. Numbering starts at 0.",
              "default": "0",
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            },
            {
              "name": "row",
              "desc": "The index of the cell\\`s row. Numbering starts at 0.",
              "default": "0",
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            },
            {
              "name": "text_valign",
              "desc": "The vertical alignment of the cell\\`s text.  \nPossible values: [text.align_top](#var_text.align_top), [text.align_center](#var_text.align_center), [text.align_bottom](#var_text.align_bottom).",
              "default": "text.align_center",
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "text.align_top",
                "text.align_center",
                "text.align_bottom"
              ]
            }
          ],
          "syntax": "table.cell_set_text_valign(table_id, column, row, text_valign) → void",
          "seeAlso": [
            "[table.cell_set_bgcolor](#fun_table.cell_set_bgcolor)",
            "[table.cell_set_height](#fun_table.cell_set_height)",
            "[table.cell_set_text](#fun_table.cell_set_text)",
            "[table.cell_set_text_color](#fun_table.cell_set_text_color)",
            "[table.cell_set_text_halign](#fun_table.cell_set_text_halign)",
            "[table.cell_set_text_size](#fun_table.cell_set_text_size)",
            "[table.cell_set_width](#fun_table.cell_set_width)",
            "[table.cell_set_tooltip](#fun_table.cell_set_tooltip)"
          ],
          "thisType": [
            "series table"
          ],
          "methodName": "cell_set_text_valign",
          "originalName": "table.cell_set_text_valign",
          "methodSyntax": "table.cell_set_text_valign(column, row, text_valign) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "table.cell_set_text_size",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function sets the size of the cell\\`s text.",
          "args": [
            {
              "name": "column",
              "desc": "The index of the cell\\`s column. Numbering starts at 0.",
              "default": "0",
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            },
            {
              "name": "row",
              "desc": "The index of the cell\\`s row. Numbering starts at 0.",
              "default": "0",
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            },
            {
              "name": "text_size",
              "desc": "The size of the text.  \nPossible values: [size.auto](#var_size.auto), [size.tiny](#var_size.tiny), [size.small](#var_size.small), [size.normal](#var_size.normal), [size.large](#var_size.large), [size.huge](#var_size.huge).",
              "default": "size.auto",
              "required": false,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "size.auto",
                "size.tiny",
                "size.small",
                "size.normal",
                "size.large",
                "size.huge"
              ]
            }
          ],
          "syntax": "table.cell_set_text_size(table_id, column, row, text_size) → void",
          "seeAlso": [
            "[table.cell_set_bgcolor](#fun_table.cell_set_bgcolor)",
            "[table.cell_set_height](#fun_table.cell_set_height)",
            "[table.cell_set_text](#fun_table.cell_set_text)",
            "[table.cell_set_text_color](#fun_table.cell_set_text_color)",
            "[table.cell_set_text_halign](#fun_table.cell_set_text_halign)",
            "[table.cell_set_text_valign](#fun_table.cell_set_text_valign)",
            "[table.cell_set_width](#fun_table.cell_set_width)",
            "[table.cell_set_tooltip](#fun_table.cell_set_tooltip)"
          ],
          "thisType": [
            "series table"
          ],
          "methodName": "cell_set_text_size",
          "originalName": "table.cell_set_text_size",
          "methodSyntax": "table.cell_set_text_size(column, row, text_size) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "table.cell_set_bgcolor",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function sets the background color of the cell.",
          "args": [
            {
              "name": "column",
              "desc": "The index of the cell\\`s column. Numbering starts at 0.",
              "default": "0",
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            },
            {
              "name": "row",
              "desc": "The index of the cell\\`s row. Numbering starts at 0.",
              "default": "0",
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            },
            {
              "name": "bgcolor",
              "desc": "The background color of the cell.",
              "default": null,
              "required": false,
              "displayType": "series color",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "possibleValues": [
                "colors"
              ]
            }
          ],
          "syntax": "table.cell_set_bgcolor(table_id, column, row, bgcolor) → void",
          "seeAlso": [
            "[table.cell_set_height](#fun_table.cell_set_height)",
            "[table.cell_set_text](#fun_table.cell_set_text)",
            "[table.cell_set_text_color](#fun_table.cell_set_text_color)",
            "[table.cell_set_text_halign](#fun_table.cell_set_text_halign)",
            "[table.cell_set_text_size](#fun_table.cell_set_text_size)",
            "[table.cell_set_text_valign](#fun_table.cell_set_text_valign)",
            "[table.cell_set_width](#fun_table.cell_set_width)",
            "[table.cell_set_tooltip](#fun_table.cell_set_tooltip)"
          ],
          "thisType": [
            "series table"
          ],
          "methodName": "cell_set_bgcolor",
          "originalName": "table.cell_set_bgcolor",
          "methodSyntax": "table.cell_set_bgcolor(column, row, bgcolor) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "matrix.row",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function creates a one-dimensional array from the elements of a matrix row.",
          "args": [
            {
              "name": "row",
              "desc": "Index of the required row.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            }
          ],
          "syntax": "matrix.row(id, row) → type[]",
          "remarks": "Indexing of rows starts at 0.",
          "returns": "An array ID containing the `row` values of the `id` matrix.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.get](#fun_matrix.get)",
            "[array.get](#fun_array.get)",
            "[matrix.col](#fun_matrix.col)",
            "[matrix.rows](#fun_matrix.rows)"
          ],
          "thisType": [
            "matrix"
          ],
          "examples": "//@version=5\nindicator(\"`matrix.row()` Example\", \"\", true)\n\n// Create a 2x3 \"float\" matrix from `hlc3` values.\nm = matrix.new<float>(2, 3, hlc3)\n\n// Return an array with the values of the first row of the matrix.\na = matrix.row(m, 0)\n\n// Plot the first value from the array `a`.\nplot(array.get(a, 0))",
          "methodName": "row",
          "originalName": "matrix.row",
          "methodSyntax": "matrix.row(row) → type[]",
          "returnedType": "array",
          "returnedTypes": [
            "array"
          ]
        },
        {
          "name": "matrix.col",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function creates a one-dimensional array from the elements of a matrix column.",
          "args": [
            {
              "name": "column",
              "desc": "Index of the required column.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            }
          ],
          "syntax": "matrix.col(id, column) → type[]",
          "remarks": "Indexing of rows starts at 0.",
          "returns": "An array ID containing the `column` values of the `id` matrix.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.get](#fun_matrix.get)",
            "[array.get](#fun_array.get)",
            "[matrix.col](#fun_matrix.col)",
            "[matrix.columns](#fun_matrix.columns)"
          ],
          "thisType": [
            "matrix"
          ],
          "examples": "//@version=5\nindicator(\"`matrix.col()` Example\", \"\", true)\n\n// Create a 2x3 \"float\" matrix from `hlc3` values.\nm = matrix.new<float>(2, 3, hlc3)\n\n// Return an array with the values of the first column of matrix `m`.\na = matrix.col(m, 0)\n\n// Plot the first value from the array `a`.\nplot(array.get(a, 0))",
          "methodName": "col",
          "originalName": "matrix.col",
          "methodSyntax": "matrix.col(column) → type[]",
          "returnedType": "array",
          "returnedTypes": [
            "array"
          ]
        },
        {
          "name": "matrix.reshape",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function rebuilds the `id` matrix to `rows` x `cols` dimensions.",
          "args": [
            {
              "name": "rows",
              "desc": "The number of rows of the reshaped matrix.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "columns",
              "desc": "The  of columns of the reshaped matrix.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "matrix.reshape(id, rows, columns) → void",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.get](#fun_matrix.get)",
            "[matrix.set](#fun_matrix.set)",
            "[matrix.add_row](#fun_matrix.add_row)",
            "[matrix.add_col](#fun_matrix.add_col)"
          ],
          "thisType": [
            "matrix"
          ],
          "examples": "//@version=5\nindicator(\"`matrix.reshape()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x3 matrix.\n\tvar m1 = matrix.new<float>(2, 3)\n\t// Fill the matrix with values.\n\tmatrix.set(m1, 0, 0, 1)\n\tmatrix.set(m1, 0, 1, 2)\n\tmatrix.set(m1, 0, 2, 3)\n\tmatrix.set(m1, 1, 0, 4)\n\tmatrix.set(m1, 1, 1, 5)\n\tmatrix.set(m1, 1, 2, 6)\n\t\n\t// Copy the matrix to a new one.\n\tvar m2 = matrix.copy(m1)\n\t\n\t// Reshape the copy to a 3x2.\n\tmatrix.reshape(m2, 3, 2)\n\t\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Original matrix:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 0, \"Reshaped matrix:\")\n\ttable.cell(t, 1, 1, str.tostring(m2))",
          "methodName": "reshape",
          "originalName": "matrix.reshape",
          "methodSyntax": "matrix.reshape(rows, columns) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "matrix.add_row",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function adds a row at the `row` index of the `id` matrix. The row can consist of `na` values, or an array can be used to provide values.",
          "args": [
            {
              "name": "row",
              "desc": "The index of the row after which the new row will be inserted. Optional. The default value is [matrix.rows](#fun_matrix.rows).",
              "default": "matrix.rows()",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            },
            {
              "name": "array_id",
              "desc": "An array to be inserted. Optional.",
              "default": null,
              "required": true,
              "displayType": "any[]",
              "allowedTypeIDs": "array",
              "possibleValues": null
            }
          ],
          "syntax": "matrix.add_row(id, row, array_id) → void",
          "remarks": "Indexing of rows and columns starts at zero. Rather than add rows to an empty matrix, it is far more efficient to declare a matrix with explicit dimensions and fill it with values.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.get](#fun_matrix.get)",
            "[matrix.set](#fun_matrix.set)",
            "[matrix.columns](#fun_matrix.columns)",
            "[matrix.rows](#fun_matrix.rows)",
            "[matrix.add_col](#fun_matrix.add_col)"
          ],
          "thisType": [
            "matrix"
          ],
          "methodName": "add_row",
          "originalName": "matrix.add_row",
          "methodSyntax": "matrix.add_row(row, array_id) → void",
          "detailedDesc": [
            {
              "desc": "Adding a row to the matrix",
              "examples": "//@version=5\nindicator(\"`matrix.add_row()` Example 1\")\n\n// Create a 2x3 \"int\" matrix containing values `0`.\nm = matrix.new<int>(2, 3, 0)\n\n// Add a row with `na` values to the matrix.\nmatrix.add_row(m)\n\n// Display matrix elements.\nif barstate.islastconfirmedhistory\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Matrix elements:\")\n\ttable.cell(t, 0, 1, str.tostring(m))"
            },
            {
              "desc": "Adding an array as a row to the matrix",
              "examples": "//@version=5\nindicator(\"`matrix.add_row()` Example 2\")\n\nif barstate.islastconfirmedhistory\n\t// Create an empty matrix object. \n\tvar m = matrix.new<int>()\n\t\n\t// Create an array with values `1` and `2`.\n\tvar a = array.from(1, 2)\n\t\n\t// Add the `a` array as the first row of the empty matrix.\n\tmatrix.add_row(m, 0, a)\n\t\n\t// Display matrix elements.\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Matrix elements:\")\n\ttable.cell(t, 0, 1, str.tostring(m))"
            }
          ],
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "matrix.add_col",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function adds a column at the `column` index of the `id` matrix. The column can consist of `na` values, or an array can be used to provide values.",
          "args": [
            {
              "name": "column",
              "desc": "The index of the column after which the new column will be inserted. Optional. The default value is [matrix.columns](#fun_matrix.columns).",
              "default": "matrix.columns()",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            },
            {
              "name": "array_id",
              "desc": "An array to be inserted. Optional.",
              "default": null,
              "required": true,
              "displayType": "any[]",
              "allowedTypeIDs": "array",
              "possibleValues": null
            }
          ],
          "syntax": "matrix.add_col(id, column) → void\nmatrix.add_col(id, column, array_id) → void",
          "remarks": "Rather than add columns to an empty matrix, it is far more efficient to declare a matrix with explicit dimensions and fill it with values.  \nAdding a column is also much slower than adding a row with the [matrix.add_row](#fun_matrix.add_row) function.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.get](#fun_matrix.get)",
            "[matrix.set](#fun_matrix.set)",
            "[matrix.columns](#fun_matrix.columns)",
            "[matrix.rows](#fun_matrix.rows)",
            "[matrix.add_row](#fun_matrix.add_row)"
          ],
          "thisType": [
            "matrix"
          ],
          "methodName": "add_col",
          "originalName": "matrix.add_col",
          "methodSyntax": "matrix.add_col(column) → void\nmatrix.add_col(id, column, array_id) → void",
          "detailedDesc": [
            {
              "desc": "Adding a column to the matrix",
              "examples": "//@version=5\nindicator(\"`matrix.add_col()` Example 1\")\n\n// Create a 2x3 \"int\" matrix containing values `0`.\nm = matrix.new<int>(2, 3, 0)\n\n// Add a column  with `na` values to the matrix.\nmatrix.add_col(m)\n\n// Display matrix elements.\nif barstate.islastconfirmedhistory\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Matrix elements:\")\n\ttable.cell(t, 0, 1, str.tostring(m))"
            },
            {
              "desc": "Adding an array as a column to the matrix",
              "examples": "//@version=5\nindicator(\"`matrix.add_col()` Example 2\")\n\nif barstate.islastconfirmedhistory\n\t// Create an empty matrix object. \n\tvar m = matrix.new<int>()\n\t\n\t// Create an array with values `1` and `3`.\n\tvar a = array.from(1, 3)\n\t\n\t// Add the `a` array as the first column of the empty matrix.\n\tmatrix.add_col(m, 0, a)\n\t\n\t// Display matrix elements.\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Matrix elements:\")\n\ttable.cell(t, 0, 1, str.tostring(m))"
            }
          ],
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "matrix.remove_row",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function removes the row at `row` index of the `id` matrix and returns an array containing the removed row\\`s values.",
          "args": [
            {
              "name": "row",
              "desc": "The index of the row to be deleted. Optional. The default value is [matrix.rows](#fun_matrix.rows).",
              "default": "matrix.rows()",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            }
          ],
          "syntax": "matrix.remove_row(id, row) → type[]",
          "remarks": "Indexing of rows and columns starts at zero. It is far more efficient to declare matrices with explicit dimensions than to build them by adding or removing rows.",
          "returns": "An array containing the elements of the row removed from the `id` matrix.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.set](#fun_matrix.set)",
            "[matrix.copy](#fun_matrix.copy)",
            "[matrix.remove_col](#fun_matrix.remove_col)"
          ],
          "thisType": [
            "matrix"
          ],
          "examples": "//@version=5\nindicator(\"matrix_remove_row\", overlay = true)\n\n// Create a 2x2 \"int\" matrix containing values `1`.\nvar matrixOrig = matrix.new<int>(2, 2, 1)\n\n// Set values to the 'matrixOrig' matrix.\nmatrix.set(matrixOrig, 0, 1, 2)\nmatrix.set(matrixOrig, 1, 0, 3)\nmatrix.set(matrixOrig, 1, 1, 4)\n\n// Create a copy of the 'matrixOrig' matrix.\nmatrixCopy = matrix.copy(matrixOrig)\n\n// Remove the first row from the matrix `matrixCopy`.\narr = matrix.remove_row(matrixCopy, 0)\n\n// Display matrix elements.\nif barstate.islastconfirmedhistory\n\tvar t = table.new(position.top_right, 3, 2, color.green)\n\ttable.cell(t, 0, 0, \"Original Matrix:\")\n\ttable.cell(t, 0, 1, str.tostring(matrixOrig))\n\ttable.cell(t, 1, 0, \"Removed Elements:\")\n\ttable.cell(t, 1, 1, str.tostring(arr))\n\ttable.cell(t, 2, 0, \"Result Matrix:\")\n\ttable.cell(t, 2, 1, str.tostring(matrixCopy))",
          "methodName": "remove_row",
          "originalName": "matrix.remove_row",
          "methodSyntax": "matrix.remove_row(row) → type[]",
          "returnedType": "array",
          "returnedTypes": [
            "array"
          ]
        },
        {
          "name": "matrix.remove_col",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function removes the column at `column` index of the `id` matrix and returns an array containing the removed column\\`s values.",
          "args": [
            {
              "name": "column",
              "desc": "The index of the column to be removed. Optional. The default value is [matrix.columns](#fun_matrix.columns).",
              "default": "matrix.columns()",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            }
          ],
          "syntax": "matrix.remove_col(id, column) → type[]",
          "remarks": "Indexing of rows and columns starts at zero. It is far more efficient to declare matrices with explicit dimensions than to build them by adding or removing columns.  \nDeleting a column is also much slower than deleting a row with the [matrix.remove_row](#fun_matrix.remove_row) function.",
          "returns": "An array containing the elements of the column removed from the `id` matrix.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.set](#fun_matrix.set)",
            "[matrix.copy](#fun_matrix.copy)",
            "[matrix.remove_row](#fun_matrix.remove_row)"
          ],
          "thisType": [
            "matrix"
          ],
          "examples": "//@version=5\nindicator(\"matrix_remove_col\", overlay = true)\n\n// Create a 2x2 matrix with ones.\nvar matrixOrig = matrix.new<int>(2, 2, 1)\n\n// Set values to the 'matrixOrig' matrix.\nmatrix.set(matrixOrig, 0, 1, 2)\nmatrix.set(matrixOrig, 1, 0, 3)\nmatrix.set(matrixOrig, 1, 1, 4)\n\n\n// Create a copy of the 'matrixOrig' matrix.\nmatrixCopy = matrix.copy(matrixOrig)\n\n// Remove the first column from the `matrixCopy` matrix.\narr = matrix.remove_col(matrixCopy, 0)\n\n// Display matrix elements.\nif barstate.islastconfirmedhistory\n\tvar t = table.new(position.top_right, 3, 2, color.green)\n\ttable.cell(t, 0, 0, \"Original Matrix:\")\n\ttable.cell(t, 0, 1, str.tostring(matrixOrig))\n\ttable.cell(t, 1, 0, \"Removed Elements:\")\n\ttable.cell(t, 1, 1, str.tostring(arr))\n\ttable.cell(t, 2, 0, \"Result Matrix:\")\n\ttable.cell(t, 2, 1, str.tostring(matrixCopy))",
          "methodName": "remove_col",
          "originalName": "matrix.remove_col",
          "methodSyntax": "matrix.remove_col(column) → type[]",
          "returnedType": "array",
          "returnedTypes": [
            "array"
          ]
        },
        {
          "name": "matrix.submatrix",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function extracts a submatrix of the `id` matrix within the specified indices.",
          "args": [
            {
              "name": "from_row",
              "desc": "Index of the row from which the extraction will begin (inclusive). Optional. The default value is 0.",
              "default": "0",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "to_row",
              "desc": "Index of the row where the extraction will end (non inclusive). Optional. The default value is [matrix.rows](#fun_matrix.rows).",
              "default": "matrix.rows()",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "from_column",
              "desc": "Index of the column from which the extraction will begin (inclusive). Optional. The default value is 0.",
              "default": "0",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "to_column",
              "desc": "Index of the column where the extraction will end (non inclusive). Optional. The default value is [matrix.columns](#fun_matrix.columns).",
              "default": "matrix.columns()",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "matrix.submatrix(id, from_row, to_row, from_column, to_column) → matrix<type>",
          "remarks": "Indexing of the rows and columns starts at zero.",
          "returns": "A new matrix object containing the submatrix of the `id` matrix defined by the `from_row`, `to_row`, `from_column` and `to_column` indices.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.set](#fun_matrix.set)",
            "[matrix.row](#fun_matrix.row)",
            "[matrix.col](#fun_matrix.col)",
            "[matrix.reshape](#fun_matrix.reshape)"
          ],
          "thisType": [
            "matrix"
          ],
          "examples": "//@version=5\nindicator(\"`matrix.submatrix()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x3 matrix matrix with values `0`.\n\tvar m1 = matrix.new<int>(2, 3, 0)\n\t// Fill the matrix with values.\n\tmatrix.set(m1, 0, 0, 1)\n\tmatrix.set(m1, 0, 1, 2)\n\tmatrix.set(m1, 0, 2, 3)\n\tmatrix.set(m1, 1, 0, 4)\n\tmatrix.set(m1, 1, 1, 5)\n\tmatrix.set(m1, 1, 2, 6)\n\t\n\t// Create a 2x2 submatrix of the `m1` matrix.\n\tvar m2 = matrix.submatrix(m1, 0, 2, 1, 3)\n\t\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Original Matrix:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 0, \"Submatrix:\")\n\ttable.cell(t, 1, 1, str.tostring(m2))",
          "methodName": "submatrix",
          "originalName": "matrix.submatrix",
          "methodSyntax": "matrix.submatrix(from_row, to_row, from_column, to_column) → matrix<type>",
          "returnedType": "matrix",
          "returnedTypes": [
            "matrix"
          ]
        },
        {
          "name": "matrix.columns",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function returns the number of columns in the matrix.",
          "args": [],
          "syntax": "matrix.columns(id) → series int",
          "returns": "The number of columns in the matrix `id`.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.get](#fun_matrix.get)",
            "[matrix.set](#fun_matrix.set)",
            "[matrix.col](#fun_matrix.col)",
            "[matrix.row](#fun_matrix.row)",
            "[matrix.rows](#fun_matrix.rows)"
          ],
          "thisType": [
            "matrix"
          ],
          "examples": "//@version=5\nindicator(\"`matrix.columns()` Example\")\n\n// Create a 2x6 matrix with values `0`.\nvar m = matrix.new<int>(2, 6, 0)\n\n// Get the quantity of columns in matrix `m`.\nvar x = matrix.columns(m)\n\n// Display using a label.\nif barstate.islastconfirmedhistory\n\tlabel.new(bar_index, high, \"Columns: \" + str.tostring(x) + \"\\n\" + str.tostring(m))",
          "methodName": "columns",
          "originalName": "matrix.columns",
          "methodSyntax": "matrix.columns() → series int",
          "returnedType": "int",
          "returnedTypes": [
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "name": "matrix.rows",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function returns the number of rows in the matrix.",
          "args": [],
          "syntax": "matrix.rows(id) → series int",
          "returns": "The number of rows in the matrix `id`.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.get](#fun_matrix.get)",
            "[matrix.set](#fun_matrix.set)",
            "[matrix.columns](#fun_matrix.columns)",
            "[matrix.row](#fun_matrix.row)"
          ],
          "thisType": [
            "matrix"
          ],
          "examples": "//@version=5\nindicator(\"`matrix.rows()` Example\")\n\n// Create a 2x6 matrix with values `0`.\nvar m = matrix.new<int>(2, 6, 0)\n\n// Get the quantity of rows in the matrix.\nvar x = matrix.rows(m)\n\n// Display using a label.\nif barstate.islastconfirmedhistory\n\tlabel.new(bar_index, high, \"Rows: \" + str.tostring(x) + \"\\n\" + str.tostring(m))",
          "methodName": "rows",
          "originalName": "matrix.rows",
          "methodSyntax": "matrix.rows() → series int",
          "returnedType": "int",
          "returnedTypes": [
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "name": "matrix.elements_count",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function returns the total number of all matrix elements.",
          "args": [],
          "syntax": "matrix.elements_count(id) → series int",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.columns](#fun_matrix.columns)",
            "[matrix.rows](#fun_matrix.rows)"
          ],
          "thisType": [
            "matrix"
          ],
          "methodName": "elements_count",
          "originalName": "matrix.elements_count",
          "methodSyntax": "matrix.elements_count() → series int",
          "returnedType": "int",
          "returnedTypes": [
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "name": "matrix.swap_rows",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function swaps the rows at the index `row1` and `row2` in the `id` matrix.",
          "args": [
            {
              "name": "row1",
              "desc": "Index of the first row to be swapped.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "row2",
              "desc": "Index of the second row to be swapped.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "matrix.swap_rows(id, row1, row2) → void",
          "remarks": "Indexing of the rows and columns starts at zero.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.get](#fun_matrix.get)",
            "[matrix.set](#fun_matrix.set)",
            "[matrix.columns](#fun_matrix.columns)",
            "[matrix.swap_columns](#fun_matrix.swap_columns)"
          ],
          "thisType": [
            "matrix"
          ],
          "examples": "//@version=5\nindicator(\"`matrix.swap_rows()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 3x2 matrix with ‘na’ values.\n\tvar m1 = matrix.new<int>(3, 2, na)\n\t// Fill the matrix with values.\n\tmatrix.set(m1, 0, 0, 1)\n\tmatrix.set(m1, 0, 1, 2)\n\tmatrix.set(m1, 1, 0, 3)\n\tmatrix.set(m1, 1, 1, 4)\n\tmatrix.set(m1, 2, 0, 5)\n\tmatrix.set(m1, 2, 1, 6)\n\t\n\t// Copy the matrix to a new one.\n\tvar m2 = matrix.copy(m1)\n\t\n\t// Swap the first and second rows of the matrix copy.\n\tmatrix.swap_rows(m2, 0, 1)\n\t\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Original matrix:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 0, \"Swapped rows in copy:\")\n\ttable.cell(t, 1, 1, str.tostring(m2))",
          "methodName": "swap_rows",
          "originalName": "matrix.swap_rows",
          "methodSyntax": "matrix.swap_rows(row1, row2) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "matrix.swap_columns",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function swaps the columns at the index `column1` and `column2` in the `id` matrix.",
          "args": [
            {
              "name": "column1",
              "desc": "Index of the first column to be swapped.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "column2",
              "desc": "Index of the second column to be swapped.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "matrix.swap_columns(id, column1, column2) → void",
          "remarks": "Indexing of the rows and columns starts at zero.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.get](#fun_matrix.get)",
            "[matrix.set](#fun_matrix.set)",
            "[matrix.columns](#fun_matrix.columns)",
            "[matrix.rows](#fun_matrix.rows)"
          ],
          "thisType": [
            "matrix"
          ],
          "examples": "//@version=5\nindicator(\"`matrix.swap_columns()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x2 matrix with ‘na’ values.\n\tvar m1 = matrix.new<int>(2, 2, na)    \n\t// Fill the matrix with values.\n\tmatrix.set(m1, 0, 0, 1)\n\tmatrix.set(m1, 0, 1, 2)\n\tmatrix.set(m1, 1, 0, 3)\n\tmatrix.set(m1, 1, 1, 4)\n\t\n\t// Copy the matrix to a new one.\n\tvar m2 = matrix.copy(m1)\n\t\n\t// Swap the first and second columns of the matrix copy.\n\tmatrix.swap_columns(m2, 0, 1)\n\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Original matrix:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 0, \"Swapped columns in copy:\")\n\ttable.cell(t, 1, 1, str.tostring(m2))",
          "methodName": "swap_columns",
          "originalName": "matrix.swap_columns",
          "methodSyntax": "matrix.swap_columns(column1, column2) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "matrix.det",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function returns the [determinant](https://en.wikipedia.org/wiki/Determinant) of a square matrix.",
          "args": [],
          "syntax": "matrix.det(id) → series float|int",
          "remarks": "Function calculation based on the [LU decomposition](https://en.wikipedia.org/wiki/LU_decomposition) algorithm.",
          "returns": "The determinant value of the `id` matrix.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.set](#fun_matrix.set)",
            "[matrix.is_square](#fun_matrix.is_square)"
          ],
          "thisType": [
            "matrix<float>",
            "matrix<int>"
          ],
          "examples": "//@version=5\nindicator(\"`matrix.det` Example\")\n\n// Create a 2x2 matrix.\nvar m = matrix.new<float>(2, 2, na)\n// Fill the matrix with values.\nmatrix.set(m, 0, 0,  3)\nmatrix.set(m, 0, 1,  7)\nmatrix.set(m, 1, 0,  1)\nmatrix.set(m, 1, 1, -4)\n\n// Get the determinant of the matrix. \nvar x = matrix.det(m)\n\nplot(x, 'Matrix determinant')",
          "methodName": "det",
          "originalName": "matrix.det",
          "methodSyntax": "matrix.det() → series float|int",
          "returnedType": [
            "float",
            "int"
          ],
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float",
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "name": "matrix.transpose",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function creates a new, [transposed](https://en.wikipedia.org/wiki/Transpose#Transpose_of_a_matrix) version of the `id`.  \nThis interchanges the row and column index of each element.",
          "args": [],
          "syntax": "matrix.transpose(id) → matrix<type>",
          "returns": "A new matrix containing the transposed version of the `id` matrix.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.set](#fun_matrix.set)",
            "[matrix.columns](#fun_matrix.columns)",
            "[matrix.rows](#fun_matrix.rows)",
            "[matrix.reshape](#fun_matrix.reshape)",
            "[matrix.reverse](#fun_matrix.reverse)"
          ],
          "thisType": [
            "matrix"
          ],
          "examples": "//@version=5\nindicator(\"`matrix.transpose()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x2 matrix. \n\tvar m1 = matrix.new<float>(2, 2, na)\n\t// Fill the matrix with values.\n\tmatrix.set(m1, 0, 0, 1)\n\tmatrix.set(m1, 0, 1, 2)\n\tmatrix.set(m1, 1, 0, 3)\n\tmatrix.set(m1, 1, 1, 4)\n\t\n\t// Create a transpose of the matrix.\n\tvar m2 = matrix.transpose(m1)\n\t\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Original matrix:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 0, \"Transposed matrix:\")\n\ttable.cell(t, 1, 1, str.tostring(m2))",
          "methodName": "transpose",
          "originalName": "matrix.transpose",
          "methodSyntax": "matrix.transpose() → matrix<type>",
          "returnedType": "matrix",
          "returnedTypes": [
            "matrix"
          ]
        },
        {
          "name": "matrix.diff",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function returns a new matrix resulting from the subtraction between matrices `id1` and `id2`, or of matrix `id1` and an `id2` scalar (a numerical value).",
          "args": [
            {
              "name": "id2",
              "desc": "Matrix object or a scalar value to be subtracted.",
              "default": null,
              "required": true,
              "displayType": "series int|float|matrix<int|float>",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float",
                "matrix<int>",
                "matrix<float>"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "matrix.diff(id1, id2) → matrix<int|float>",
          "returns": "A new matrix object containing the difference between `id2` and `id1`.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.get](#fun_matrix.get)",
            "[matrix.set](#fun_matrix.set)",
            "[matrix.columns](#fun_matrix.columns)",
            "[matrix.rows](#fun_matrix.rows)"
          ],
          "thisType": [
            "matrix<int>",
            "matrix<float>"
          ],
          "methodName": "diff",
          "originalName": "matrix.diff",
          "methodSyntax": "matrix.diff(id2) → matrix<int|float>",
          "detailedDesc": [
            {
              "desc": "Difference between two matrices",
              "examples": "//@version=5\nindicator(\"`matrix.diff()` Example 1\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x3 matrix containing values `5`.\n\tvar m1 = matrix.new<float>(2, 3, 5) \n\t// Create a 2x3 matrix containing values `4`.\n\tvar m2 = matrix.new<float>(2, 3, 4) \n\t// Create a new matrix containing the difference between matrices `m1` and `m2`.\n\tvar m3 = matrix.diff(m1, m2) \n\t\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 1, 2, color.green)\n\ttable.cell(t, 0, 0, \"Difference between two matrices:\")\n\ttable.cell(t, 0, 1, str.tostring(m3))"
            },
            {
              "desc": "Difference between a matrix and a scalar value",
              "examples": "//@version=5\nindicator(\"`matrix.diff()` Example 2\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x3 matrix with values `4`.\n\tvar m1 = matrix.new<float>(2, 3, 4)\n\t\n\t// Create a new matrix containing the difference between the `m1` matrix and the \"int\" value `1`.\n\tvar m2 = matrix.diff(m1, 1)\n\t\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 1, 2, color.green)\n\ttable.cell(t,  0, 0, \"Difference between a matrix and a scalar:\")\n\ttable.cell(t,  0, 1, str.tostring(m2))"
            }
          ],
          "returnedType": [
            "matrix<float>",
            "matrix<int>"
          ],
          "returnedTypes": [
            "matrix<int>",
            "matrix<float>"
          ]
        },
        {
          "name": "matrix.mult",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function returns a new matrix resulting from the [product](https://en.wikipedia.org/wiki/Matrix_multiplication) between the matrices `id1` and `id2`, or between an `id1` matrix and an `id2` scalar (a numerical value), or between an `id1` matrix and an `id2` vector (an array of values).",
          "args": [
            {
              "name": "id2",
              "desc": "Second matrix object, value or array.",
              "default": null,
              "required": true,
              "displayType": "series int|float|matrix<int|float>|array<int|float>",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float",
                "matrix<int>",
                "matrix<float>",
                "array<int>",
                "array<float>"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "matrix.mult(id1, id2) → matrix<int|float>\nmatrix.mult(id1, id2) → array<int|float>",
          "returns": "A new matrix object containing the product of `id2` and `id1`.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.sum](#fun_matrix.sum)",
            "[matrix.diff](#fun_matrix.diff)"
          ],
          "thisType": [
            "matrix<int>",
            "matrix<float>"
          ],
          "methodName": "mult",
          "originalName": "matrix.mult",
          "methodSyntax": "matrix.mult(id2) → matrix<int|float>\nmatrix.mult(id2) → array<int|float>",
          "detailedDesc": [
            {
              "desc": "Product of two matrices",
              "examples": "//@version=5\nindicator(\"`matrix.mult()` Example 1\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 6x2 matrix containing values `5`.\n\tvar m1 = matrix.new<float>(6, 2, 5) \n\t// Create a 2x3 matrix containing values `4`.\n\t// Note that it must have the same quantity of rows as there are columns in the first matrix.\n\tvar m2 = matrix.new<float>(2, 3, 4) \n\t// Create a new matrix from the multiplication of the two matrices.\n\tvar m3 = matrix.mult(m1, m2) \n\t\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 1, 2, color.green)\n\ttable.cell(t, 0, 0, \"Product of two matrices:\")\n\ttable.cell(t, 0, 1, str.tostring(m3))"
            },
            {
              "desc": "Product of a matrix and a scalar",
              "examples": "//@version=5\nindicator(\"`matrix.mult()` Example 2\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x3 matrix containing values `4`.\n\tvar m1 = matrix.new<float>(2, 3, 4) \n\t\n\t// Create a new matrix from the product of the two matrices.\n\tscalar = 5\n\tvar m2 = matrix.mult(m1, scalar) \n\t\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 5, 2, color.green)\n\ttable.cell(t, 0, 0, \"Matrix 1:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 1, \"x\")\n\ttable.cell(t, 2, 0, \"Scalar:\")\n\ttable.cell(t, 2, 1, str.tostring(scalar))\n\ttable.cell(t, 3, 1, \"=\")\n\ttable.cell(t, 4, 0, \"Matrix 2:\")\n\ttable.cell(t, 4, 1, str.tostring(m2))"
            },
            {
              "desc": "Product of a matrix and an array vector",
              "examples": "//@version=5\nindicator(\"`matrix.mult()` Example 3\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x3 matrix containing values `4`.\n\tvar m1 = matrix.new<int>(2, 3, 4)\n\t\n\t// Create an array of three elements.\n\tvar array<int> a = array.from(1, 1, 1)\n\t\n\t// Create a new matrix containing the product of the `m1` matrix and the `a` array.\n\tvar m3 = matrix.mult(m1, a) \n\t\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 5, 2, color.green)\n\ttable.cell(t, 0, 0, \"Matrix 1:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 1, \"x\")\n\ttable.cell(t, 2, 0, \"Value:\")\n\ttable.cell(t, 2, 1, str.tostring(a, \" \"))\n\ttable.cell(t, 3, 1, \"=\")\n\ttable.cell(t, 4, 0, \"Matrix 3:\")\n\ttable.cell(t, 4, 1, str.tostring(m3))"
            }
          ],
          "returnedType": [
            "array<float>",
            "array<int>",
            "matrix<float>",
            "matrix<int>"
          ],
          "returnedTypes": [
            "matrix<int>",
            "matrix<float>",
            "array<int>",
            "array<float>"
          ]
        },
        {
          "name": "matrix.pinv",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function returns the [pseudoinverse](https://en.wikipedia.org/wiki/Moore%E2%80%93Penrose_inverse) of a matrix.",
          "args": [],
          "syntax": "matrix.pinv(id) → matrix<float|int>",
          "remarks": "The function is calculated using a [Moore–Penrose](https://en.wikipedia.org/wiki/Moore%E2%80%93Penrose_inverse#Definition) inverse formula based on singular-value decomposition of a matrix.  \nFor non-singular square matrices this function returns the result of [matrix.inv](#fun_matrix.inv).",
          "returns": "A new matrix containing the pseudoinverse of the `id` matrix.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.set](#fun_matrix.set)",
            "[matrix.inv](#fun_matrix.inv)"
          ],
          "thisType": [
            "matrix<float>",
            "matrix<int>"
          ],
          "examples": "//@version=5\nindicator(\"`matrix.pinv()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x2 matrix. \n\tvar m1 = matrix.new<int>(2, 2, na)\n\t// Fill the matrix with values.\n\tmatrix.set(m1, 0, 0, 1)\n\tmatrix.set(m1, 0, 1, 2)\n\tmatrix.set(m1, 1, 0, 3)\n\tmatrix.set(m1, 1, 1, 4)\n\t\n\t// Pseudoinverse of the matrix.\n\tvar m2 = matrix.pinv(m1)\n\t\n\t// Display matrix elements.\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Original Matrix:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 0, \"Pseudoinverse matrix:\")\n\ttable.cell(t, 1, 1, str.tostring(m2))",
          "methodName": "pinv",
          "originalName": "matrix.pinv",
          "methodSyntax": "matrix.pinv() → matrix<float|int>",
          "returnedType": [
            "matrix<float>",
            "matrix<int>"
          ],
          "returnedTypes": [
            "matrix<float>",
            "matrix<int>"
          ]
        },
        {
          "name": "matrix.inv",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function returns the [inverse](https://en.wikipedia.org/wiki/Invertible_matrix) of a square matrix.",
          "args": [],
          "syntax": "matrix.inv(id) → matrix<float|int>",
          "remarks": "The function is calculated using the [LU decomposition](https://en.wikipedia.org/wiki/LU_decomposition) algorithm.",
          "returns": "A new matrix, which is the inverse of the `id` matrix.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.set](#fun_matrix.set)",
            "[matrix.pinv](#fun_matrix.pinv)",
            "[matrix.copy](#fun_matrix.copy)",
            "[str.tostring](#fun_str.tostring)"
          ],
          "thisType": [
            "matrix<float>",
            "matrix<int>"
          ],
          "examples": "//@version=5\nindicator(\"`matrix.inv()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x2 matrix. \n\tvar m1 = matrix.new<int>(2, 2, na)\n\t// Fill the matrix with values.\n\tmatrix.set(m1, 0, 0, 1)\n\tmatrix.set(m1, 0, 1, 2)\n\tmatrix.set(m1, 1, 0, 3)\n\tmatrix.set(m1, 1, 1, 4)\n\t\n\t// Inverse of the matrix.\n\tvar m2 = matrix.inv(m1)\n\t\n\t// Display matrix elements.\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Original Matrix:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 0, \"Inverse matrix:\")\n\ttable.cell(t, 1, 1, str.tostring(m2))",
          "methodName": "inv",
          "originalName": "matrix.inv",
          "methodSyntax": "matrix.inv() → matrix<float|int>",
          "returnedType": [
            "matrix<float>",
            "matrix<int>"
          ],
          "returnedTypes": [
            "matrix<float>",
            "matrix<int>"
          ]
        },
        {
          "name": "matrix.rank",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function calculates the [rank](https://en.wikipedia.org/wiki/Rank_(linear_algebra)) of the matrix.",
          "args": [],
          "syntax": "matrix.rank(id) → series int",
          "returns": "The rank of the `id` matrix.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.set](#fun_matrix.set)",
            "[str.tostring](#fun_str.tostring)"
          ],
          "thisType": [
            "matrix"
          ],
          "examples": "//@version=5\nindicator(\"`matrix.rank()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x2 matrix. \n\tvar m1 = matrix.new<int>(2, 2, na)\n\t// Fill the matrix with values.\n\tmatrix.set(m1, 0, 0, 1)\n\tmatrix.set(m1, 0, 1, 2)\n\tmatrix.set(m1, 1, 0, 3)\n\tmatrix.set(m1, 1, 1, 4)\n\t\n\t// Get the rank of the matrix. \n\tr = matrix.rank(m1)\n\t\n\t// Display matrix elements.\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Matrix elements:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 0, \"Rank of the matrix:\")\n\ttable.cell(t, 1, 1, str.tostring(r)) ",
          "methodName": "rank",
          "originalName": "matrix.rank",
          "methodSyntax": "matrix.rank() → series int",
          "returnedType": "int",
          "returnedTypes": [
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "name": "matrix.trace",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function calculates the [trace](https://en.wikipedia.org/wiki/Trace_(linear_algebra)) of a matrix (the sum of the main diagonal\\`s elements).",
          "args": [],
          "syntax": "matrix.trace(id) → series float|int",
          "returns": "The trace of the `id` matrix.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.get](#fun_matrix.get)",
            "[matrix.set](#fun_matrix.set)",
            "[matrix.columns](#fun_matrix.columns)",
            "[matrix.rows](#fun_matrix.rows)"
          ],
          "thisType": [
            "matrix<float>",
            "matrix<int>"
          ],
          "examples": "//@version=5\nindicator(\"`matrix.trace()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x2 matrix. \n\tvar m1 = matrix.new<int>(2, 2, na)\n\t// Fill the matrix with values.\n\tmatrix.set(m1, 0, 0, 1)\n\tmatrix.set(m1, 0, 1, 2)\n\tmatrix.set(m1, 1, 0, 3)\n\tmatrix.set(m1, 1, 1, 4)\n\t\n\t// Get the trace of the matrix.\n\ttr = matrix.trace(m1)\n\t\n\t// Display matrix elements.\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Matrix elements:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 0, \"Trace of the matrix:\")\n\ttable.cell(t, 1, 1, str.tostring(tr))",
          "methodName": "trace",
          "originalName": "matrix.trace",
          "methodSyntax": "matrix.trace() → series float|int",
          "returnedType": [
            "float",
            "int"
          ],
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float",
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "name": "matrix.eigenvalues",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function returns an array containing the [eigenvalues](https://en.wikipedia.org/wiki/Eigenvalues_and_eigenvectors) of a square matrix.",
          "args": [],
          "syntax": "matrix.eigenvalues(id) → array<float|int>",
          "remarks": "The function is calculated using \"The Implicit QL Algorithm\".",
          "returns": "An array containing the eigenvalues of the `id` matrix.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.set](#fun_matrix.set)",
            "[matrix.eigenvectors](#fun_matrix.eigenvectors)"
          ],
          "thisType": [
            "matrix<float>",
            "matrix<int>"
          ],
          "examples": "//@version=5\nindicator(\"`matrix.eigenvalues()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x2 matrix. \n\tvar m1 = matrix.new<int>(2, 2, na)\n\t// Fill the matrix with values.\n\tmatrix.set(m1, 0, 0, 2)\n\tmatrix.set(m1, 0, 1, 4)\n\tmatrix.set(m1, 1, 0, 6)\n\tmatrix.set(m1, 1, 1, 8)\n\t\n\t// Get the eigenvalues of the matrix.\n\ttr = matrix.eigenvalues(m1)\n\t\n\t// Display matrix elements.\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Matrix elements:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 0, \"Array of Eigenvalues:\")\n\ttable.cell(t, 1, 1, str.tostring(tr)) ",
          "methodName": "eigenvalues",
          "originalName": "matrix.eigenvalues",
          "methodSyntax": "matrix.eigenvalues() → array<float|int>",
          "returnedType": [
            "array<int>",
            "array<float>"
          ],
          "returnedTypes": [
            "array<float>",
            "array<int>"
          ]
        },
        {
          "name": "matrix.eigenvectors",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Returns a matrix of [eigenvectors](https://en.wikipedia.org/wiki/Eigenvalues_and_eigenvectors), in which each column is an eigenvector of the `id` matrix.",
          "args": [],
          "syntax": "matrix.eigenvectors(id) → matrix<float|int>",
          "remarks": "The function is calculated using \"The Implicit QL Algorithm\".",
          "returns": "A new matrix containing the eigenvectors of the `id` matrix.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.get](#fun_matrix.get)",
            "[matrix.set](#fun_matrix.set)",
            "[matrix.eigenvalues](#fun_matrix.eigenvalues)"
          ],
          "thisType": [
            "matrix<float>",
            "matrix<int>"
          ],
          "examples": "//@version=5\nindicator(\"`matrix.eigenvectors()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x2 matrix \n\tvar m1 = matrix.new<int>(2, 2, 1)\n\t// Fill the matrix with values.\n\tmatrix.set(m1, 0, 0, 2)\n\tmatrix.set(m1, 0, 1, 4)\n\tmatrix.set(m1, 1, 0, 6)\n\tmatrix.set(m1, 1, 1, 8)\n\t\n\t// Get the eigenvectors of the matrix.\n\tm2 = matrix.eigenvectors(m1)\n\t\n\t// Display matrix elements.\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Matrix Elements:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 0, \"Matrix Eigenvectors:\")\n\ttable.cell(t, 1, 1, str.tostring(m2))  ",
          "methodName": "eigenvectors",
          "originalName": "matrix.eigenvectors",
          "methodSyntax": "matrix.eigenvectors() → matrix<float|int>",
          "returnedType": [
            "matrix<float>",
            "matrix<int>"
          ],
          "returnedTypes": [
            "matrix<float>",
            "matrix<int>"
          ]
        },
        {
          "name": "matrix.kron",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function returns the [Kronecker product](https://en.wikipedia.org/wiki/Kronecker_product) for the `id1` and `id2` matrices.",
          "args": [
            {
              "name": "id2",
              "desc": "Second matrix object.",
              "default": null,
              "required": true,
              "displayType": "matrix<float|int>",
              "allowedTypeIDs": [
                "matrix<float>",
                "matrix<int>"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "matrix.kron(id1, id2) → matrix<float|int>",
          "returns": "A new matrix containing the [Kronecker product](https://en.wikipedia.org/wiki/Kronecker_product) of `id1` and `id2`.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.mult](#fun_matrix.mult)",
            "[str.tostring](#fun_str.tostring)",
            "[table.new](#fun_table.new)"
          ],
          "thisType": [
            "matrix<float>",
            "matrix<int>"
          ],
          "examples": "//@version=5\nindicator(\"`matrix.kron()` Example\")\n\n// Display using a table.\nif barstate.islastconfirmedhistory\n\t// Create two matrices with default values `1` and `2`. \n\tvar m1 = matrix.new<float>(2, 2, 1) \n\tvar m2 = matrix.new<float>(2, 2, 2) \n\t\n\t// Calculate the Kronecker product of the matrices.\n\tvar m3 = matrix.kron(m1, m2) \n\t\n\t// Display matrix elements.\n\tvar t = table.new(position.top_right, 5, 2, color.green)\n\ttable.cell(t, 0, 0, \"Matrix 1:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 1, \"⊗\")\n\ttable.cell(t, 2, 0, \"Matrix 2:\")\n\ttable.cell(t, 2, 1, str.tostring(m2))\n\ttable.cell(t, 3, 1, \"=\")\n\ttable.cell(t, 4, 0, \"Kronecker product:\")\n\ttable.cell(t, 4, 1, str.tostring(m3))",
          "methodName": "kron",
          "originalName": "matrix.kron",
          "methodSyntax": "matrix.kron(id2) → matrix<float|int>",
          "returnedType": [
            "matrix<float>",
            "matrix<int>"
          ],
          "returnedTypes": [
            "matrix<float>",
            "matrix<int>"
          ]
        },
        {
          "name": "matrix.pow",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function calculates the product of the matrix by itself `power` times.",
          "args": [
            {
              "name": "power",
              "desc": "The number of times the matrix will be multiplied by itself.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "matrix.pow(id, power) → matrix<float|int>",
          "returns": "The product of the `id` matrix by itself `power` times.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.set](#fun_matrix.set)",
            "[matrix.mult](#fun_matrix.mult)"
          ],
          "thisType": [
            "matrix<float>",
            "matrix<int>"
          ],
          "examples": "//@version=5\nindicator(\"`matrix.pow()` Example\")\n\n// Display using a table.\nif barstate.islastconfirmedhistory\n\t// Create a 2x2 matrix. \n\tvar m1 = matrix.new<int>(2, 2, 2)\n\t// Calculate the power of three of the matrix.\n\tvar m2 = matrix.pow(m1, 3)\n\t\n\t// Display matrix elements.\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Original Matrix:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 0, \"Matrix³:\")\n\ttable.cell(t, 1, 1, str.tostring(m2))",
          "methodName": "pow",
          "originalName": "matrix.pow",
          "methodSyntax": "matrix.pow(power) → matrix<float|int>",
          "returnedType": [
            "matrix<float>",
            "matrix<int>"
          ],
          "returnedTypes": [
            "matrix<float>",
            "matrix<int>"
          ]
        },
        {
          "name": "matrix.is_zero",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function determines if all elements of the matrix are zero.",
          "args": [],
          "syntax": "matrix.is_zero(id) → series bool",
          "returns": "Returns true if all elements of the `id` matrix are zero, false otherwise.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.get](#fun_matrix.get)",
            "[matrix.set](#fun_matrix.set)"
          ],
          "thisType": [
            "matrix<float>",
            "matrix<int>"
          ],
          "methodName": "is_zero",
          "originalName": "matrix.is_zero",
          "methodSyntax": "matrix.is_zero() → series bool",
          "returnedType": "bool",
          "returnedTypes": [
            "series bool",
            "simple bool",
            "input bool",
            "const bool"
          ]
        },
        {
          "name": "matrix.is_identity",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function determines if a matrix is an [identity matrix](https://en.wikipedia.org/wiki/Identity_matrix) (elements with ones on the [main diagonal](https://en.wikipedia.org/wiki/Main_diagonal) and zeros elsewhere).",
          "args": [],
          "syntax": "matrix.is_identity(id) → series bool",
          "remarks": "Returns false with non-square matrices.",
          "returns": "Returns true if `id` is an identity matrix, false otherwise.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.is_square](#fun_matrix.is_square)",
            "[matrix.is_diagonal](#fun_matrix.is_diagonal)"
          ],
          "thisType": [
            "matrix<float>",
            "matrix<int>"
          ],
          "methodName": "is_identity",
          "originalName": "matrix.is_identity",
          "methodSyntax": "matrix.is_identity() → series bool",
          "returnedType": "bool",
          "returnedTypes": [
            "series bool",
            "simple bool",
            "input bool",
            "const bool"
          ]
        },
        {
          "name": "matrix.is_binary",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function determines if the matrix is [binary](https://en.wikipedia.org/wiki/Logical_matrix) (when all elements of the matrix are 0 or 1).",
          "args": [],
          "syntax": "matrix.is_binary(id) → series bool",
          "returns": "Returns true if the `id` matrix is binary, false otherwise.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.get](#fun_matrix.get)",
            "[matrix.set](#fun_matrix.set)"
          ],
          "thisType": [
            "matrix<float>",
            "matrix<int>"
          ],
          "methodName": "is_binary",
          "originalName": "matrix.is_binary",
          "methodSyntax": "matrix.is_binary() → series bool",
          "returnedType": "bool",
          "returnedTypes": [
            "series bool",
            "simple bool",
            "input bool",
            "const bool"
          ]
        },
        {
          "name": "matrix.is_symmetric",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function determines if a [square matrix](https://en.wikipedia.org/wiki/Square_matrix) is [symmetric](https://en.wikipedia.org/wiki/Symmetric_matrix) (elements are symmetric with respect to the [main diagonal](https://en.wikipedia.org/wiki/Main_diagonal)).",
          "args": [],
          "syntax": "matrix.is_symmetric(id) → series bool",
          "remarks": "Returns false with non-square matrices.",
          "returns": "Returns true if the `id` matrix is symmetric, false otherwise.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.get](#fun_matrix.get)",
            "[matrix.set](#fun_matrix.set)",
            "[matrix.is_square](#fun_matrix.is_square)"
          ],
          "thisType": [
            "matrix<float>",
            "matrix<int>"
          ],
          "methodName": "is_symmetric",
          "originalName": "matrix.is_symmetric",
          "methodSyntax": "matrix.is_symmetric() → series bool",
          "returnedType": "bool",
          "returnedTypes": [
            "series bool",
            "simple bool",
            "input bool",
            "const bool"
          ]
        },
        {
          "name": "matrix.is_antisymmetric",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function determines if a matrix is [antisymmetric](https://en.wikipedia.org/wiki/Skew-symmetric_matrix) (its [transpose](https://en.wikipedia.org/wiki/Transpose) equals its negative).",
          "args": [],
          "syntax": "matrix.is_antisymmetric(id) → series bool",
          "remarks": "Returns false with non-square matrices.",
          "returns": "Returns true, if the `id` matrix is antisymmetric, false otherwise.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.get](#fun_matrix.get)",
            "[matrix.set](#fun_matrix.set)",
            "[matrix.is_square](#fun_matrix.is_square)"
          ],
          "thisType": [
            "matrix<float>",
            "matrix<int>"
          ],
          "methodName": "is_antisymmetric",
          "originalName": "matrix.is_antisymmetric",
          "methodSyntax": "matrix.is_antisymmetric() → series bool",
          "returnedType": "bool",
          "returnedTypes": [
            "series bool",
            "simple bool",
            "input bool",
            "const bool"
          ]
        },
        {
          "name": "matrix.is_diagonal",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function determines if the matrix is [diagonal](https://en.wikipedia.org/wiki/Diagonal_matrix) (all elements outside the main diagonal are zero).",
          "args": [],
          "syntax": "matrix.is_diagonal(id) → series bool",
          "remarks": "Returns false with non-square matrices.",
          "returns": "Returns true if the `id` matrix is diagonal, false otherwise.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.set](#fun_matrix.set)",
            "[matrix.is_square](#fun_matrix.is_square)",
            "[matrix.is_identity](#fun_matrix.is_identity)",
            "[matrix.is_antidiagonal](#fun_matrix.is_antidiagonal)"
          ],
          "thisType": [
            "matrix<float>",
            "matrix<int>"
          ],
          "methodName": "is_diagonal",
          "originalName": "matrix.is_diagonal",
          "methodSyntax": "matrix.is_diagonal() → series bool",
          "returnedType": "bool",
          "returnedTypes": [
            "series bool",
            "simple bool",
            "input bool",
            "const bool"
          ]
        },
        {
          "name": "matrix.is_antidiagonal",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function determines if the matrix is [anti-diagonal](https://en.wikipedia.org/wiki/Anti-diagonal_matrix) (all elements outside the secondary diagonal are zero).",
          "args": [],
          "syntax": "matrix.is_antidiagonal(id) → series bool",
          "remarks": "Returns false with non-square matrices.",
          "returns": "Returns true if the `id` matrix is ​​anti-diagonal, false otherwise.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.set](#fun_matrix.set)",
            "[matrix.is_square](#fun_matrix.is_square)",
            "[matrix.is_identity](#fun_matrix.is_identity)",
            "[matrix.is_diagonal](#fun_matrix.is_diagonal)"
          ],
          "thisType": [
            "matrix<float>",
            "matrix<int>"
          ],
          "methodName": "is_antidiagonal",
          "originalName": "matrix.is_antidiagonal",
          "methodSyntax": "matrix.is_antidiagonal() → series bool",
          "returnedType": "bool",
          "returnedTypes": [
            "series bool",
            "simple bool",
            "input bool",
            "const bool"
          ]
        },
        {
          "name": "matrix.is_triangular",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function determines if the matrix is [triangular](https://en.wikipedia.org/wiki/Triangular_matrix) (if all elements above or below the [main diagonal](https://en.wikipedia.org/wiki/Main_diagonal) are zero).",
          "args": [],
          "syntax": "matrix.is_triangular(id) → series bool",
          "remarks": "Returns false with non-square matrices.",
          "returns": "Returns true if the `id` matrix is triangular, false otherwise.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.set](#fun_matrix.set)",
            "[matrix.is_square](#fun_matrix.is_square)"
          ],
          "thisType": [
            "matrix<float>",
            "matrix<int>"
          ],
          "methodName": "is_triangular",
          "originalName": "matrix.is_triangular",
          "methodSyntax": "matrix.is_triangular() → series bool",
          "returnedType": "bool",
          "returnedTypes": [
            "series bool",
            "simple bool",
            "input bool",
            "const bool"
          ]
        },
        {
          "name": "matrix.is_stochastic",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function determines if the matrix is [stochastic](https://en.wikipedia.org/wiki/Stochastic_matrix).",
          "args": [],
          "syntax": "matrix.is_stochastic(id) → series bool",
          "returns": "Returns true if the `id` matrix is stochastic, false otherwise.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.set](#fun_matrix.set)"
          ],
          "thisType": [
            "matrix<float>",
            "matrix<int>"
          ],
          "methodName": "is_stochastic",
          "originalName": "matrix.is_stochastic",
          "methodSyntax": "matrix.is_stochastic() → series bool",
          "returnedType": "bool",
          "returnedTypes": [
            "series bool",
            "simple bool",
            "input bool",
            "const bool"
          ]
        },
        {
          "name": "matrix.is_square",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function determines if the matrix is [square](https://en.wikipedia.org/wiki/Square_matrix) (it has the same number of rows and columns).",
          "args": [],
          "syntax": "matrix.is_square(id) → series bool",
          "returns": "Returns true if the `id` matrix is square, false otherwise.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.get](#fun_matrix.get)",
            "[matrix.set](#fun_matrix.set)",
            "[matrix.columns](#fun_matrix.columns)",
            "[matrix.rows](#fun_matrix.rows)"
          ],
          "thisType": [
            "matrix"
          ],
          "methodName": "is_square",
          "originalName": "matrix.is_square",
          "methodSyntax": "matrix.is_square() → series bool",
          "returnedType": "bool",
          "returnedTypes": [
            "series bool",
            "simple bool",
            "input bool",
            "const bool"
          ]
        },
        {
          "name": "table.merge_cells",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "The function merges a sequence of cells in the table into one cell. The cells are merged in a rectangle shape where the start_column and start_row specify the top-left corner, and end_column and end_row specify the bottom-right corner.",
          "args": [
            {
              "name": "start_column",
              "desc": "The index of the column of the first cell to merge. Numbering starts at 0.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "start_row",
              "desc": "The index of the row of the first cell to merge. Numbering starts at 0.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "end_column",
              "desc": "The index of the column of the last cell to merge. Numbering starts at 0.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "end_row",
              "desc": "The index of the row of the last cell to merge. Numbering starts at 0.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "table.merge_cells(table_id, start_column, start_row, end_column, end_row) → void",
          "remarks": "This function will merge cells, even if their properties are not yet defined with [table.cell](#fun_table.cell).\nThe resulting merged cell inherits all of its values from the cell located at `start_column`:`start_row`, except width and height.  \nThe width and height of the resulting merged cell are based on the width/height of other cells in the neighboring columns/rows and cannot be set manually.\nTo modify the merged cell with any of the `table.cell_set_*` functions, target the cell at the `start_column`:`start_row` coordinates.\nAn attempt to merge a cell that has already been merged will result in an error.",
          "seeAlso": [
            "[table.delete](#fun_table.delete)",
            "[table.new](#fun_table.new)"
          ],
          "thisType": [
            "series table"
          ],
          "examples": "//@version=5\nindicator(\"table.merge_cells example\")\nSMA50  = ta.sma(close, 50)\nSMA100 = ta.sma(close, 100)\nSMA200 = ta.sma(close, 200)\nif barstate.islast\n\tmaTable = table.new(position.bottom_right, 3, 3, bgcolor = color.gray, border_width = 1, border_color = color.black)\n\t// Header\n\ttable.cell(maTable, 0, 0, text = \"SMA Table\")\n\ttable.merge_cells(maTable, 0, 0, 2, 0)\n\t// Cell Titles\n\ttable.cell(maTable, 0, 1, text = \"SMA 50\")\n\ttable.cell(maTable, 1, 1, text = \"SMA 100\")\n\ttable.cell(maTable, 2, 1, text = \"SMA 200\")\n\t// Values\n\ttable.cell(maTable, 0, 2, bgcolor = color.white, text = str.tostring(SMA50))\n\ttable.cell(maTable, 1, 2, bgcolor = color.white, text = str.tostring(SMA100))\n\ttable.cell(maTable, 2, 2, bgcolor = color.white, text = str.tostring(SMA200))",
          "methodName": "merge_cells",
          "originalName": "table.merge_cells",
          "methodSyntax": "table.merge_cells(start_column, start_row, end_column, end_row) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "chart.point.copy",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Creates a copy of a [chart.point](#op_chart.point) object with the specified `id`.",
          "args": [],
          "syntax": "chart.point.copy(id) → chart.point",
          "thisType": [
            "chart.point"
          ],
          "methodName": "copy",
          "originalName": "chart.point.copy",
          "methodSyntax": "chart.point.copy() → chart.point",
          "returnedType": "chart.point",
          "returnedTypes": [
            "chart.point"
          ]
        },
        {
          "name": "line.set_first_point",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Sets the first point of the `id` line to `point`.",
          "args": [
            {
              "name": "point",
              "desc": "A [chart.point](#op_chart.point) object.",
              "default": null,
              "required": true,
              "displayType": "chart.point",
              "allowedTypeIDs": [
                "chart.point"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "line.set_first_point(id, point) → void",
          "thisType": [
            "series line"
          ],
          "methodName": "set_first_point",
          "originalName": "line.set_first_point",
          "methodSyntax": "line.set_first_point(point) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "line.set_second_point",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Sets the second point of the `id` line to `point`.",
          "args": [
            {
              "name": "point",
              "desc": "A [chart.point](#op_chart.point) object.",
              "default": null,
              "required": true,
              "displayType": "chart.point",
              "allowedTypeIDs": [
                "chart.point"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "line.set_second_point(id, point) → void",
          "thisType": [
            "series line"
          ],
          "methodName": "set_second_point",
          "originalName": "line.set_second_point",
          "methodSyntax": "line.set_second_point(point) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "label.set_point",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Sets the location of the `id` label to `point`.",
          "args": [
            {
              "name": "point",
              "desc": "A [chart.point](#op_chart.point) object.",
              "default": null,
              "required": true,
              "displayType": "chart.point",
              "allowedTypeIDs": [
                "chart.point"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "label.set_point(id, point) → void",
          "thisType": [
            "series label"
          ],
          "methodName": "set_point",
          "originalName": "label.set_point",
          "methodSyntax": "label.set_point(point) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "box.set_top_left_point",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Sets the top-left corner location of the `id` box to `point`.",
          "args": [
            {
              "name": "point",
              "desc": "A [chart.point](#op_chart.point) object.",
              "default": null,
              "required": true,
              "displayType": "chart.point",
              "allowedTypeIDs": [
                "chart.point"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "box.set_top_left_point(id, point) → void",
          "thisType": [
            "series box"
          ],
          "methodName": "set_top_left_point",
          "originalName": "box.set_top_left_point",
          "methodSyntax": "box.set_top_left_point(point) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "box.set_bottom_right_point",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Sets the bottom-right corner location of the `id` box to `point`.",
          "args": [
            {
              "name": "point",
              "desc": "A [chart.point](#op_chart.point) object.",
              "default": null,
              "required": true,
              "displayType": "chart.point",
              "allowedTypeIDs": [
                "chart.point"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "box.set_bottom_right_point(id, point) → void",
          "thisType": [
            "series box"
          ],
          "methodName": "set_bottom_right_point",
          "originalName": "box.set_bottom_right_point",
          "methodSyntax": "box.set_bottom_right_point(point) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "map.contains",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Returns [true](#op_true) if the `key` was found in the `id` map, [false](#op_false) otherwise.",
          "args": [
            {
              "name": "key",
              "desc": "The key to search in the map.",
              "default": null,
              "required": true,
              "displayType": "map<type>",
              "allowedTypeIDs": [],
              "possibleValues": null
            }
          ],
          "syntax": "map.contains(id, key) → series bool",
          "seeAlso": [
            "[map.new<type,type>](#fun_map.new%3Ctype,type%3E)",
            "[map.put](#fun_map.put)",
            "[map.keys](#fun_map.keys)",
            "[map.values](#fun_map.values)",
            "[map.size](#fun_map.size)"
          ],
          "thisType": [
            "map"
          ],
          "examples": "//@version=5\nindicator(\"map.includes example\")\na = map.new<string, float>()\na.put(\"open\", open)\np = close\nif map.contains(a, \"open\")\n\tp := a.get(\"open\")\nplot(p)",
          "methodName": "contains",
          "originalName": "map.contains",
          "methodSyntax": "map.contains(key) → series bool",
          "returnedType": "bool",
          "returnedTypes": [
            "series bool",
            "simple bool",
            "input bool",
            "const bool"
          ]
        },
        {
          "name": "map.keys",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Returns an array of all the keys in the `id` map. The resulting array is a copy and any changes to it are not reflected in the original map.",
          "args": [],
          "syntax": "map.keys(id) → type[]",
          "remarks": "Maps maintain insertion order. The elements within the array returned by this function will also be in the insertion order.",
          "seeAlso": [
            "[map.new<type,type>](#fun_map.new%3Ctype,type%3E)",
            "[map.put](#fun_map.put)",
            "[map.get](#fun_map.get)",
            "[map.values](#fun_map.values)",
            "[map.size](#fun_map.size)"
          ],
          "thisType": [
            "map"
          ],
          "examples": "//@version=5\nindicator(\"map.keys example\")\na = map.new<string, float>()\na.put(\"open\", open)\na.put(\"high\", high)\na.put(\"low\", low)\na.put(\"close\", close)\nkeys = map.keys(a)\nohlc = 0.0\nfor key in keys\n\tohlc += a.get(key)\nplot(ohlc/4)",
          "methodName": "keys",
          "originalName": "map.keys",
          "methodSyntax": "map.keys() → type[]",
          "returnedType": "array",
          "returnedTypes": [
            "array"
          ]
        },
        {
          "name": "map.values",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Returns an array of all the values in the `id` map. The resulting array is a copy and any changes to it are not reflected in the original map.",
          "args": [],
          "syntax": "map.values(id) → type[]",
          "remarks": "Maps maintain insertion order. The elements within the array returned by this function will also be in the insertion order.",
          "seeAlso": [
            "[map.new<type,type>](#fun_map.new%3Ctype,type%3E)",
            "[map.put](#fun_map.put)",
            "[map.get](#fun_map.get)",
            "[map.keys](#fun_map.keys)",
            "[map.size](#fun_map.size)"
          ],
          "thisType": [
            "map"
          ],
          "examples": "//@version=5\nindicator(\"map.values example\")\na = map.new<string, float>()\na.put(\"open\", open)\na.put(\"high\", high)\na.put(\"low\", low)\na.put(\"close\", close)\nvalues = map.values(a)\nohlc = 0.0\nfor value in values\n\tohlc += value\nplot(ohlc/4)",
          "methodName": "values",
          "originalName": "map.values",
          "methodSyntax": "map.values() → type[]",
          "returnedType": "array",
          "returnedTypes": [
            "array"
          ]
        },
        {
          "name": "map.put",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Puts a new key-value pair into the `id` map.",
          "args": [
            {
              "name": "key",
              "desc": "The key to put into the map.",
              "default": null,
              "required": true,
              "displayType": "map<type>",
              "allowedTypeIDs": [],
              "possibleValues": null
            },
            {
              "name": "value",
              "desc": "The key value to put into the map.",
              "default": null,
              "required": true,
              "displayType": "map<type>",
              "allowedTypeIDs": [],
              "possibleValues": null
            }
          ],
          "syntax": "map.put(id, key, value) → series valueType",
          "remarks": "Maps maintain insertion order. Note that the order does not change when inserting a pair with a `key` that\\`s already in the map.  \nThe new pair replaces the existing pair with the `key` in such cases.",
          "returns": "The previous value associated with `key` if the key was already present in the map, or [na](#var_na) if the key is new.",
          "seeAlso": [
            "[map.new<type,type>](#fun_map.new%3Ctype,type%3E)",
            "[map.put_all](#fun_map.put_all)",
            "[map.keys](#fun_map.keys)",
            "[map.values](#fun_map.values)",
            "[map.remove](#fun_map.remove)"
          ],
          "thisType": [
            "map"
          ],
          "examples": "//@version=5\nindicator(\"map.put example\")\na = map.new<string, float>()\nmap.put(a, \"first\", 10)\nmap.put(a, \"second\", 15)\nprevFirst = map.put(a, \"first\", 20)\ncurrFirst = a.get(\"first\")\nplot(prevFirst)\nplot(currFirst)",
          "methodName": "put",
          "originalName": "map.put",
          "methodSyntax": "map.put(key, value) → series valueType",
          "returnedType": [],
          "returnedTypes": []
        },
        {
          "name": "map.put_all",
          "isMethod": true,
          "kind": "Built-in Method",
          "desc": "Puts all key-value pairs from the `id2` map into the `id` map.",
          "args": [
            {
              "name": "id2",
              "desc": "A map object to be appended.",
              "default": null,
              "required": true,
              "displayType": "map<type>",
              "allowedTypeIDs": "map",
              "possibleValues": null
            }
          ],
          "syntax": "map.put_all(id, id2) → void",
          "seeAlso": [
            "[map.new<type,type>](#fun_map.new%3Ctype,type%3E)",
            "[map.put](#fun_map.put)",
            "[map.keys](#fun_map.keys)",
            "[map.values](#fun_map.values)",
            "[map.remove](#fun_map.remove)"
          ],
          "thisType": [
            "map"
          ],
          "examples": "//@version=5\nindicator(\"map.put_all example\")\na = map.new<string, float>()\nb = map.new<string, float>()\na.put(\"first\", 10)\na.put(\"second\", 15)\nb.put(\"third\", 20)\nmap.put_all(a, b)\nplot(a.get(\"third\"))",
          "methodName": "put_all",
          "originalName": "map.put_all",
          "methodSyntax": "map.put_all(id2) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        }
      ],
      "title": "Built-in Method"
    }
  ],
  "controls": [
    {
      "docs": [
        {
          "name": "or",
          "kind": "Control Flow Keyword",
          "desc": "Logical OR. Applicable to boolean expressions.",
          "syntax": "<booleanExpression1> or <booleanExpression2>",
          "returns": "Boolean value, or series of boolean values."
        },
        {
          "name": "and",
          "kind": "Control Flow Keyword",
          "desc": "Logical AND. Applicable to boolean expressions.",
          "syntax": "<booleanExpression1> and <booleanExpression2>",
          "returns": "Boolean value, or series of boolean values."
        },
        {
          "name": "not",
          "kind": "Control Flow Keyword",
          "desc": "Logical negation (NOT). Applicable to boolean expressions.",
          "syntax": "not <booleanExpression>",
          "returns": "Boolean value, or series of boolean values."
        },
        {
          "name": "if",
          "kind": "Control Flow Keyword",
          "desc": "If statement defines what block of statements must be executed when conditions of the expression are satisfied.\nTo have access to and use the if statement, one should specify the version >= 2 of Pine Script™ language in the very first line of code, for example: //@version=5\nThe 4th version of Pine Script™ Language allows you to use “else if” syntax.\nGeneral code form:",
          "syntax": "[variable_declaration = ] if boolean_expression\n        …\n    [else if boolean_expression\n        … ]\n    [else\n        …\n        return_expression]",
          "detailedDesc": [
            {
              "desc": [
                "where",
                "**var_declarationX** — this variable gets the value of the if statement",
                "**condition** — if the condition is true, the logic from the block 'then' (var_decl_then0, var_decl_then1, etc.) is used.",
                "If the condition is false, the logic from the block 'else' (var_decl_else0, var_decl_else1, etc.) is used.",
                "**return_expression_then**, **return_expression_else** — the last expression from the block then or from the block else will return the final value of the statement. If declaration of the variable is in the end, its value will be the result.",
                "The type of returning value of the if statement depends on return_expression_then and return_expression_else type (their types must match: it is not possible to return an integer value from then, while you have a string value in else block)."
              ],
              "examples": "//@version=5\nindicator(\"if\")\n// This code compiles\nx = if close > open\n    close\nelse\n    open\n\n// This code doesn’t compile\n// y = if close > open\n//     close\n// else\n//     \"open\"\nplot(x)"
            },
            {
              "desc": "It is possible to omit the `else` block. In this case if the condition is false, an “empty” value (na, false, or “”) will be assigned to the var_declarationX variable:",
              "examples": "//@version=5\nindicator(\"if\")\nx = if close > open\n    close\n// If current close > current open, then x = close.\n// Otherwise the x = na.\nplot(x)"
            },
            {
              "desc": "It is possible to use either multiple “else if” blocks or none at all. The blocks “then”, “else if”, “else” are shifted by four spaces:",
              "examples": "//@version=5\nindicator(\"if\")\nx = if open > close\n    5\nelse if high > low\n    close\nelse\n    open\nplot(x)"
            },
            {
              "desc": "It is possible to ignore the resulting value of an `if` statement (“var_declarationX=“ can be omitted).  \nIt may be useful if you need the side effect of the expression, for example in strategy trading:",
              "examples": "//@version=5\nstrategy(\"if\")\nif (ta.crossover(high, low))\n    strategy.entry(\"BBandLE\", strategy.long, stop=low, oca_name=\"BollingerBands\", oca_type=strategy.oca.cancel, comment=\"BBandLE\")\nelse\n    strategy.cancel(id=\"BBandLE\")"
            },
            {
              "desc": "If statements can include each other:",
              "examples": "//@version=5\nindicator(\"if\")\nfloat x = na\nif close > open\n    if close > close[1]\n        x := close\n    else\n        x := close[1]\nelse\n    x := open\nplot(x)"
            }
          ]
        },
        {
          "name": "switch",
          "kind": "Control Flow Keyword",
          "desc": "The switch operator transfers control to one of the several statements, depending on the values of a condition and expressions.",
          "syntax": "[variable_declaration = ] switch expression\n    value1 => local_block\n    value2 => local_block\n    …\n    => default_local_block\n\n[variable_declaration = ] switch\n    boolean_expression1 => local_block\n    boolean_expression2 => local_block\n    …\n    => default_local_block",
          "remarks": "Only one of the `local_block` instances or the `default_local_block` can be executed.  \nThe `default_local_block` is introduced with the `=>` token alone and is only executed when none of the preceding blocks are executed.  \nIf the result of the `switch` statement is assigned to a variable and a `default_local_block` is not specified, the statement returns `na` if no `local_block` is executed.  \nWhen assigning the result of the `switch` statement to a variable, all `local_block` instances must return the same type of value.",
          "examples": "float variable_declaration = switch number\n    0 => local_block\n    1 => reassignment := value, reassignment2 := value2, float(na)\n    2 => function_call(value), returns_float_call(value2)\n    3 => line.set_color(color.blue), line.set_y1(_line, close), float(na)\n    => runtime.error(...)\n    // cannot return void, can add na if needed\n    // if the variable_delaration is used it will get the last value\n    // of the first true switch statement",
          "returns": "The value of the last expression in the local block of statements that is executed.",
          "seeAlso": [
            "[if](#kw_if)",
            "[?:](#op_?:)"
          ],
          "detailedDesc": [
            {
              "desc": "Switch with an expression:",
              "examples": "//@version=5\nindicator(\"Switch using an expression\")\n\nstring i_maType = input.string(\"EMA\", \"MA type\", options = [\"EMA\", \"SMA\", \"RMA\", \"WMA\"])\n\nfloat ma = switch i_maType\n\t\"EMA\" => ta.ema(close, 10)\n\t\"SMA\" => ta.sma(close, 10)\n\t\"RMA\" => ta.rma(close, 10)\n\t// Default used when the three first cases do not match.\n\t=> ta.wma(close, 10)\n\nplot(ma)"
            },
            {
              "desc": "Switch without an expression:",
              "examples": "//@version=5\nstrategy(\"Switch without an expression\", overlay = true)\n\nbool longCondition  = ta.crossover( ta.sma(close, 14), ta.sma(close, 28))\nbool shortCondition = ta.crossunder(ta.sma(close, 14), ta.sma(close, 28))\n\nswitch\n\tlongCondition  => strategy.entry(\"Long ID\", strategy.long)\n\tshortCondition => strategy.entry(\"Short ID\", strategy.short)"
            }
          ]
        },
        {
          "name": "for",
          "kind": "Control Flow Keyword",
          "desc": "The 'for' structure allows the repeated execution of a number of statements:",
          "syntax": "[var_declaration =] for counter = from_num to to_num [by step_num]\n    statements | continue | break\n    return_expression",
          "seeAlso": [
            "[for...in](#kw_for...in)",
            "[while](#kw_while)"
          ],
          "detailedDesc": [
            {
              "desc": " - **var_declaration** - An optional variable declaration that will be assigned the value of the loop\\`s return_expression.  \n - **counter** - A variable holding the value of the loop\\`s counter, which is incremented/decremented by 1 or by the step_num value on each iteration of the loop.  \n - **from_num** - The starting value of the counter. \"series int|float\" values/expressions are allowed.  \n - **to_num** - The end value of the counter.  \nWhen the counter becomes greater than to_num (or less than to_num in cases where from_num > to_num) the loop is broken. \"series int|float\" values/expressions are allowed, but they are evaluated only on the loop\\`s first iteration.  \n - **step_num** - The increment/decrement value of the counter.  \nIt is optional. The default value is +1 or -1, depending on which of from_num or to_num is the greatest.  \nWhen a value is used, the counter is also incremented/decremented depending on which of from_num or to_num is the greatest, so the +/- sign of step_num is optional.  \n - **statements | continue | break** - Any number of statements, or the 'continue' or 'break' keywords, indented by 4 spaces or a tab.  \n - **return_expression** - The loop\\`s return value which is assigned to the variable in var_declaration if one is present.  \nIf the loop exits because of a 'continue' or 'break' keyword, the loop\\`s return value is that of the last variable assigned a value before the loop\\`s exit.  \n - **continue** - A keyword that can only be used in loops.  \nIt causes the next iteration of the loop to be executed.  \n - **break** - A keyword that exits the loop.",
              "examples": "//@version=5\nindicator(\"for\")\n// Here, we count the quantity of bars in a given 'lookback' length which closed above the current bar\\`s close\nqtyOfHigherCloses(lookback) =>\n\tint result = 0\n\tfor i = 1 to lookback\n\t\tif close[i] > close\n\t\t\tresult += 1\n\tresult\nplot(qtyOfHigherCloses(14))"
            },
            {
              "desc": "",
              "examples": "//@version=5\nindicator(\"`for` loop with a step\")\n\na = array.from(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)\nsum = 0.0\n\nfor i = 0 to 9 by 5\n\t// Because the step is set to 5, we are adding only the first (0) and the sixth (5) value from the array `a`.\n\tsum += array.get(a, i)\n\nplot(sum)"
            }
          ]
        },
        {
          "name": "for...in",
          "kind": "Control Flow Keyword",
          "desc": "The `for...in` structure allows the repeated execution of a number of statements for each element in an array.  \nIt can be used with either one argument: `array_element`, or with two: `[index, array_element]`.  \nThe second form doesn't affect the functionality of the loop.  \nIt tracks the current iteration\\`s index in the tuple\\`s first variable.",
          "syntax": "[var_declaration =] for array_element in array_id\n    statements | continue | break\n    return_expression\n\n[var_declaration =] for [index, array_element] in array_id\n    statements | continue | break\n    return_expression",
          "seeAlso": [
            "[for](#kw_for)",
            "[while](#kw_while)",
            "[array.sum](#fun_array.sum)",
            "[array.min](#fun_array.min)",
            "[array.max](#fun_array.max)"
          ],
          "detailedDesc": [
            {
              "desc": "- **var_declaration** - An optional variable declaration that will be assigned the value of the loop\\`s `return_expression`.  \n - **index** - An optional variable that tracks the current iteration\\`s index.  \nIndexing starts at 0.  \nThe variable is immutable in the loop\\`s body.  \nWhen used, it must be included in a tuple also containing `array_element`.  \n - **array_element** - A variable containing each successive array element to be processed in the loop.  \nThe variable is immutable in the loop\\`s body.  \n - **array_id** - The ID of the array over which the loop is iterated.  \n - **statements | continue | break** - Any number of statements, or the 'continue' or 'break' keywords, indented by 4 spaces or a tab.  \n - **return_expression** - The loop\\`s return value assigned to the variable in `var_declaration`, if one is present.  \nIf the loop exits because of a 'continue' or 'break' keyword, the loop\\`s return value is that of the last variable assigned a value before the loop\\`s exit.  \n - **continue** - A keyword that can only be used in loops.  \nIt causes the next iteration of the loop to be executed.  \n - **break** - A keyword that exits the loop.\nIt is allowed to modify the array\\`s elements or its size inside the loop."
            },
            {
              "desc": "Here, we use the single-argument form of `for...in` to determine on each bar how many of the bar\\`s OHLC values are greater than the SMA of 'close' values:",
              "examples": "//@version=5\nindicator(\"for...in\")\n// Here we determine on each bar how many of the bar\\`s OHLC values are greater than the SMA of 'close' values\narray<float> ohlcValues = array.from(open, high, low, close)\nqtyGreaterThan(value, array) =>\n\tint result = 0\n\tfor currentElement in array\n\t\tif currentElement > value\n\t\t\tresult += 1\n\t\tresult\nplot(qtyGreaterThan(ta.sma(close, 20), ohlcValues))"
            },
            {
              "desc": "Here, we use the two-argument form of [for...in](#op_for...in) to set the values of our `isPos` array to `true` when their corresponding value in our `valuesArray` array is positive:",
              "examples": "//@version=5\nindicator(\"for...in\")\nvar valuesArray = array.from(4, -8, 11, 78, -16, 34, 7, 99, 0, 55)\nvar isPos = array.new_bool(10, false)\n\nfor [index, value] in valuesArray\n\tif value > 0\n\t\tarray.set(isPos, index, true)\n\nif barstate.islastconfirmedhistory\n\tlabel.new(bar_index, high, str.tostring(isPos))"
            },
            {
              "desc": "Iterate through matrix rows as arrays.",
              "examples": "//@version=5\nindicator(\"`for ... in` matrix Example\")\n\n// Create a 2x3 matrix with values `4`.\nmatrix1 = matrix.new<int>(2, 3, 4)\n\nsum = 0.0\n// Loop through every row of the matrix.\nfor rowArray in matrix1\n\t// Sum values of the every row \n\tsum += array.sum(rowArray)\n\nplot(sum)"
            }
          ]
        },
        {
          "name": "while",
          "kind": "Control Flow Keyword",
          "desc": "The `while` statement allows the conditional iteration of a local code block.",
          "syntax": "variable_declaration = while boolean_expression\n    …\n    continue\n    …\n    break\n    …\n    return_expression",
          "remarks": "The local code block after the initial `while` line must be indented with four spaces or a tab.  \nFor the `while` loop to terminate, the boolean expression following `while` must eventually become false, or a `break` must be executed.",
          "detailedDesc": [
            {
              "desc": [
                "where:",
                "**variable_declaration** - An optional variable declaration. The `return expression` can provide the initialization value for this variable.",
                "**boolean_expression** - when true, the local block of the `while` statement is executed. When false, execution of the script resumes after the `while` statement.",
                "**continue** - The `continue` keyword causes the loop to branch to its next iteration.",
                "**break** - The `break` keyword causes the loop to terminate. The script\\`s execution resumes after the `while` statement.",
                "**return_expression** - An optional line providing the `while` statement\\`s returning value."
              ],
              "examples": "//@version=5\nindicator(\"while\")\n// This is a simple example of calculating a factorial using a while loop.\nint i_n = input.int(10, \"Factorial Size\", minval=0)\nint counter   = i_n\nint factorial = 1\nwhile counter > 0\n\tfactorial := factorial * counter\n\tcounter   := counter - 1\n\nplot(factorial)"
            }
          ]
        },
        {
          "name": "var",
          "kind": "Control Flow Keyword",
          "desc": "**var** is the keyword used for assigning and one-time initializing of the variable.  \nNormally, a syntax of assignment of variables, which doesn’t include the keyword var, results in the value of the variable being overwritten with every update of the data.  \nContrary to that, when assigning variables with the keyword var, they can “keep the state” despite the data updating, only changing it when conditions within if-expressions are met.",
          "syntax": "var variable_name = expression",
          "detailedDesc": [
            {
              "desc": [
                "**variable_name** - any name of the user’s variable that’s allowed in Pine Script™ (can contain capital and lowercase Latin characters, numbers, and underscores (_), but can’t start with a number).",
                "**expression** - any arithmetic expression, just as with defining a regular variable. The expression will be calculated and assigned to a variable once."
              ],
              "examples": "//@version=5\nindicator(\"Var keyword example\")\nvar a = close\nvar b = 0.0\nvar c = 0.0\nvar green_bars_count = 0\nif close > open\n\tvar x = close\n\tb := x\n\tgreen_bars_count := green_bars_count + 1\n\tif green_bars_count >= 10\n\t\tvar y = close\n\t\tc := y\nplot(a)\nplot(b)\nplot(c)"
            },
            {
              "desc": [
                "The variable 'a' keeps the closing price of the first bar for each bar in the series.",
                "The variable 'b' keeps the closing price of the first \"green\" bar in the series.",
                "The variable 'c' keeps the closing price of the tenth \"green\" bar in the series."
              ]
            }
          ]
        },
        {
          "name": "varip",
          "kind": "Control Flow Keyword",
          "desc": "**varip** (var intrabar persist) is the keyword used for the assignment and one-time initialization of a variable or a field of a user-defined (type)(#op_type).  \nIt’s similar to the [var](#op_var) keyword, but variables and fields declared with [varip](#op_varip) retain their values between executions of the script on the same bar.",
          "syntax": "varip [<variable_type> ]<variable_name> = <expression>\n\n[export ]type <UDT_identifier>\n    varip <field_type> <field_name> [= <value>]",
          "remarks": "When using [varip](#op_varip) to declare variables in strategies that may execute more than once per historical chart bar, the values of such variables are preserved across successive iterations of the script on the same bar.\nThe effect of [varip](#op_varip) eliminates the [rollback](https://www.tradingview.com/pine-script-docs/en/v5/language/Execution_model.html#calculation-based-on-realtime-bars) of variables before each successive execution of a script on the same bar.",
          "detailedDesc": [
            {
              "desc": [
                "where:",
                "**variable_type** - An optional fundamental type ([int](#op_int), [float](#op_float), [bool](#op_bool), [color](#op_color), [string](#op_string)) or a user-defined type, or an array or matrix of one of those types. Special types are not compatible with this keyword.",
                "**variable_name** - A [valid identifier](https://www.tradingview.com/pine-script-docs/en/v5/language/Identifiers.html). The variable can also be an object created from a UDT.",
                "**expression** - Any arithmetic expression, just as when defining a regular variable. The expression will be calculated and assigned to the variable only once, on the first bar.",
                "**UDT_identifier, field_type, field_name, value** - Constructs related to user-defined types as described in the (type)(#op_type) section."
              ],
              "examples": "//@version=5\nindicator(\"varip\")\nvarip int v = -1\nv := v + 1\nplot(v)"
            },
            {
              "desc": "With [var](#op_var), `v` would equal the value of the [bar_index](#var_bar_index).  \nOn historical bars, where the script calculates only once per chart bar, the value of `v` is the same as with [var](#op_var).  \nHowever, on realtime bars, the script will evaluate the expression on each new chart update, producing a different result.",
              "examples": "//@version=5\nindicator(\"varip with types\")\ntype barData\n    int index = -1\n    varip int ticks = -1\n\nvar currBar = barData.new()\ncurrBar.index += 1\ncurrBar.ticks += 1\n\n// Will be equal to bar_index on all bars\nplot(currBar.index)\n// In real time, will increment per every tick on the chart\nplot(currBar.ticks)"
            },
            {
              "desc": "The same [+=](#op_+=) operation applied to both the `index` and `ticks` fields results in different real-time values because `ticks` increases on every chart update, while `index` only does so once per bar.  \nNote how the `currBar` object does not use the [varip](#op_varip) keyword.  \nThe `ticks` field of the object can increment on every tick, but the reference itself is defined once and then stays unchanged.  \nIf we were to declare `currBar` using [varip](#op_varip), the behavior of `index` would remain unchanged because while the reference to the type instance would persist between chart updates, the `index` field of the object would not."
            }
          ]
        },
        {
          "name": "import",
          "kind": "Control Flow Keyword",
          "desc": "Used to load an external [library](#fun_library) into a script and bind its functions to a namespace.  \nThe importing script can be an indicator, a strategy, or another library.  \nA library must be published (privately or publicly) before it can be imported.",
          "args": [
            {
              "name": "username",
              "desc": "User name of the library\\`s author.",
              "default": null,
              "required": true,
              "displayType": "literal string"
            },
            {
              "name": "libraryName",
              "desc": "Name of the imported library, which corresponds to the `title` argument used by the author in his library script.",
              "default": null,
              "required": true,
              "displayType": "literal string"
            },
            {
              "name": "libraryVersion",
              "desc": "Version number of the imported library.",
              "default": null,
              "required": true,
              "displayType": "literal int"
            },
            {
              "name": "alias",
              "desc": "Namespace used to refer to the library\\`s functions. Optional. The default is the libraryName string.",
              "default": "'libraryname'",
              "required": false,
              "displayType": "literal string"
            }
          ],
          "syntax": "import {username}/{libraryName}/{libraryVersion} as {alias}",
          "remarks": "Using an alias that replaces a built-in namespace such as math.* or strategy.* is allowed, but if the library contains function names that shadow Pine Script™\\`s built-in functions, the built-ins will become unavailable.  \nThe same version of a library can only be imported once.  \nAliases must be distinct for each imported library.  \nWhen calling library functions, casting their arguments to types other than their declared type is not allowed.",
          "seeAlso": [
            "[library](#fun_library)",
            "[export](#kw_export)"
          ],
          "examples": "//@version=5\nindicator(\"num_methods import\")\n// Import the first version of the username’s \"num_methods\" library and assign it to the \"m\" namespace\", \nimport username/num_methods/1 as m\n// Call the “sinh()” function from the imported library\ny = m.sinh(3.14)\n// Plot value returned by the \"sinh()\" function\", \nplot(y)"
        },
        {
          "name": "export",
          "kind": "Control Flow Keyword",
          "desc": "Used in libraries to prefix the declaration of functions or user-defined type definitions that will be available from other scripts importing the library.",
          "syntax": "export [method] <functionName>(<paramType> <paramName> [= <defaultValue>], …) =>\n    <functionBlock>\n\nexport <type> <typeName>\n    <propertyType> <propertyName> [= <value>]\n    …",
          "remarks": [
            "Each library must have at least one exported function or user-defined type (UDT).",
            "Exported functions cannot use variables from the global scope if they are arrays, mutable variables (reassigned with `:=`), or variables of 'input' form.",
            "Exported functions cannot use `request.*()` functions.",
            "Exported functions must explicitly declare each parameter\\`s type and all parameters must be used in the function\\`s body. By default, all arguments passed to exported functions are of the [series](#op_series) form, unless they are explicitly specified as [simple](#op_simple) in the function\\`s signature.",
            "The @description, @function, @param, @type, @field, and @returns compiler annotations are used to automatically generate the library\\`s description and release notes, and in the Pine Script™ Editor\\`s tooltips."
          ],
          "seeAlso": [
            "[library](#fun_library)",
            "[import](#kw_import)",
            "[simple](#type_simple)",
            "[series](#type_series)",
            "(type)(#op_type)"
          ],
          "examples": "//@version=5\n//@description Library of debugging functions.\nlibrary(\"Debugging_library\", overlay = true)\n//@function Displays a string as a table cell for debugging purposes.\n//@param txt String to display.\n//@returns Void.\nexport print(string txt) → \n\tvar table t = table.new(position.middle_right, 1, 1)\n\ttable.cell(t, 0, 0, txt, bgcolor = color.yellow)\n// Using the function from inside the library to show an example on the published chart.\n// This has no impact on scripts using the library.\nprint(\"Library Test\")"
        },
        {
          "name": "true",
          "kind": "Boolean Literal",
          "desc": "Literal representing one of the values a [bool](#op_bool) variable can hold, or an expression can evaluate to when it uses comparison or logical operators.",
          "syntax": "bool true",
          "remarks": "See the User Manual for [comparison operators](https://www.tradingview.com/pine-script-docs/en/v5/language/Operators.html#comparison-operators) and [logical operators](https://www.tradingview.com/pine-script-docs/en/v5/language/Operators.html#logical-operators).",
          "seeAlso": [
            "[bool](#type_bool)"
          ]
        },
        {
          "name": "false",
          "kind": "Boolean Literal",
          "desc": "Literal representing a [bool](#op_bool) value, and result of a comparison operation.",
          "syntax": "bool false",
          "remarks": "See the User Manual for [comparison operators](https://www.tradingview.com/pine-script-docs/en/v5/language/Operators.html#comparison-operators) and [logical operators](https://www.tradingview.com/pine-script-docs/en/v5/language/Operators.html#logical-operators).",
          "seeAlso": [
            "[bool](#type_bool)"
          ]
        },
        {
          "name": "type",
          "kind": "Control Flow Keyword",
          "desc": "This keyword allows the declaration of user-defined types (UDT) from which scripts can instantiate objects. UDTs are composite types that contain an arbitrary number of fields of any built-in or user-defined type, including the defined UDT itself. The syntax to define a UDT is:",
          "syntax": "[export ]type <UDT_identifier>\n    [varip ]<field_type> <field_name> [= <value>]\n    …",
          "detailedDesc": [
            {
              "desc": "Once a UDT is defined, scripts can instantiate objects from it with the `UDT_identifier.new()` construct.  \nWhen creating a new type instance, the fields of the resulting object will initialize with the default values from the UDT\\`s definition.  \nAny type fields without specified defaults will initialize as [na](#var_na).  \nAlternatively, users can pass initial values as arguments in the `*.new()` method to override the type\\`s defaults.  \nFor example, `newFooObject = foo.new(x = true)` assigns a new `foo` object to the `newFooObject` variable with its `x` field initialized using a value of [true](#op_true).\nField declarations can include the [varip](#op_varip) keyword, in which case the field values persist between successive script iterations on the same bar.\nFor more information see the User Manual\\`s sections on [defining UDTs](https://www.tradingview.com/pine-script-docs/en/v5/language/Type_system.html#user-defined-types) and [using objects](https://www.tradingview.com/pine-script-docs/en/v5/language/Objects.html).\nLibraries can export UDTs.  \nSee the[Libraries](https://www.tradingview.com/pine-script-docs/en/v5/concepts/Libraries.html#user-defined-types-and-objects) page of our User Manual to learn more.",
              "examples": "//@version=5\nindicator(\"Multi Time Period Chart\", overlay = true)\n\ntimeframeInput = input.timeframe(\"1D\")\n\ntype bar\n    float o = open\n    float h = high\n    float l = low\n    float c = close\n    int   t = time\n\ndrawBox(bar b, right) =>\n    bar s = bar.new()\n    color boxColor = b.c >= b.o ? color.green : color.red\n    box.new(b.t, b.h, right, b.l, boxColor, xloc = xloc.bar_time, bgcolor = color.new(boxColor, 90))\n\nupdateBox(box boxId, bar b) =>\n    color boxColor = b.c >= b.o ? color.green : color.red\n    box.set_border_color(boxId, boxColor)\n    box.set_bgcolor(boxId, color.new(boxColor, 90))\n    box.set_top(boxId, b.h)\n    box.set_bottom(boxId, b.l)\n    box.set_right(boxId, time)\n\nsecBar = request.security(syminfo.tickerid, timeframeInput, bar.new())\n\nif not na(secBar)\n    // To avoid a runtime error, only process data when an object exists.\n    if not barstate.islast\n        if timeframe.change(timeframeInput)\n            // On historical bars, draw a new box in the past when the HTF closes.\n            drawBox(secBar, time[1])\n    else\n        var box lastBox = na\n        if na(lastBox) or timeframe.change(timeframeInput)\n            // On the last bar, only draw a new current box the first time we get there or when HTF changes.\n            lastBox := drawBox(secBar, time)\n        else\n            // On other chart updates, use setters to modify the current box.\n            updateBox(lastBox, secBar)"
            }
          ]
        },
        {
          "name": "method",
          "kind": "Control Flow Keyword",
          "desc": "This keyword is used to prefix a function declaration, indicating it can then be invoked using dot notation by appending its name to a variable of the type of its first parameter and omitting that first parameter. Alternatively, functions declared as methods can also be invoked like normal user-defined functions. In that case, an argument must be supplied for its first parameter. The first parameter of a method declaration must be explicitly typified.",
          "syntax": "[export] method <functionName>(<paramType> <paramName> [= <defaultValue>], …) =>\n    <functionBlock>",
          "examples": "//@version=5\nindicator(\"\")\n\nvar prices = array.new<float>()\n\n//@function Pushes a new value into the array and removes the first one if the resulting array is greater than `maxSize`. Can be used as a method.\nmethod maintainArray(array<float> id, maxSize, value) =>\n    id.push(value)\n    if id.size() > maxSize\n        id.shift()\n\nprices.maintainArray(50, close)\n// The method can also be called like a function, without using dot notation.\n// In this case an argument must be supplied for its first parameter.\n// maintainArray(prices, 50, close)\n\n// This calls the `array.avg()` built-in using dot notation with the `prices` array.\n// It is possible because built-in functions belonging to some namespaces that are a special Pine type\n// can be invoked with method notation when the function\\`s first parameter is an ID of that type.\n// Those namespaces are: `array`, `matrix`, `line`, `linefill`, `label`, `box`, and `table`.\nplot(prices.avg())"
        },
        {
          "name": "continue",
          "kind": "Control Flow Keyword",
          "desc": "The 'continue' operator, when used in a for loop, will skip the rest of the code and move to the next iteration of the loop.",
          "syntax": "continue",
          "examples": "//@version=5\nindicator('Continue operator example')\nvar sum = 0\nfor i = 1 to 10\n    if i % 2 == 0\n        continue\n    sum := sum + i\nplot(sum)"
        },
        {
          "name": "break",
          "kind": "Control Flow Keyword",
          "desc": "The 'break' operator, when used in a for loop, will break out of the loop and not continue to the next iteration.",
          "syntax": "break",
          "examples": "//@version=5\nindicator('Break operator example')\nvar sum = 0\nfor i = 1 to 10\n    if sum > 25\n        break\n    sum := sum + i\nplot(sum)"
        }
      ],
      "title": "Control-Flow Keyword"
    }
  ],
  "variables": [
    {
      "docs": [
        {
          "name": "session.isfirstbar",
          "kind": "Built-in Variable",
          "desc": "Returns [true](#op_true) if the current bar is the first bar of the day\\`s session, `false` otherwise.  \nIf extended session information is used, only returns [true](#op_true) on the first bar of the pre-market bars.",
          "type": "bool",
          "displayType": "series bool"
        },
        {
          "name": "session.islastbar",
          "kind": "Built-in Variable",
          "desc": "Returns [true](#op_true) if the current bar is the last bar of the day\\`s session, `false` otherwise.  \nIf extended session information is used, only returns [true](#op_true) on the last bar of the post-market bars.",
          "type": "bool",
          "remarks": "This variable is not guaranteed to return [true](#op_true) once in every session because the last bar of the session might not exist if no trades occur during what should be the session\\`s last bar.\nThis variable is not guaranteed to work as expected on non-standard chart types, e.g., Renko.",
          "displayType": "series bool"
        },
        {
          "name": "session.isfirstbar_regular",
          "kind": "Built-in Variable",
          "desc": "Returns [true](#op_true) on the first regular session bar of the day, `false` otherwise.  \nThe result is the same whether extended session information is used or not.",
          "type": "bool",
          "displayType": "series bool"
        },
        {
          "name": "session.islastbar_regular",
          "kind": "Built-in Variable",
          "desc": "Returns [true](#op_true) on the last regular session bar of the day, `false` otherwise.  \nThe result is the same whether extended session information is used or not.",
          "type": "bool",
          "remarks": "This variable is not guaranteed to return [true](#op_true) once in every session because the last bar of the session might not exist if no trades occur during what should be the session\\`s last bar.\nThis variable is not guaranteed to work as expected on non-standard chart types, e.g., Renko.",
          "displayType": "series bool"
        },
        {
          "name": "bar_index",
          "kind": "Built-in Variable",
          "desc": "Current bar index. Numbering is zero-based, index of the first bar is 0.",
          "type": "int",
          "remarks": "Note that **bar_index** has replaced **n** variable in version 4.\nNote that bar indexing starts from 0 on the first historical bar.\nPlease note that using this variable/function can cause [indicator repainting](https://www.tradingview.com/pine-script-docs/en/v5/concepts/Repainting.html).",
          "seeAlso": [
            "[last_bar_index](#var_last_bar_index)",
            "[barstate.isfirst](#var_barstate.isfirst)",
            "[barstate.islast](#var_barstate.islast)",
            "[barstate.isrealtime](#var_barstate.isrealtime)"
          ],
          "examples": "//@version=5\nindicator(\"bar_index\")\nplot(bar_index)\nplot(bar_index > 5000 ? close : 0)",
          "displayType": "series int"
        },
        {
          "name": "last_bar_index",
          "kind": "Built-in Variable",
          "desc": "Bar index of the last chart bar. Bar indices begin at zero on the first bar.",
          "type": "int",
          "remarks": "Please note that using this variable can cause [indicator repainting](https://www.tradingview.com/pine-script-docs/en/v5/concepts/Repainting.html).",
          "returns": "Last historical bar index for closed markets, or the real-time bar index for open markets.",
          "seeAlso": [
            "[bar_index](#var_bar_index)",
            "[last_bar_time](#var_last_bar_time)",
            "[barstate.ishistory](#var_barstate.ishistory)",
            "[barstate.isrealtime](#var_barstate.isrealtime)"
          ],
          "examples": "//@version=5\nstrategy(\"Mark Last X Bars For Backtesting\", overlay = true, calc_on_every_tick = true)\nlastBarsFilterInput = input.int(100, \"Bars Count:\")\n// Here, we store the 'last_bar_index' value that is known from the beginning of the script\\`s calculation.\n// The 'last_bar_index' will change when new real-time bars appear, so we declare 'lastbar' with the 'var' keyword.\nvar lastbar = last_bar_index\n// Check if the current bar_index is 'lastBarsFilterInput' removed from the last bar on the chart, or the chart is traded in real-time.\nallowedToTrade = (lastbar - bar_index <= lastBarsFilterInput) or barstate.isrealtime\nbgcolor(allowedToTrade ? color.new(color.green, 80) : na)",
          "displayType": "series int"
        },
        {
          "name": "last_bar_time",
          "kind": "Built-in Variable",
          "desc": "Time in UNIX format of the last chart bar. It is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970.",
          "type": "int",
          "remarks": "Please note that using this variable/function can cause [indicator repainting](https://www.tradingview.com/pine-script-docs/en/v5/concepts/Repainting.html).\nNote that this variable returns the timestamp based on the time of the bar\\`s open.",
          "seeAlso": [
            "[time](#var_time)",
            "[timenow](#var_timenow)",
            "[timestamp](#fun_timestamp)",
            "[last_bar_index](#var_last_bar_index)"
          ],
          "displayType": "series int"
        },
        {
          "name": "na",
          "kind": "Built-in Variable",
          "desc": "A keyword signifying \"not available\", indicating that a variable has no assigned value.",
          "type": "null",
          "remarks": "Do not use this variable with [comparison operators](https://www.tradingview.com/pine-script-docs/en/v5/language/Operators.html#comparison-operators) to test values for `na`, as it might lead to unexpected behavior.  \nInstead, use the [na](#fun_na) function.  \nNote that `na` can be used to initialize variables when the initialization statement also specifies the variable\\`s type.",
          "seeAlso": [
            "[na](#fun_na)",
            "[nz](#fun_nz)",
            "[fixnan](#fun_fixnan)"
          ],
          "examples": "//@version=5\nindicator(\"na\")\n// CORRECT\n// Plot no value when on bars zero to nine. Plot `close` on other bars.\nplot(bar_index < 10 ? na : close)\n// CORRECT ALTERNATIVE\n// Initialize `a` to `na`. Reassign `close` to `a` on bars 10 and later.\nfloat a = na\nif bar_index >= 10\n\ta := close\nplot(a)\n\n// INCORRECT\n// Trying to test the preceding bar\\`s `close` for `na`.\n// Will not work correctly on bar zero, when `close[1]` is `na`.\nplot(close[1] == na ? close : close[1])\n// CORRECT\n// Use the `na()` function to test for `na`.\nplot(na(close[1]) ? close : close[1])\n// CORRECT ALTERNATIVE\n// `nz()` tests `close[1]` for `na`. It returns `close[1]` if it is not `na`, and `close` if it is.\nplot(nz(close[1], close))",
          "displayType": "null"
        },
        {
          "name": "volume",
          "kind": "Built-in Variable",
          "desc": "Current bar volume.",
          "type": "float",
          "remarks": "Previous values may be accessed with square brackets operator [], e.g. volume[1], volume[2].",
          "seeAlso": [
            "[open](#var_open)",
            "[high](#var_high)",
            "[low](#var_low)",
            "[close](#var_close)",
            "[time](#fun_time)",
            "[hl2](#var_hl2)",
            "[hlc3](#var_hlc3)",
            "[hlcc4](#var_hlcc4)",
            "[ohlc4](#var_ohlc4)"
          ],
          "displayType": "series float"
        },
        {
          "name": "open",
          "kind": "Built-in Variable",
          "desc": "Current open price.",
          "type": "float",
          "remarks": "Previous values may be accessed with square brackets operator [], e.g. open[1], open[2].",
          "seeAlso": [
            "[high](#var_high)",
            "[low](#var_low)",
            "[close](#var_close)",
            "[volume](#var_volume)",
            "[time](#fun_time)",
            "[hl2](#var_hl2)",
            "[hlc3](#var_hlc3)",
            "[hlcc4](#var_hlcc4)",
            "[ohlc4](#var_ohlc4)"
          ],
          "displayType": "series float"
        },
        {
          "name": "high",
          "kind": "Built-in Variable",
          "desc": "Current high price.",
          "type": "float",
          "remarks": "Previous values may be accessed with square brackets operator [], e.g. high[1], high[2].",
          "seeAlso": [
            "[open](#var_open)",
            "[low](#var_low)",
            "[close](#var_close)",
            "[volume](#var_volume)",
            "[time](#fun_time)",
            "[hl2](#var_hl2)",
            "[hlc3](#var_hlc3)",
            "[hlcc4](#var_hlcc4)",
            "[ohlc4](#var_ohlc4)"
          ],
          "displayType": "series float"
        },
        {
          "name": "low",
          "kind": "Built-in Variable",
          "desc": "Current low price.",
          "type": "float",
          "remarks": "Previous values may be accessed with square brackets operator [], e.g. low[1], low[2].",
          "seeAlso": [
            "[open](#var_open)",
            "[high](#var_high)",
            "[close](#var_close)",
            "[volume](#var_volume)",
            "[time](#fun_time)",
            "[hl2](#var_hl2)",
            "[hlc3](#var_hlc3)",
            "[hlcc4](#var_hlcc4)",
            "[ohlc4](#var_ohlc4)"
          ],
          "displayType": "series float"
        },
        {
          "name": "close",
          "kind": "Built-in Variable",
          "desc": "Close price of the current bar when it has closed, or last traded price of a yet incomplete, realtime bar.",
          "type": "float",
          "remarks": "Previous values may be accessed with square brackets operator [], e.g. close[1], close[2].",
          "seeAlso": [
            "[open](#var_open)",
            "[high](#var_high)",
            "[low](#var_low)",
            "[volume](#var_volume)",
            "[time](#fun_time)",
            "[hl2](#var_hl2)",
            "[hlc3](#var_hlc3)",
            "[hlcc4](#var_hlcc4)",
            "[ohlc4](#var_ohlc4)"
          ],
          "displayType": "series float"
        },
        {
          "name": "hl2",
          "kind": "Built-in Variable",
          "desc": "Is a shortcut for (high + low)/2",
          "type": "float",
          "seeAlso": [
            "[open](#var_open)",
            "[high](#var_high)",
            "[low](#var_low)",
            "[close](#var_close)",
            "[volume](#var_volume)",
            "[time](#fun_time)",
            "[hlc3](#var_hlc3)",
            "[hlcc4](#var_hlcc4)",
            "[ohlc4](#var_ohlc4)"
          ],
          "displayType": "series float"
        },
        {
          "name": "hlc3",
          "kind": "Built-in Variable",
          "desc": "Is a shortcut for (high + low + close)/3",
          "type": "float",
          "seeAlso": [
            "[open](#var_open)",
            "[high](#var_high)",
            "[low](#var_low)",
            "[close](#var_close)",
            "[volume](#var_volume)",
            "[time](#fun_time)",
            "[hl2](#var_hl2)",
            "[hlcc4](#var_hlcc4)",
            "[ohlc4](#var_ohlc4)"
          ],
          "displayType": "series float"
        },
        {
          "name": "hlcc4",
          "kind": "Built-in Variable",
          "desc": "Is a shortcut for (high + low + close + close)/4",
          "type": "float",
          "seeAlso": [
            "[open](#var_open)",
            "[high](#var_high)",
            "[low](#var_low)",
            "[close](#var_close)",
            "[volume](#var_volume)",
            "[time](#fun_time)",
            "[hl2](#var_hl2)",
            "[hlc3](#var_hlc3)",
            "[ohlc4](#var_ohlc4)"
          ],
          "displayType": "series float"
        },
        {
          "name": "ohlc4",
          "kind": "Built-in Variable",
          "desc": "Is a shortcut for (open + high + low + close)/4",
          "type": "float",
          "seeAlso": [
            "[open](#var_open)",
            "[high](#var_high)",
            "[low](#var_low)",
            "[close](#var_close)",
            "[volume](#var_volume)",
            "[time](#fun_time)",
            "[hl2](#var_hl2)",
            "[hlc3](#var_hlc3)",
            "[hlcc4](#var_hlcc4)"
          ],
          "displayType": "series float"
        },
        {
          "name": "ta.vwap",
          "kind": "Built-in Variable",
          "desc": "Volume Weighted Average Price. It uses [hlc3](#var_hlc3) as its source series.",
          "type": "float",
          "seeAlso": [
            "[ta.vwap](#fun_ta.vwap) (function)"
          ],
          "displayType": "series float"
        },
        {
          "name": "ta.accdist",
          "kind": "Built-in Variable",
          "desc": [
            "Accumulation/distribution index."
          ],
          "type": "float",
          "displayType": "series float"
        },
        {
          "name": "ta.tr",
          "kind": "Built-in Variable",
          "desc": "True range. Same as tr(false). It is max(high - low, abs(high - close[1]), abs(low - close[1]))",
          "type": "float",
          "seeAlso": [
            "[ta.tr](#fun_ta.tr)",
            "[ta.atr](#fun_ta.atr)"
          ],
          "displayType": "series float"
        },
        {
          "name": "ta.iii",
          "kind": "Built-in Variable",
          "desc": "Intraday Intensity Index.",
          "type": "float",
          "examples": "//@version=5\nindicator(\"Intraday Intensity Index\")\nplot(ta.iii, color=color.yellow)\n\n// the same on pine\nf_iii() =>\n    (2 * close - high - low) / ((high - low) * volume)\n\nplot(f_iii())",
          "displayType": "series float"
        },
        {
          "name": "ta.wvad",
          "kind": "Built-in Variable",
          "desc": "Williams Variable Accumulation/Distribution.",
          "type": "float",
          "examples": "//@version=5\nindicator(\"Williams Variable Accumulation/Distribution\")\nplot(ta.wvad, color=color.yellow)\n\n// the same on pine\nf_wvad() =>\n    (close - open) / (high - low) * volume\n\nplot(f_wvad())",
          "displayType": "series float"
        },
        {
          "name": "ta.wad",
          "kind": "Built-in Variable",
          "desc": "Williams Accumulation/Distribution.",
          "type": "float",
          "examples": "//@version=5\nindicator(\"Williams Accumulation/Distribution\")\nplot(ta.wad, color=color.yellow)\n\n// the same on pine\nf_wad() =>\n    trueHigh = math.max(high, close[1])\n    trueLow = math.min(low, close[1])\n    mom = ta.change(close)\n    gain = (mom > 0) ? close - trueLow : (mom < 0) ? close - trueHigh : 0\n    ta.cum(gain)\n\nplot(f_wad())",
          "displayType": "series float"
        },
        {
          "name": "ta.obv",
          "kind": "Built-in Variable",
          "desc": "On Balance Volume.",
          "type": "float",
          "examples": "//@version=5\nindicator(\"On Balance Volume\")\nplot(ta.obv, color=color.yellow)\n\n// the same on pine\nf_obv() =>\n    ta.cum(math.sign(ta.change(close)) * volume)\n\nplot(f_obv())",
          "displayType": "series float"
        },
        {
          "name": "ta.pvt",
          "kind": "Built-in Variable",
          "desc": "Price-Volume Trend.",
          "type": "float",
          "examples": "//@version=5\nindicator(\"Price-Volume Trend\")\nplot(ta.pvt, color=color.yellow)\n\n// the same on pine\nf_pvt() =>\n    ta.cum((ta.change(close) / close[1]) * volume)\n\nplot(f_pvt())",
          "displayType": "series float"
        },
        {
          "name": "ta.nvi",
          "kind": "Built-in Variable",
          "desc": "Negative Volume Index.",
          "type": "float",
          "examples": "//@version=5\nindicator(\"Negative Volume Index\")\n\nplot(ta.nvi, color=color.yellow)\n\n// the same on pine\nf_nvi() =>\n    float ta_nvi = 1.0\n    float prevNvi = (nz(ta_nvi[1], 0.0) == 0.0)  ? 1.0: ta_nvi[1]\n    if nz(close, 0.0) == 0.0 or nz(close[1], 0.0) == 0.0\n        ta_nvi := prevNvi\n    else\n        ta_nvi := (volume < nz(volume[1], 0.0)) ? prevNvi + ((close - close[1]) / close[1]) * prevNvi : prevNvi\n    result = ta_nvi\n\nplot(f_nvi())",
          "displayType": "series float"
        },
        {
          "name": "ta.pvi",
          "kind": "Built-in Variable",
          "desc": "Positive Volume Index.",
          "type": "float",
          "examples": "//@version=5\nindicator(\"Positive Volume Index\")\n\nplot(ta.pvi, color=color.yellow)\n\n// the same on pine\nf_pvi() =>\n    float ta_pvi = 1.0\n    float prevPvi = (nz(ta_pvi[1], 0.0) == 0.0)  ? 1.0: ta_pvi[1]\n    if nz(close, 0.0) == 0.0 or nz(close[1], 0.0) == 0.0\n        ta_pvi := prevPvi\n    else\n        ta_pvi := (volume > nz(volume[1], 0.0)) ? prevPvi + ((close - close[1]) / close[1]) * prevPvi : prevPvi\n    result = ta_pvi\n\nplot(f_pvi())",
          "displayType": "series float"
        },
        {
          "name": "syminfo.ticker",
          "kind": "Built-in Variable",
          "desc": "Symbol name without exchange prefix, e.g. 'MSFT'.",
          "type": "string",
          "seeAlso": [
            "[syminfo.tickerid](#var_syminfo.tickerid)",
            "[timeframe.period](#var_timeframe.period)",
            "[timeframe.multiplier](#var_timeframe.multiplier)",
            "[syminfo.root](#var_syminfo.root)"
          ],
          "displayType": "simple string"
        },
        {
          "name": "syminfo.tickerid",
          "kind": "Built-in Variable",
          "desc": "Returns the full form of the ticker ID representing a symbol, for use as an argument in functions with a `ticker` or `symbol` parameter.  \nIt always includes the prefix (exchange) and ticker separated by a colon (\"NASDAQ:AAPL\"), but it can also include other symbol data such as dividend adjustment, chart type, currency conversion, etc.",
          "type": "string",
          "remarks": "Because the value of this variable does not always use a simple \"prefix:ticker\" format, it is a poor candidate for use in boolean comparisons or string manipulation functions.  \nIn those contexts, run the variable\\`s result through [ticker.standard](#fun_ticker.standard) to purify it.  \nThis will remove any extraneous information and return a ticker ID consistently formatted using the \"prefix:ticker\" structure.",
          "seeAlso": [
            "[ticker.new](#fun_ticker.new) (function)",
            "[syminfo.ticker](#var_syminfo.ticker)",
            "[timeframe.period](#var_timeframe.period)",
            "[timeframe.multiplier](#var_timeframe.multiplier)",
            "[syminfo.root](#var_syminfo.root)"
          ],
          "displayType": "simple string"
        },
        {
          "name": "syminfo.minmove",
          "kind": "Built-in Variable",
          "desc": "Returns a whole number used to calculate the smallest increment between a symbol\\`s price movements ([syminfo.mintick](#var_syminfo.mintick)).  \nIt is the numerator in the [syminfo.mintick](#var_syminfo.mintick) formula: '[syminfo.minmove](#var_syminfo.minmove) / [syminfo.pricescale](#var_syminfo.pricescale) = [syminfo.mintick](#var_syminfo.mintick)'.",
          "type": "int",
          "seeAlso": [
            "[ticker.new](#fun_ticker.new) (function)",
            "[syminfo.ticker](#var_syminfo.ticker)",
            "[timeframe.period](#var_timeframe.period)",
            "[timeframe.multiplier](#var_timeframe.multiplier)",
            "[syminfo.root](#var_syminfo.root)"
          ],
          "displayType": "simple int"
        },
        {
          "name": "syminfo.pricescale",
          "kind": "Built-in Variable",
          "desc": "Returns a whole number used to calculate the smallest increment between a symbol\\`s price movements ([syminfo.mintick](#var_syminfo.mintick)).  \nIt is the denominator in the [syminfo.mintick](#var_syminfo.mintick) formula: '[syminfo.minmove](#var_syminfo.minmove) / [syminfo.pricescale](#var_syminfo.pricescale) = [syminfo.mintick](#var_syminfo.mintick)'.",
          "type": "int",
          "seeAlso": [
            "[ticker.new](#fun_ticker.new) (function)",
            "[syminfo.ticker](#var_syminfo.ticker)",
            "[timeframe.period](#var_timeframe.period)",
            "[timeframe.multiplier](#var_timeframe.multiplier)",
            "[syminfo.root](#var_syminfo.root)"
          ],
          "displayType": "simple int"
        },
        {
          "name": "timeframe.period",
          "kind": "Built-in Variable",
          "desc": [
            "A string representation of the chart\\`s timeframe. The returned string\\`s format is \"[<quantity>][<units>]\", where <quantity> and <units> are in some cases absent. <quantity> is the number of units, but it is absent if that number is 1. <unit> is \"S\" for seconds, \"D\" for days, \"W\" for weeks, \"M\" for months, but it is absent for minutes. No <unit> exists for hours.",
            "The variable will return: \"10S\" for 10 seconds, \"60\" for 60 minutes, \"D\" for one day, \"2W\" for two weeks, \"3M\" for one quarter.",
            "Can be used as an argument with any function containing a `timeframe` parameter."
          ],
          "type": "string",
          "seeAlso": [
            "[syminfo.ticker](#var_syminfo.ticker)",
            "[syminfo.tickerid](#var_syminfo.tickerid)",
            "[timeframe.multiplier](#var_timeframe.multiplier)"
          ],
          "displayType": "simple string"
        },
        {
          "name": "syminfo.root",
          "kind": "Built-in Variable",
          "desc": "Root for derivatives like futures contract. For other symbols returns the same value as [syminfo.ticker](#var_syminfo.ticker).",
          "type": "string",
          "seeAlso": [
            "[syminfo.ticker](#var_syminfo.ticker)",
            "[syminfo.tickerid](#var_syminfo.tickerid)"
          ],
          "examples": "//@version=5\nindicator(\"syminfo.root\")\n\n// If the current chart symbol is continuous futures ('ES1!'), it would display 'ES'.\nif barstate.islastconfirmedhistory\n\tlabel.new(bar_index, high, syminfo.root)",
          "displayType": "simple string"
        },
        {
          "name": "syminfo.prefix",
          "kind": "Built-in Variable",
          "desc": "Prefix of current symbol name (i.e. for 'CME_EOD:TICKER' prefix is 'CME_EOD').",
          "type": "string",
          "seeAlso": [
            "[syminfo.ticker](#var_syminfo.ticker)",
            "[syminfo.tickerid](#var_syminfo.tickerid)"
          ],
          "examples": "//@version=5\nindicator(\"syminfo.prefix\")\n\n// If current chart symbol is 'BATS:MSFT' then syminfo.prefix is 'BATS'.\nif barstate.islastconfirmedhistory\n\tlabel.new(bar_index, high, text=syminfo.prefix)",
          "displayType": "simple string"
        },
        {
          "name": "syminfo.mintick",
          "kind": "Built-in Variable",
          "desc": "Min tick value for the current symbol.",
          "type": "float",
          "seeAlso": [
            "[syminfo.pointvalue](#var_syminfo.pointvalue)"
          ],
          "displayType": "simple float"
        },
        {
          "name": "syminfo.pointvalue",
          "kind": "Built-in Variable",
          "desc": "Point value for the current symbol.",
          "type": "float",
          "seeAlso": [
            "[syminfo.mintick](#var_syminfo.mintick)"
          ],
          "displayType": "simple float"
        },
        {
          "name": "syminfo.session",
          "kind": "Built-in Variable",
          "desc": "Session type of the chart main series. Possible values are [session.regular](#const_session.regular), [session.extended](#const_session.extended).",
          "type": "string",
          "seeAlso": [
            "[session.regular](#const_session.regular)",
            "[session.extended](#const_session.extended)"
          ],
          "displayType": "simple string"
        },
        {
          "name": "syminfo.timezone",
          "kind": "Built-in Variable",
          "desc": "Timezone of the exchange of the chart main series. Possible values see in [timestamp](#fun_timestamp).",
          "type": "string",
          "seeAlso": [
            "[timestamp](#fun_timestamp)"
          ],
          "displayType": "simple string"
        },
        {
          "name": "syminfo.description",
          "kind": "Built-in Variable",
          "desc": "Description for the current symbol.",
          "type": "string",
          "seeAlso": [
            "[syminfo.ticker](#var_syminfo.ticker)",
            "[syminfo.prefix](#var_syminfo.prefix)"
          ],
          "displayType": "simple string"
        },
        {
          "name": "syminfo.currency",
          "kind": "Built-in Variable",
          "desc": "Currency for the current symbol. Returns currency code: 'USD', 'EUR', etc.",
          "type": "string",
          "seeAlso": [
            "[syminfo.basecurrency](#var_syminfo.basecurrency)",
            "[syminfo.ticker](#var_syminfo.ticker)",
            "[currency.USD](#const_currency.USD)",
            "[currency.EUR](#const_currency.EUR)"
          ],
          "displayType": "simple string"
        },
        {
          "name": "syminfo.basecurrency",
          "kind": "Built-in Variable",
          "desc": "Base currency for the symbol. For the symbol 'BTCUSD' returns 'BTC'.",
          "type": "string",
          "seeAlso": [
            "[syminfo.currency](#var_syminfo.currency)",
            "[syminfo.ticker](#var_syminfo.ticker)"
          ],
          "displayType": "simple string"
        },
        {
          "name": "syminfo.type",
          "kind": "Built-in Variable",
          "desc": "Type of the current symbol. Possible values are stock, futures, index, forex, crypto, fund, dr.",
          "type": "string",
          "seeAlso": [
            "[syminfo.ticker](#var_syminfo.ticker)"
          ],
          "displayType": "simple string"
        },
        {
          "name": "syminfo.sector",
          "kind": "Built-in Variable",
          "desc": "Returns the sector of the symbol, or [na](#var_na) if the symbol has no sector.  \nExample: \"Electronic Technology\", \"Technology services\", \"Energy Minerals\", \"Consumer Durables\", etc.  \nThese are the same values one can see in the chart\\`s \"Symbol info\" window.",
          "type": "string",
          "remarks": "A sector is a broad section of the economy. An industry is a narrower classification.  \nNASDAQ:CAT (Caterpillar, Inc.) for example, belongs to the \"Producer Manufacturing\" sector and the \"Trucks/Construction/Farm Machinery\" industry.",
          "displayType": "simple string"
        },
        {
          "name": "syminfo.industry",
          "kind": "Built-in Variable",
          "desc": "Returns the industry of the symbol, or [na](#var_na) if the symbol has no industry.  \nExample: \"Internet Software/Services\", \"Packaged software\", \"Integrated Oil\", \"Motor Vehicles\", etc.  \nThese are the same values one can see in the chart\\`s \"Symbol info\" window.",
          "type": "string",
          "remarks": "A sector is a broad section of the economy. An industry is a narrower classification.  \nNASDAQ:CAT (Caterpillar, Inc.) for example, belongs to the \"Producer Manufacturing\" sector and the \"Trucks/Construction/Farm Machinery\" industry.",
          "displayType": "simple string"
        },
        {
          "name": "syminfo.country",
          "kind": "Built-in Variable",
          "desc": "Returns the two-letter code of the country where the symbol is traded, in the [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format, or [na](#var_na) if the exchange is not directly tied to a specific country.  \nFor example, on \"NASDAQ:AAPL\" it will return \"US\", on \"LSE:AAPL\" it will return \"GB\", and on \"BITSTAMP:BTCUSD it will return [na](#var_na).",
          "type": "string",
          "displayType": "simple string"
        },
        {
          "name": "syminfo.volumetype",
          "kind": "Built-in Variable",
          "desc": "Volume type of the current symbol. Possible values are: \"base\" for base currency, \"quote\" for quote currency, \"tick\" for the number of transactions, and \"n/a\" when there is no volume or its type is not specified.",
          "type": "string",
          "remarks": "Only some data feed suppliers provide information qualifying volume. As a result, the variable will return a value on some symbols only, mostly in the crypto sector.",
          "seeAlso": [
            "[syminfo.type](#var_syminfo.type)"
          ],
          "displayType": "simple string"
        },
        {
          "name": "timeframe.multiplier",
          "kind": "Built-in Variable",
          "desc": "Multiplier of resolution, e.g. '60' - 60, 'D' - 1, '5D' - 5, '12M' - 12.",
          "type": "int",
          "seeAlso": [
            "[syminfo.ticker](#var_syminfo.ticker)",
            "[syminfo.tickerid](#var_syminfo.tickerid)",
            "[timeframe.period](#var_timeframe.period)"
          ],
          "displayType": "simple int"
        },
        {
          "name": "timeframe.isdwm",
          "kind": "Built-in Variable",
          "desc": "Returns true if current resolution is a daily or weekly or monthly resolution, false otherwise.",
          "type": "bool",
          "seeAlso": [
            "[timeframe.isintraday](#var_timeframe.isintraday)",
            "[timeframe.isminutes](#var_timeframe.isminutes)",
            "[timeframe.isseconds](#var_timeframe.isseconds)",
            "[timeframe.isdaily](#var_timeframe.isdaily)",
            "[timeframe.isweekly](#var_timeframe.isweekly)",
            "[timeframe.ismonthly](#var_timeframe.ismonthly)"
          ],
          "displayType": "simple bool"
        },
        {
          "name": "timeframe.isintraday",
          "kind": "Built-in Variable",
          "desc": "Returns true if current resolution is an intraday (minutes or seconds) resolution, false otherwise.",
          "type": "bool",
          "seeAlso": [
            "[timeframe.isminutes](#var_timeframe.isminutes)",
            "[timeframe.isseconds](#var_timeframe.isseconds)",
            "[timeframe.isdwm](#var_timeframe.isdwm)",
            "[timeframe.isdaily](#var_timeframe.isdaily)",
            "[timeframe.isweekly](#var_timeframe.isweekly)",
            "[timeframe.ismonthly](#var_timeframe.ismonthly)"
          ],
          "displayType": "simple bool"
        },
        {
          "name": "timeframe.isdaily",
          "kind": "Built-in Variable",
          "desc": "Returns true if current resolution is a daily resolution, false otherwise.",
          "type": "bool",
          "seeAlso": [
            "[timeframe.isdwm](#var_timeframe.isdwm)",
            "[timeframe.isintraday](#var_timeframe.isintraday)",
            "[timeframe.isminutes](#var_timeframe.isminutes)",
            "[timeframe.isseconds](#var_timeframe.isseconds)",
            "[timeframe.isweekly](#var_timeframe.isweekly)",
            "[timeframe.ismonthly](#var_timeframe.ismonthly)"
          ],
          "displayType": "simple bool"
        },
        {
          "name": "timeframe.isweekly",
          "kind": "Built-in Variable",
          "desc": "Returns true if current resolution is a weekly resolution, false otherwise.",
          "type": "bool",
          "seeAlso": [
            "[timeframe.isdwm](#var_timeframe.isdwm)",
            "[timeframe.isintraday](#var_timeframe.isintraday)",
            "[timeframe.isminutes](#var_timeframe.isminutes)",
            "[timeframe.isseconds](#var_timeframe.isseconds)",
            "[timeframe.isdaily](#var_timeframe.isdaily)",
            "[timeframe.ismonthly](#var_timeframe.ismonthly)"
          ],
          "displayType": "simple bool"
        },
        {
          "name": "timeframe.ismonthly",
          "kind": "Built-in Variable",
          "desc": "Returns true if current resolution is a monthly resolution, false otherwise.",
          "type": "bool",
          "seeAlso": [
            "[timeframe.isdwm](#var_timeframe.isdwm)",
            "[timeframe.isintraday](#var_timeframe.isintraday)",
            "[timeframe.isminutes](#var_timeframe.isminutes)",
            "[timeframe.isseconds](#var_timeframe.isseconds)",
            "[timeframe.isdaily](#var_timeframe.isdaily)",
            "[timeframe.isweekly](#var_timeframe.isweekly)"
          ],
          "displayType": "simple bool"
        },
        {
          "name": "timeframe.isminutes",
          "kind": "Built-in Variable",
          "desc": "Returns true if current resolution is a minutes resolution, false otherwise.",
          "type": "bool",
          "seeAlso": [
            "[timeframe.isdwm](#var_timeframe.isdwm)",
            "[timeframe.isintraday](#var_timeframe.isintraday)",
            "[timeframe.isseconds](#var_timeframe.isseconds)",
            "[timeframe.isdaily](#var_timeframe.isdaily)",
            "[timeframe.isweekly](#var_timeframe.isweekly)",
            "[timeframe.ismonthly](#var_timeframe.ismonthly)"
          ],
          "displayType": "simple bool"
        },
        {
          "name": "timeframe.isseconds",
          "kind": "Built-in Variable",
          "desc": "Returns true if current resolution is a seconds resolution, false otherwise.",
          "type": "bool",
          "seeAlso": [
            "[timeframe.isdwm](#var_timeframe.isdwm)",
            "[timeframe.isintraday](#var_timeframe.isintraday)",
            "[timeframe.isminutes](#var_timeframe.isminutes)",
            "[timeframe.isdaily](#var_timeframe.isdaily)",
            "[timeframe.isweekly](#var_timeframe.isweekly)",
            "[timeframe.ismonthly](#var_timeframe.ismonthly)"
          ],
          "displayType": "simple bool"
        },
        {
          "name": "timenow",
          "kind": "Built-in Variable",
          "desc": "Current time in UNIX format. It is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970.",
          "type": "int",
          "remarks": "Please note that using this variable/function can cause [indicator repainting](https://www.tradingview.com/pine-script-docs/en/v5/concepts/Repainting.html).",
          "seeAlso": [
            "[timestamp](#fun_timestamp)",
            "[time](#var_time) (variable)",
            "[time_close](#var_time_close)",
            "[year](#var_year)",
            "[month](#var_month)",
            "[weekofyear](#var_weekofyear)",
            "[dayofmonth](#var_dayofmonth)",
            "[dayofweek](#var_dayofweek)",
            "[hour](#var_hour)",
            "[minute](#var_minute)",
            "[second](#var_second)"
          ],
          "displayType": "series int"
        },
        {
          "name": "time",
          "kind": "Built-in Variable",
          "desc": "Current bar time in UNIX format. It is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970.",
          "type": "int",
          "remarks": "Note that this variable returns the timestamp based on the time of the bar\\`s open.  \nBecause of that, for overnight sessions (e.g.  \nEURUSD, where Monday session starts on Sunday, 17:00) this variable can return time before the specified date of the trading day.  \nFor example, on EURUSD, `dayofmonth(time)` can be lower by 1 than the date of the trading day, because the bar for the current day actually opens one day prior.",
          "seeAlso": [
            "[time](#fun_time) (function)",
            "[time_close](#var_time_close)",
            "[timenow](#var_timenow)",
            "[year](#var_year)",
            "[month](#var_month)",
            "[weekofyear](#var_weekofyear)",
            "[dayofmonth](#var_dayofmonth)",
            "[dayofweek](#var_dayofweek)",
            "[hour](#var_hour)",
            "[minute](#var_minute)",
            "[second](#var_second)"
          ],
          "displayType": "series int"
        },
        {
          "name": "time_close",
          "kind": "Built-in Variable",
          "desc": "The time of the current bar\\`s close in UNIX format. It represents the number of milliseconds elapsed since 00:00:00 UTC, 1 January 1970.  \nOn non-standard price-based chart types (Renko, Line break, Kagi, Point & Figure, and Range), this variable returns [na](#var_na) on the chart\\`s realtime bars.",
          "type": "int",
          "seeAlso": [
            "[time](#var_time)",
            "[timenow](#var_timenow)",
            "[year](#var_year)",
            "[month](#var_month)",
            "[weekofyear](#var_weekofyear)",
            "[dayofmonth](#var_dayofmonth)",
            "[dayofweek](#var_dayofweek)",
            "[hour](#var_hour)",
            "[minute](#var_minute)",
            "[second](#var_second)"
          ],
          "displayType": "series int"
        },
        {
          "name": "time_tradingday",
          "kind": "Built-in Variable",
          "desc": "The beginning time of the trading day the current bar belongs to, in UNIX format (the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970).",
          "type": "int",
          "remarks": "The variable is useful for overnight sessions, where the current day\\`s session can start on the previous calendar day (e.g., on EURUSD the Monday session will start on Sunday, 17:00).  \nUnlike `time`, which would return the timestamp for Sunday at 17:00 for the Monday daily bar, `time_tradingday` will return the timestamp for Monday, 00:00.\nWhen used on timeframes higher than 1D, `time_tradingday` returns the trading day of the last day inside the bar (e.g.  \non 1W, it will return the last trading day of the week).",
          "seeAlso": [
            "[time](#var_time)",
            "[time_close](#var_time_close)"
          ],
          "displayType": "series int"
        },
        {
          "name": "year",
          "kind": "Built-in Variable",
          "desc": "Current bar year in exchange timezone.",
          "type": "int",
          "remarks": "Note that this variable returns the year based on the time of the bar\\`s open. For overnight sessions (e.g.  \nEURUSD, where Monday session starts on Sunday, 17:00) this value can be lower by 1 than the year of the trading day.",
          "seeAlso": [
            "[year](#fun_year) (function)",
            "[time](#var_time)",
            "[month](#var_month)",
            "[weekofyear](#var_weekofyear)",
            "[dayofmonth](#var_dayofmonth)",
            "[dayofweek](#var_dayofweek)",
            "[hour](#var_hour)",
            "[minute](#var_minute)",
            "[second](#var_second)"
          ],
          "displayType": "series int"
        },
        {
          "name": "month",
          "kind": "Built-in Variable",
          "desc": "Current bar month in exchange timezone.",
          "type": "int",
          "remarks": "Note that this variable returns the month based on the time of the bar\\`s open. For overnight sessions (e.g.  \nEURUSD, where Monday session starts on Sunday, 17:00) this value can be lower by 1 than the month of the trading day.",
          "seeAlso": [
            "[month](#fun_month) (function)",
            "[time](#var_time)",
            "[year](#var_year)",
            "[weekofyear](#var_weekofyear)",
            "[dayofmonth](#var_dayofmonth)",
            "[dayofweek](#var_dayofweek)",
            "[hour](#var_hour)",
            "[minute](#var_minute)",
            "[second](#var_second)"
          ],
          "displayType": "series int"
        },
        {
          "name": "weekofyear",
          "kind": "Built-in Variable",
          "desc": "Week number of current bar time in exchange timezone.",
          "type": "int",
          "remarks": "Note that this variable returns the week based on the time of the bar\\`s open. For overnight sessions (e.g.  \nEURUSD, where Monday session starts on Sunday, 17:00) this value can be lower by 1 than the week of the trading day.",
          "seeAlso": [
            "[weekofyear](#fun_weekofyear) (function)",
            "[time](#var_time)",
            "[year](#var_year)",
            "[month](#var_month)",
            "[dayofmonth](#var_dayofmonth)",
            "[dayofweek](#var_dayofweek)",
            "[hour](#var_hour)",
            "[minute](#var_minute)",
            "[second](#var_second)"
          ],
          "displayType": "series int"
        },
        {
          "name": "dayofmonth",
          "kind": "Built-in Variable",
          "desc": "Date of current bar time in exchange timezone.",
          "type": "int",
          "remarks": "Note that this variable returns the day based on the time of the bar\\`s open. For overnight sessions (e.g.  \nEURUSD, where Monday session starts on Sunday, 17:00) this value can be lower by 1 than the day of the trading day.",
          "seeAlso": [
            "[dayofmonth](#fun_dayofmonth) (function)",
            "[time](#var_time)",
            "[year](#var_year)",
            "[month](#var_month)",
            "[weekofyear](#var_weekofyear)",
            "[dayofweek](#var_dayofweek)",
            "[hour](#var_hour)",
            "[minute](#var_minute)",
            "[second](#var_second)"
          ],
          "displayType": "series int"
        },
        {
          "name": "dayofweek",
          "kind": "Built-in Variable",
          "desc": "Day of week for current bar time in exchange timezone.",
          "type": "int",
          "remarks": [
            "Note that this variable returns the day based on the time of the bar\\`s open. For overnight sessions (e.g. EURUSD, where Monday session starts on Sunday, 17:00) this value can be lower by 1 than the day of the trading day.",
            "You can use [dayofweek.sunday](#var_dayofweek.sunday), [dayofweek.monday](#var_dayofweek.monday), [dayofweek.tuesday](#var_dayofweek.tuesday), [dayofweek.wednesday](#var_dayofweek.wednesday), [dayofweek.thursday](#var_dayofweek.thursday), [dayofweek.friday](#var_dayofweek.friday) and [dayofweek.saturday](#var_dayofweek.saturday) variables for comparisons."
          ],
          "seeAlso": [
            "[dayofweek](#fun_dayofweek) (function)",
            "[time](#var_time)",
            "[year](#var_year)",
            "[month](#var_month)",
            "[weekofyear](#var_weekofyear)",
            "[dayofmonth](#var_dayofmonth)",
            "[hour](#var_hour)",
            "[minute](#var_minute)",
            "[second](#var_second)"
          ],
          "displayType": "series int"
        },
        {
          "name": "hour",
          "kind": "Built-in Variable",
          "desc": "Current bar hour in exchange timezone.",
          "type": "int",
          "seeAlso": [
            "[hour](#fun_hour) (function)",
            "[time](#var_time)",
            "[year](#var_year)",
            "[month](#var_month)",
            "[weekofyear](#var_weekofyear)",
            "[dayofmonth](#var_dayofmonth)",
            "[dayofweek](#var_dayofweek)",
            "[minute](#var_minute)",
            "[second](#var_second)"
          ],
          "displayType": "series int"
        },
        {
          "name": "minute",
          "kind": "Built-in Variable",
          "desc": "Current bar minute in exchange timezone.",
          "type": "int",
          "seeAlso": [
            "[minute](#fun_minute) (function)",
            "[time](#var_time)",
            "[year](#var_year)",
            "[month](#var_month)",
            "[weekofyear](#var_weekofyear)",
            "[dayofmonth](#var_dayofmonth)",
            "[dayofweek](#var_dayofweek)",
            "[hour](#var_hour)",
            "[second](#var_second)"
          ],
          "displayType": "series int"
        },
        {
          "name": "second",
          "kind": "Built-in Variable",
          "desc": "Current bar second in exchange timezone.",
          "type": "int",
          "seeAlso": [
            "[second](#fun_second) (function)",
            "[time](#var_time)",
            "[year](#var_year)",
            "[month](#var_month)",
            "[weekofyear](#var_weekofyear)",
            "[dayofmonth](#var_dayofmonth)",
            "[dayofweek](#var_dayofweek)",
            "[hour](#var_hour)",
            "[minute](#var_minute)"
          ],
          "displayType": "series int"
        },
        {
          "name": "strategy.position_size",
          "kind": "Built-in Variable",
          "desc": "Direction and size of the current market position. If the value is > 0, the market position is long. If the value is < 0, the market position is short. The absolute value is the number of contracts/shares/lots/units in trade (position size).",
          "type": "float",
          "seeAlso": [
            "[strategy.position_avg_price](#var_strategy.position_avg_price)"
          ],
          "displayType": "series float"
        },
        {
          "name": "strategy.position_avg_price",
          "kind": "Built-in Variable",
          "desc": "Average entry price of current market position. If the market position is flat, 'NaN' is returned.",
          "type": "float",
          "seeAlso": [
            "[strategy.position_size](#var_strategy.position_size)"
          ],
          "displayType": "series float"
        },
        {
          "name": "strategy.openprofit",
          "kind": "Built-in Variable",
          "desc": "Current unrealized profit or loss for all open positions.",
          "type": "float",
          "seeAlso": [
            "[strategy.netprofit](#var_strategy.netprofit)",
            "[strategy.position_size](#var_strategy.position_size)"
          ],
          "displayType": "series float"
        },
        {
          "name": "strategy.netprofit",
          "kind": "Built-in Variable",
          "desc": "Total currency value of all completed trades.",
          "type": "float",
          "seeAlso": [
            "[strategy.openprofit](#var_strategy.openprofit)",
            "[strategy.position_size](#var_strategy.position_size)",
            "[strategy.grossprofit](#var_strategy.grossprofit)",
            "[strategy.grossloss](#var_strategy.grossloss)"
          ],
          "displayType": "series float"
        },
        {
          "name": "strategy.equity",
          "kind": "Built-in Variable",
          "desc": "Current equity ([strategy.initial_capital](#var_strategy.initial_capital) + [strategy.netprofit](#var_strategy.netprofit) + [strategy.openprofit](#var_strategy.openprofit)).",
          "type": "float",
          "seeAlso": [
            "[strategy.netprofit](#var_strategy.netprofit)",
            "[strategy.openprofit](#var_strategy.openprofit)",
            "[strategy.position_size](#var_strategy.position_size)"
          ],
          "displayType": "series float"
        },
        {
          "name": "strategy.position_entry_name",
          "kind": "Built-in Variable",
          "desc": "Name of the order that initially opened current market position.",
          "type": "string",
          "seeAlso": [
            "[strategy.position_size](#var_strategy.position_size)"
          ],
          "displayType": "series string"
        },
        {
          "name": "strategy.grossprofit",
          "kind": "Built-in Variable",
          "desc": "Total currency value of all completed winning trades.",
          "type": "float",
          "seeAlso": [
            "[strategy.netprofit](#var_strategy.netprofit)",
            "[strategy.grossloss](#var_strategy.grossloss)"
          ],
          "displayType": "series float"
        },
        {
          "name": "strategy.grossloss",
          "kind": "Built-in Variable",
          "desc": "Total currency value of all completed losing trades.",
          "type": "float",
          "seeAlso": [
            "[strategy.netprofit](#var_strategy.netprofit)",
            "[strategy.grossprofit](#var_strategy.grossprofit)"
          ],
          "displayType": "series float"
        },
        {
          "name": "strategy.max_drawdown",
          "kind": "Built-in Variable",
          "desc": "Maximum equity drawdown value for the whole trading interval.",
          "type": "float",
          "seeAlso": [
            "[strategy.netprofit](#var_strategy.netprofit)",
            "[strategy.equity](#var_strategy.equity)",
            "[strategy.max_runup](#var_strategy.max_runup)"
          ],
          "displayType": "series float"
        },
        {
          "name": "strategy.max_runup",
          "kind": "Built-in Variable",
          "desc": "Maximum equity run-up value for the whole trading interval.",
          "type": "float",
          "seeAlso": [
            "[strategy.netprofit](#var_strategy.netprofit)",
            "[strategy.equity](#var_strategy.equity)",
            "[strategy.max_drawdown](#var_strategy.max_drawdown)"
          ],
          "displayType": "series float"
        },
        {
          "name": "strategy.max_contracts_held_all",
          "kind": "Built-in Variable",
          "desc": "Maximum number of contracts/shares/lots/units in one trade for the whole trading interval.",
          "type": "float",
          "seeAlso": [
            "[strategy.position_size](#var_strategy.position_size)",
            "[strategy.max_contracts_held_long](#var_strategy.max_contracts_held_long)",
            "[strategy.max_contracts_held_short](#var_strategy.max_contracts_held_short)"
          ],
          "displayType": "series float"
        },
        {
          "name": "strategy.max_contracts_held_long",
          "kind": "Built-in Variable",
          "desc": "Maximum number of contracts/shares/lots/units in one long trade for the whole trading interval.",
          "type": "float",
          "seeAlso": [
            "[strategy.position_size](#var_strategy.position_size)",
            "[strategy.max_contracts_held_all](#var_strategy.max_contracts_held_all)",
            "[strategy.max_contracts_held_short](#var_strategy.max_contracts_held_short)"
          ],
          "displayType": "series float"
        },
        {
          "name": "strategy.max_contracts_held_short",
          "kind": "Built-in Variable",
          "desc": "Maximum number of contracts/shares/lots/units in one short trade for the whole trading interval.",
          "type": "float",
          "seeAlso": [
            "[strategy.position_size](#var_strategy.position_size)",
            "[strategy.max_contracts_held_all](#var_strategy.max_contracts_held_all)",
            "[strategy.max_contracts_held_long](#var_strategy.max_contracts_held_long)"
          ],
          "displayType": "series float"
        },
        {
          "name": "strategy.opentrades",
          "kind": "Built-in Variable",
          "desc": "Number of market position entries, which were not closed and remain opened. If there is no open market position, 0 is returned.",
          "type": "int",
          "seeAlso": [
            "[strategy.position_size](#var_strategy.position_size)"
          ],
          "displayType": "series int"
        },
        {
          "name": "strategy.closedtrades",
          "kind": "Built-in Variable",
          "desc": "Number of trades, which were closed for the whole trading interval.",
          "type": "int",
          "seeAlso": [
            "[strategy.position_size](#var_strategy.position_size)",
            "[strategy.opentrades](#var_strategy.opentrades)",
            "[strategy.wintrades](#var_strategy.wintrades)",
            "[strategy.losstrades](#var_strategy.losstrades)",
            "[strategy.eventrades](#var_strategy.eventrades)"
          ],
          "displayType": "series int"
        },
        {
          "name": "strategy.wintrades",
          "kind": "Built-in Variable",
          "desc": "Number of profitable trades for the whole trading interval.",
          "type": "int",
          "seeAlso": [
            "[strategy.position_size](#var_strategy.position_size)",
            "[strategy.opentrades](#var_strategy.opentrades)",
            "[strategy.closedtrades](#var_strategy.closedtrades)",
            "[strategy.losstrades](#var_strategy.losstrades)",
            "[strategy.eventrades](#var_strategy.eventrades)"
          ],
          "displayType": "series int"
        },
        {
          "name": "strategy.losstrades",
          "kind": "Built-in Variable",
          "desc": "Number of unprofitable trades for the whole trading interval.",
          "type": "int",
          "seeAlso": [
            "[strategy.position_size](#var_strategy.position_size)",
            "[strategy.opentrades](#var_strategy.opentrades)",
            "[strategy.closedtrades](#var_strategy.closedtrades)",
            "[strategy.wintrades](#var_strategy.wintrades)",
            "[strategy.eventrades](#var_strategy.eventrades)"
          ],
          "displayType": "series int"
        },
        {
          "name": "strategy.eventrades",
          "kind": "Built-in Variable",
          "desc": "Number of breakeven trades for the whole trading interval.",
          "type": "int",
          "seeAlso": [
            "[strategy.position_size](#var_strategy.position_size)",
            "[strategy.opentrades](#var_strategy.opentrades)",
            "[strategy.closedtrades](#var_strategy.closedtrades)",
            "[strategy.wintrades](#var_strategy.wintrades)",
            "[strategy.losstrades](#var_strategy.losstrades)"
          ],
          "displayType": "series int"
        },
        {
          "name": "strategy.initial_capital",
          "kind": "Built-in Variable",
          "desc": "The amount of initial capital set in the strategy properties.",
          "type": "float",
          "seeAlso": [
            "[strategy](#fun_strategy)"
          ],
          "displayType": "series float"
        },
        {
          "name": "strategy.account_currency",
          "kind": "Built-in Variable",
          "desc": "Returns the currency used to calculate results, which can be set in the strategy\\`s properties.",
          "type": "string",
          "seeAlso": [
            "[strategy](#fun_strategy)",
            "[strategy.convert_to_account](#fun_strategy.convert_to_account)",
            "[strategy.convert_to_symbol](#fun_strategy.convert_to_symbol)"
          ],
          "displayType": "simple string"
        },
        {
          "name": "strategy.long",
          "kind": "Built-in Variable",
          "desc": "Long position entry.",
          "type": "strategy_direction",
          "seeAlso": [
            "[strategy.entry](#fun_strategy.entry)",
            "[strategy.exit](#fun_strategy.exit)",
            "[strategy.order](#fun_strategy.order)"
          ],
          "displayType": "const strategy_direction"
        },
        {
          "name": "strategy.short",
          "kind": "Built-in Variable",
          "desc": "Short position entry.",
          "type": "strategy_direction",
          "seeAlso": [
            "[strategy.entry](#fun_strategy.entry)",
            "[strategy.exit](#fun_strategy.exit)",
            "[strategy.order](#fun_strategy.order)"
          ],
          "displayType": "const strategy_direction"
        },
        {
          "name": "strategy.margin_liquidation_price",
          "kind": "Built-in Variable",
          "desc": "When margin is used in a strategy, returns the price point where a simulated margin call will occur and liquidate enough of the position to meet the margin requirements.",
          "type": "float",
          "remarks": "The variable returns [na](#var_na) if the strategy does not use margin, i.e., the [strategy](#fun_strategy) declaration statement does not specify an argument for the `margin_long` or `margin_short` parameter.",
          "examples": "//@version=5\nstrategy(\"Margin call management\", overlay = true, margin_long = 25, margin_short = 25, \n  default_qty_type = strategy.percent_of_equity, default_qty_value = 395)\n\nfloat maFast = ta.sma(close, 14)\nfloat maSlow = ta.sma(close, 28)\n\nif ta.crossover(maFast, maSlow)\n    strategy.entry(\"Long\", strategy.long)\n\nif ta.crossunder(maFast, maSlow)\n    strategy.entry(\"Short\", strategy.short)\n\nchangePercent(v1, v2) → \n    float result = (v1 - v2) * 100 / math.abs(v2)\n\n// exit when we're 10% away from a margin call, to prevent it.\nif math.abs(changePercent(close, strategy.margin_liquidation_price)) <= 10\n    strategy.close(\"Long\")\n    strategy.close(\"Short\")",
          "displayType": "series float"
        },
        {
          "name": "strategy.grossloss_percent",
          "type": "series float",
          "desc": "The total value of all completed losing trades, expressed as a percentage of the initial capital.",
          "kind": "Built-in Variable",
          "seeAlso": "[strategy.grossloss](#var_strategy.grossloss)"
        },
        {
          "name": "strategy.max_runup_percent",
          "type": "series float",
          "desc": "The maximum equity run-up value for the whole trading interval, expressed as a percentage and calculated by formula: `Highest Value During Trade / (Entry Price x Quantity) * 100`.",
          "kind": "Built-in Variable",
          "seeAlso": "[strategy.max_runup](#var_strategy.max_runup)"
        },
        {
          "name": "strategy.netprofit_percent",
          "type": "series float",
          "desc": "The total value of all completed trades, expressed as a percentage of the initial capital.",
          "kind": "Built-in Variable",
          "seeAlso": "[strategy.netprofit](#var_strategy.netprofit)"
        },
        {
          "name": "strategy.openprofit_percent",
          "type": "series float",
          "desc": "The current unrealized profit or loss for all open positions, expressed as a percentage and calculated by formula: `openPL / realizedEquity * 100`.",
          "kind": "Built-in Variable",
          "seeAlso": "[strategy.openprofit](#var_strategy.openprofit)"
        },
        {
          "name": "strategy.grossprofit_percent",
          "type": "series float",
          "desc": "The total currency value of all completed winning trades, expressed as a percentage of the initial capital.",
          "kind": "Built-in Variable",
          "seeAlso": "[strategy.grossprofit](#var_strategy.grossprofit)"
        },
        {
          "name": "strategy.max_drawdown_percent",
          "type": "series float",
          "desc": "The maximum equity drawdown value for the whole trading interval, expressed as a percentage and calculated by formula: `Lowest Value During Trade / (Entry Price x Quantity) * 100`.",
          "kind": "Built-in Variable",
          "seeAlso": "[strategy.max_drawdown](#var_strategy.max_drawdown)"
        },
        {
          "name": "barstate.isfirst",
          "kind": "Built-in Variable",
          "desc": "Returns true if current bar is first bar in barset, false otherwise.",
          "type": "bool",
          "remarks": [
            "PineScript code that uses this variable could calculate differently on history and real-time data.",
            "Please note that using this variable/function can cause [indicator repainting](https://www.tradingview.com/pine-script-docs/en/v5/concepts/Repainting.html)."
          ],
          "seeAlso": [
            "[barstate.islast](#var_barstate.islast)",
            "[barstate.ishistory](#var_barstate.ishistory)",
            "[barstate.isrealtime](#var_barstate.isrealtime)",
            "[barstate.isnew](#var_barstate.isnew)",
            "[barstate.isconfirmed](#var_barstate.isconfirmed)",
            "[barstate.islastconfirmedhistory](#var_barstate.islastconfirmedhistory)"
          ],
          "displayType": "series bool"
        },
        {
          "name": "barstate.islast",
          "kind": "Built-in Variable",
          "desc": "Returns true if current bar is the last bar in barset, false otherwise. This condition is true for all real-time bars in barset.",
          "type": "bool",
          "remarks": [
            "PineScript code that uses this variable could calculate differently on history and real-time data.",
            "Please note that using this variable/function can cause [indicator repainting](https://www.tradingview.com/pine-script-docs/en/v5/concepts/Repainting.html)."
          ],
          "seeAlso": [
            "[barstate.isfirst](#var_barstate.isfirst)",
            "[barstate.ishistory](#var_barstate.ishistory)",
            "[barstate.isrealtime](#var_barstate.isrealtime)",
            "[barstate.isnew](#var_barstate.isnew)",
            "[barstate.isconfirmed](#var_barstate.isconfirmed)",
            "[barstate.islastconfirmedhistory](#var_barstate.islastconfirmedhistory)"
          ],
          "displayType": "series bool"
        },
        {
          "name": "barstate.ishistory",
          "kind": "Built-in Variable",
          "desc": "Returns true if current bar is a historical bar, false otherwise.",
          "type": "bool",
          "remarks": [
            "PineScript code that uses this variable could calculate differently on history and real-time data.",
            "Please note that using this variable/function can cause [indicator repainting](https://www.tradingview.com/pine-script-docs/en/v5/concepts/Repainting.html)."
          ],
          "seeAlso": [
            "[barstate.isfirst](#var_barstate.isfirst)",
            "[barstate.islast](#var_barstate.islast)",
            "[barstate.isrealtime](#var_barstate.isrealtime)",
            "[barstate.isnew](#var_barstate.isnew)",
            "[barstate.isconfirmed](#var_barstate.isconfirmed)",
            "[barstate.islastconfirmedhistory](#var_barstate.islastconfirmedhistory)"
          ],
          "displayType": "series bool"
        },
        {
          "name": "barstate.isrealtime",
          "kind": "Built-in Variable",
          "desc": "Returns true if current bar is a real-time bar, false otherwise.",
          "type": "bool",
          "remarks": [
            "PineScript code that uses this variable could calculate differently on history and real-time data.",
            "Please note that using this variable/function can cause [indicator repainting](https://www.tradingview.com/pine-script-docs/en/v5/concepts/Repainting.html)."
          ],
          "seeAlso": [
            "[barstate.isfirst](#var_barstate.isfirst)",
            "[barstate.islast](#var_barstate.islast)",
            "[barstate.ishistory](#var_barstate.ishistory)",
            "[barstate.isnew](#var_barstate.isnew)",
            "[barstate.isconfirmed](#var_barstate.isconfirmed)",
            "[barstate.islastconfirmedhistory](#var_barstate.islastconfirmedhistory)"
          ],
          "displayType": "series bool"
        },
        {
          "name": "barstate.isnew",
          "kind": "Built-in Variable",
          "desc": "Returns true if script is currently calculating on new bar, false otherwise. This variable is true when calculating on historical bars or on first update of a newly generated real-time bar.",
          "type": "bool",
          "remarks": [
            "PineScript code that uses this variable could calculate differently on history and real-time data.",
            "Please note that using this variable/function can cause [indicator repainting](https://www.tradingview.com/pine-script-docs/en/v5/concepts/Repainting.html)."
          ],
          "seeAlso": [
            "[barstate.isfirst](#var_barstate.isfirst)",
            "[barstate.islast](#var_barstate.islast)",
            "[barstate.ishistory](#var_barstate.ishistory)",
            "[barstate.isrealtime](#var_barstate.isrealtime)",
            "[barstate.isconfirmed](#var_barstate.isconfirmed)",
            "[barstate.islastconfirmedhistory](#var_barstate.islastconfirmedhistory)"
          ],
          "displayType": "series bool"
        },
        {
          "name": "barstate.isconfirmed",
          "kind": "Built-in Variable",
          "desc": "Returns true if the script is calculating the last (closing) update of the current bar. The next script calculation will be on the new bar data.",
          "type": "bool",
          "remarks": [
            "PineScript code that uses this variable could calculate differently on history and real-time data.",
            "It is NOT recommended to use [barstate.isconfirmed](#var_barstate.isconfirmed) in [request.security](#fun_request.security) expression. Its value requested from [request.security](#fun_request.security) is unpredictable.",
            "Please note that using this variable/function can cause [indicator repainting](https://www.tradingview.com/pine-script-docs/en/v5/concepts/Repainting.html)."
          ],
          "seeAlso": [
            "[barstate.isfirst](#var_barstate.isfirst)",
            "[barstate.islast](#var_barstate.islast)",
            "[barstate.ishistory](#var_barstate.ishistory)",
            "[barstate.isrealtime](#var_barstate.isrealtime)",
            "[barstate.isnew](#var_barstate.isnew)",
            "[barstate.islastconfirmedhistory](#var_barstate.islastconfirmedhistory)"
          ],
          "displayType": "series bool"
        },
        {
          "name": "barstate.islastconfirmedhistory",
          "kind": "Built-in Variable",
          "desc": "Returns true if script is executing on the dataset\\`s last bar when market is closed, or script is executing on the bar immediately preceding the real-time bar, if market is open. Returns false otherwise.",
          "type": "bool",
          "remarks": [
            "PineScript code that uses this variable could calculate differently on history and real-time data.",
            "Please note that using this variable/function can cause [indicator repainting](https://www.tradingview.com/pine-script-docs/en/v5/concepts/Repainting.html)."
          ],
          "seeAlso": [
            "[barstate.isfirst](#var_barstate.isfirst)",
            "[barstate.islast](#var_barstate.islast)",
            "[barstate.ishistory](#var_barstate.ishistory)",
            "[barstate.isrealtime](#var_barstate.isrealtime)",
            "[barstate.isnew](#var_barstate.isnew)"
          ],
          "displayType": "series bool"
        },
        {
          "name": "session.ismarket",
          "kind": "Built-in Variable",
          "desc": "Returns true if the current bar is a part of the regular trading hours (i.e. market hours), false otherwise",
          "type": "bool",
          "seeAlso": [
            "[session.ispremarket](#var_session.ispremarket)",
            "[session.ispostmarket](#var_session.ispostmarket)"
          ],
          "displayType": "series bool"
        },
        {
          "name": "session.ispremarket",
          "kind": "Built-in Variable",
          "desc": "Returns true if the current bar is a part of the pre-market, false otherwise. On non-intraday charts always returns false.",
          "type": "bool",
          "seeAlso": [
            "[session.ismarket](#var_session.ismarket)",
            "[session.ispostmarket](#var_session.ispostmarket)"
          ],
          "displayType": "series bool"
        },
        {
          "name": "session.ispostmarket",
          "kind": "Built-in Variable",
          "desc": "Returns true if the current bar is a part of the post-market, false otherwise. On non-intraday charts always returns false.",
          "type": "bool",
          "seeAlso": [
            "[session.ismarket](#var_session.ismarket)",
            "[session.ispremarket](#var_session.ispremarket)"
          ],
          "displayType": "series bool"
        },
        {
          "name": "label.all",
          "kind": "Built-in Variable",
          "desc": "Returns an array filled with all the current labels drawn by the script.",
          "type": "array<label>",
          "remarks": "The array is read-only. Index zero of the array is the ID of the oldest object on the chart.",
          "seeAlso": [
            "[label.new](#fun_label.new)",
            "[line.all](#var_line.all)",
            "[box.all](#var_box.all)",
            "[table.all](#var_table.all)."
          ],
          "examples": "//@version=5\nindicator(\"label.all\")\n//delete all labels\nlabel.new(bar_index, close)\na_allLabels = label.all\nif array.size(a_allLabels) > 0\n\tfor i = 0 to array.size(a_allLabels) - 1\n\t\tlabel.delete(array.get(a_allLabels, i))",
          "displayType": "label[]"
        },
        {
          "name": "line.all",
          "kind": "Built-in Variable",
          "desc": "Returns an array filled with all the current lines drawn by the script.",
          "type": "array<line>",
          "remarks": "The array is read-only. Index zero of the array is the ID of the oldest object on the chart.",
          "seeAlso": [
            "[line.new](#fun_line.new)",
            "[label.all](#var_label.all)",
            "[box.all](#var_box.all)",
            "[table.all](#var_table.all)."
          ],
          "examples": "//@version=5\nindicator(\"line.all\")\n//delete all lines\nline.new(bar_index - 10, close, bar_index, close)\na_allLines = line.all\nif array.size(a_allLines) > 0\n\tfor i = 0 to array.size(a_allLines) - 1\n\t\tline.delete(array.get(a_allLines, i))",
          "displayType": "line[]"
        },
        {
          "name": "linefill.all",
          "kind": "Built-in Variable",
          "desc": "Returns an array filled with all the current linefill objects drawn by the script.",
          "type": "array<linefill>",
          "remarks": "The array is read-only. Index zero of the array is the ID of the oldest object on the chart.",
          "displayType": "linefill[]"
        },
        {
          "name": "box.all",
          "kind": "Built-in Variable",
          "desc": "Returns an array filled with all the current boxes drawn by the script.",
          "type": "array<box>",
          "remarks": "The array is read-only. Index zero of the array is the ID of the oldest object on the chart.",
          "seeAlso": [
            "[box.new](#fun_box.new)",
            "[line.all](#var_line.all)",
            "[label.all](#var_label.all)",
            "[table.all](#var_table.all)."
          ],
          "examples": "//@version=5\nindicator(\"box.all\")\n//delete all boxes\nbox.new(time, open, time + 60 * 60 * 24, close, xloc=xloc.bar_time, border_style=line.style_dashed)\na_allBoxes = box.all\nif array.size(a_allBoxes) > 0\n\tfor i = 0 to array.size(a_allBoxes) - 1\n\t\tbox.delete(array.get(a_allBoxes, i))",
          "displayType": "box[]"
        },
        {
          "name": "table.all",
          "kind": "Built-in Variable",
          "desc": "Returns an array filled with all the current tables drawn by the script.",
          "type": "array<table>",
          "remarks": "The array is read-only. Index zero of the array is the ID of the oldest object on the chart.",
          "seeAlso": [
            "[table.new](#fun_table.new)",
            "[line.all](#var_line.all)",
            "[label.all](#var_label.all)",
            "[box.all](#var_box.all)."
          ],
          "examples": "//@version=5\nindicator(\"table.all\")\n//delete all tables\ntable.new(position = position.top_right, columns = 2, rows = 1, bgcolor = color.yellow, border_width = 1)\na_allTables = table.all\nif array.size(a_allTables) > 0\n\tfor i = 0 to array.size(a_allTables) - 1\n\t\ttable.delete(array.get(a_allTables, i))",
          "displayType": "table[]"
        },
        {
          "name": "polyline.all",
          "kind": "Built-in Variable",
          "desc": "Returns an array containing all current [polyline](#op_polyline) instances drawn by the script.",
          "type": "array<polyline>",
          "remarks": "The array is read-only. Index zero of the array references the ID of the oldest polyline object on the chart.",
          "seeAlso": [
            "[polyline.new](#fun_polyfill.new)",
            "[line.all](#var_line.all)",
            "[label.all](#var_label.all)",
            "[box.all](#var_box.all)."
          ],
          "examples": "//@version=5\nindicator(\"polyline.all\")\n//delete all polyfills\nfor i in polyline.all\n\ti.delete()",
          "displayType": "polyline[]"
        },
        {
          "name": "chart.bg_color",
          "kind": "Built-in Variable",
          "desc": "Returns the color of the chart\\`s background from the \"Chart settings/Appearance/Background\" field. When a gradient is selected, the middle point of the gradient is returned.",
          "type": "color",
          "seeAlso": [
            "[chart.fg_color](#var_chart.fg_color)"
          ],
          "displayType": "input color"
        },
        {
          "name": "chart.fg_color",
          "kind": "Built-in Variable",
          "desc": "Returns a color providing optimal contrast with [chart.bg_color](#var_chart.bg_color).",
          "type": "color",
          "seeAlso": [
            "[chart.bg_color](#var_chart.bg_color)"
          ],
          "displayType": "input color"
        },
        {
          "name": "chart.left_visible_bar_time",
          "kind": "Built-in Variable",
          "desc": "The [time](#var_time) of the leftmost bar currently visible on the chart.",
          "type": "int",
          "remarks": "Scripts using this variable will automatically re-execute when its value updates to reflect changes in the chart, which can be caused by users scrolling the chart, or new real-time bars.",
          "seeAlso": [
            "[chart.right_visible_bar_time](#var_chart.right_visible_bar_time)"
          ],
          "displayType": "input int"
        },
        {
          "name": "chart.right_visible_bar_time",
          "kind": "Built-in Variable",
          "desc": "The [time](#var_time) of the rightmost bar currently visible on the chart.",
          "type": "int",
          "remarks": "Scripts using this variable will automatically re-execute when its value updates to reflect changes in the chart, which can be caused by users scrolling the chart, or new real-time bars.",
          "seeAlso": [
            "[chart.left_visible_bar_time](#var_chart.left_visible_bar_time)"
          ],
          "displayType": "input int"
        },
        {
          "name": "chart.is_heikinashi",
          "kind": "Built-in Variable",
          "type": "bool",
          "returns": "Returns [true](#op_true) if the chart type is Heikin Ashi, [false](#op_false) otherwise.",
          "seeAlso": [
            "[chart.is_renko](#var_chart.is_renko)",
            "[chart.is_linebreak](#var_chart.is_linebreak)",
            "[chart.is_kagi](#var_chart.is_kagi)",
            "[chart.is_pnf](#var_chart.is_pnf)",
            "[chart.is_range](#var_chart.is_range)"
          ],
          "displayType": "simple bool"
        },
        {
          "name": "chart.is_renko",
          "kind": "Built-in Variable",
          "type": "bool",
          "returns": "Returns [true](#op_true) if the chart type is Renko, [false](#op_false) otherwise.",
          "seeAlso": [
            "[chart.is_heikinashi](#var_chart.is_heikinashi)",
            "[chart.is_linebreak](#var_chart.is_linebreak)",
            "[chart.is_kagi](#var_chart.is_kagi)",
            "[chart.is_pnf](#var_chart.is_pnf)",
            "[chart.is_range](#var_chart.is_range)"
          ],
          "displayType": "simple bool"
        },
        {
          "name": "chart.is_linebreak",
          "kind": "Built-in Variable",
          "type": "bool",
          "returns": "Returns [true](#op_true) if the chart type is Line break, [false](#op_false) otherwise.",
          "seeAlso": [
            "[chart.is_renko](#var_chart.is_renko)",
            "[chart.is_heikinashi](#var_chart.is_heikinashi)",
            "[chart.is_kagi](#var_chart.is_kagi)",
            "[chart.is_pnf](#var_chart.is_pnf)",
            "[chart.is_range](#var_chart.is_range)"
          ],
          "displayType": "simple bool"
        },
        {
          "name": "chart.is_kagi",
          "kind": "Built-in Variable",
          "type": "bool",
          "returns": "Returns [true](#op_true) if the chart type is Kagi, [false](#op_false) otherwise.",
          "seeAlso": [
            "[chart.is_renko](#var_chart.is_renko)",
            "[chart.is_linebreak](#var_chart.is_linebreak)",
            "[chart.is_heikinashi](#var_chart.is_heikinashi)",
            "[chart.is_pnf](#var_chart.is_pnf)",
            "[chart.is_range](#var_chart.is_range)"
          ],
          "displayType": "simple bool"
        },
        {
          "name": "chart.is_pnf",
          "kind": "Built-in Variable",
          "type": "bool",
          "returns": "Returns [true](#op_true) if the chart type is Point & figure, [false](#op_false) otherwise.",
          "seeAlso": [
            "[chart.is_renko](#var_chart.is_renko)",
            "[chart.is_linebreak](#var_chart.is_linebreak)",
            "[chart.is_kagi](#var_chart.is_kagi)",
            "[chart.is_heikinashi](#var_chart.is_heikinashi)",
            "[chart.is_range](#var_chart.is_range)"
          ],
          "displayType": "simple bool"
        },
        {
          "name": "chart.is_range",
          "kind": "Built-in Variable",
          "type": "bool",
          "returns": "Returns [true](#op_true) if the chart type is Range, [false](#op_false) otherwise.",
          "seeAlso": [
            "[chart.is_renko](#var_chart.is_renko)",
            "[chart.is_linebreak](#var_chart.is_linebreak)",
            "[chart.is_kagi](#var_chart.is_kagi)",
            "[chart.is_pnf](#var_chart.is_pnf)",
            "[chart.is_heikinashi](#var_chart.is_heikinashi)"
          ],
          "displayType": "simple bool"
        },
        {
          "name": "chart.is_standard",
          "kind": "Built-in Variable",
          "type": "bool",
          "returns": "Returns [true](#op_true) if the chart type is bars, candles, hollow candles, line, area or baseline, [false](#op_false) otherwise.",
          "seeAlso": [
            "[chart.is_renko](#var_chart.is_renko)",
            "[chart.is_linebreak](#var_chart.is_linebreak)",
            "[chart.is_kagi](#var_chart.is_kagi)",
            "[chart.is_pnf](#var_chart.is_pnf)",
            "[chart.is_range](#var_chart.is_range)",
            "[chart.is_heikinashi](#var_chart.is_heikinashi)"
          ],
          "displayType": "simple bool"
        },
        {
          "name": "earnings.future_time",
          "kind": "Built-in Variable",
          "desc": "Returns a UNIX timestamp indicating the expected time of the next earnings report, or [na](#var_na) if this data isn't available.",
          "type": "float",
          "remarks": "This value is only fetched once during the script\\`s initial calculation. The variable will return the same value until the script is recalculated, even after the expected time of the next earnings report.",
          "seeAlso": [
            "[request.earnings](#fun_request.earnings)."
          ],
          "displayType": "series float"
        },
        {
          "name": "earnings.future_period_end_time",
          "kind": "Built-in Variable",
          "desc": "Checks the data for the next earnings report and returns the UNIX timestamp of the day when the financial period covered by those earnings ends, or [na](#var_na) if this data isn't available.",
          "type": "float",
          "remarks": "This value is only fetched once during the script\\`s initial calculation. The variable will return the same value until the script is recalculated, even after the expected time of the next earnings report.",
          "seeAlso": [
            "[request.earnings](#fun_request.earnings)."
          ],
          "displayType": "series float"
        },
        {
          "name": "earnings.future_eps",
          "kind": "Built-in Variable",
          "desc": "Returns the estimated Earnings per Share of the next earnings report in the currency of the instrument, or [na](#var_na) if this data isn't available.",
          "type": "float",
          "remarks": "This value is only fetched once during the script\\`s initial calculation. The variable will return the same value until the script is recalculated, even after the expected time of the next earnings report.",
          "seeAlso": [
            "[request.earnings](#fun_request.earnings)."
          ],
          "displayType": "series float"
        },
        {
          "name": "earnings.future_revenue",
          "kind": "Built-in Variable",
          "desc": "Returns the estimated Revenue of the next earnings report in the currency of the instrument, or [na](#var_na) if this data isn't available.",
          "type": "float",
          "remarks": "This value is only fetched once during the script\\`s initial calculation. The variable will return the same value until the script is recalculated, even after the expected time of the next earnings report.",
          "seeAlso": [
            "[request.earnings](#fun_request.earnings)."
          ],
          "displayType": "series float"
        },
        {
          "name": "syminfo.employees",
          "type": "simple int",
          "desc": "The number of employees the company has.",
          "kind": "Built-in Variable",
          "seeAlso": [
            "[syminfo.shareholders](#var_syminfo.shareholders)",
            "[syminfo.shares_outstanding_float](#var_syminfo.shares_outstanding_float)",
            "[syminfo.shares_outstanding_total](#var_syminfo.shares_outstanding_total)"
          ],
          "examples": "//@version=5\nindicator(\"syminfo simple\")\n//@variable A table containing information about a company's employees, shareholders, and shares.\nvar result_table = table.new(position = position.top_right, columns = 2, rows = 5, border_width = 1)\nif barstate.islastconfirmedhistory\n\t// Add header cells\n\ttable.cell(table_id = result_table, column = 0, row = 0, text = \"name\")\n\ttable.cell(table_id = result_table, column = 1, row = 0, text = \"value\")\n\t// Add employee info cells.\n\ttable.cell(table_id = result_table, column = 0, row = 1, text = \"employees\")\n\ttable.cell(table_id = result_table, column = 1, row = 1, text = str.tostring(syminfo.employees))\n\t// Add shareholder cells.\n\ttable.cell(table_id = result_table, column = 0, row = 2, text = \"shareholders\")\n\ttable.cell(table_id = result_table, column = 1, row = 2, text = str.tostring(syminfo.shareholders))\n\t// Add float shares outstanding cells.\n\ttable.cell(table_id = result_table, column = 0, row = 3, text = \"shares_outstanding_float\")\n\ttable.cell(table_id = result_table, column = 1, row = 3, text = str.tostring(syminfo.shares_outstanding_float))\n\t// Add total shares outstanding cells.\n\ttable.cell(table_id = result_table, column = 0, row = 4, text = \"shares_outstanding_total\")\n\ttable.cell(table_id = result_table, column = 1, row = 4, text = str.tostring(syminfo.shares_outstanding_total))"
        },
        {
          "name": "syminfo.shareholders",
          "type": "simple int",
          "desc": "The number of shareholders the company has.",
          "kind": "Built-in Variable",
          "seeAlso": [
            "[syminfo.employees](#var_syminfo.employees)",
            "[syminfo.shares_outstanding_float](#var_syminfo.shares_outstanding_float)",
            "[syminfo.shares_outstanding_total](#var_syminfo.shares_outstanding_total)"
          ],
          "examples": "//@version=5\nindicator(\"syminfo simple\")\n//@variable A table containing information about a company's employees, shareholders, and shares.\nvar result_table = table.new(position = position.top_right, columns = 2, rows = 5, border_width = 1)\nif barstate.islastconfirmedhistory\n\t// Add header cells\n\ttable.cell(table_id = result_table, column = 0, row = 0, text = \"name\")\n\ttable.cell(table_id = result_table, column = 1, row = 0, text = \"value\")\n\t// Add employee info cells.\n\ttable.cell(table_id = result_table, column = 0, row = 1, text = \"employees\")\n\ttable.cell(table_id = result_table, column = 1, row = 1, text = str.tostring(syminfo.employees))\n\t// Add shareholder cells.\n\ttable.cell(table_id = result_table, column = 0, row = 2, text = \"shareholders\")\n\ttable.cell(table_id = result_table, column = 1, row = 2, text = str.tostring(syminfo.shareholders))\n\t// Add float shares outstanding cells.\n\ttable.cell(table_id = result_table, column = 0, row = 3, text = \"shares_outstanding_float\")\n\ttable.cell(table_id = result_table, column = 1, row = 3, text = str.tostring(syminfo.shares_outstanding_float))\n\t// Add total shares outstanding cells.\n\ttable.cell(table_id = result_table, column = 0, row = 4, text = \"shares_outstanding_total\")\n\ttable.cell(table_id = result_table, column = 1, row = 4, text = str.tostring(syminfo.shares_outstanding_total))"
        },
        {
          "name": "syminfo.shares_outstanding_float",
          "type": "simple float",
          "desc": "The total number of shares outstanding a company has available, excluding any of its restricted shares.",
          "kind": "Built-in Variable",
          "seeAlso": [
            "[syminfo.employees](#var_syminfo.employees)",
            "[syminfo.shareholders](#var_syminfo.shareholders)",
            "[syminfo.shares_outstanding_total](#var_syminfo.shares_outstanding_total)"
          ],
          "examples": "//@version=5\nindicator(\"syminfo simple\")\n//@variable A table containing information about a company's employees, shareholders, and shares.\nvar result_table = table.new(position = position.top_right, columns = 2, rows = 5, border_width = 1)\nif barstate.islastconfirmedhistory\n\t// Add header cells\n\ttable.cell(table_id = result_table, column = 0, row = 0, text = \"name\")\n\ttable.cell(table_id = result_table, column = 1, row = 0, text = \"value\")\n\t// Add employee info cells.\n\ttable.cell(table_id = result_table, column = 0, row = 1, text = \"employees\")\n\ttable.cell(table_id = result_table, column = 1, row = 1, text = str.tostring(syminfo.employees))\n\t// Add shareholder cells.\n\ttable.cell(table_id = result_table, column = 0, row = 2, text = \"shareholders\")\n\ttable.cell(table_id = result_table, column = 1, row = 2, text = str.tostring(syminfo.shareholders))\n\t// Add float shares outstanding cells.\n\ttable.cell(table_id = result_table, column = 0, row = 3, text = \"shares_outstanding_float\")\n\ttable.cell(table_id = result_table, column = 1, row = 3, text = str.tostring(syminfo.shares_outstanding_float))\n\t// Add total shares outstanding cells.\n\ttable.cell(table_id = result_table, column = 0, row = 4, text = \"shares_outstanding_total\")\n\ttable.cell(table_id = result_table, column = 1, row = 4, text = str.tostring(syminfo.shares_outstanding_total))"
        },
        {
          "name": "syminfo.shares_outstanding_total",
          "type": "simple int",
          "desc": "The total number of shares outstanding a company has available, including restricted shares held by insiders, major shareholders, and employees.",
          "kind": "Built-in Variable",
          "seeAlso": [
            "[syminfo.employees](#var_syminfo.employees)",
            "[syminfo.shareholders](#var_syminfo.shareholders)",
            "[syminfo.shares_outstanding_float](#var_syminfo.shares_outstanding_float)"
          ],
          "examples": "//@version=5\nindicator(\"syminfo simple\")\n//@variable A table containing information about a company's employees, shareholders, and shares.\nvar result_table = table.new(position = position.top_right, columns = 2, rows = 5, border_width = 1)\nif barstate.islastconfirmedhistory\n\t// Add header cells\n\ttable.cell(table_id = result_table, column = 0, row = 0, text = \"name\")\n\ttable.cell(table_id = result_table, column = 1, row = 0, text = \"value\")\n\t// Add employee info cells.\n\ttable.cell(table_id = result_table, column = 0, row = 1, text = \"employees\")\n\ttable.cell(table_id = result_table, column = 1, row = 1, text = str.tostring(syminfo.employees))\n\t// Add shareholder cells.\n\ttable.cell(table_id = result_table, column = 0, row = 2, text = \"shareholders\")\n\ttable.cell(table_id = result_table, column = 1, row = 2, text = str.tostring(syminfo.shareholders))\n\t// Add float shares outstanding cells.\n\ttable.cell(table_id = result_table, column = 0, row = 3, text = \"shares_outstanding_float\")\n\ttable.cell(table_id = result_table, column = 1, row = 3, text = str.tostring(syminfo.shares_outstanding_float))\n\t// Add total shares outstanding cells.\n\ttable.cell(table_id = result_table, column = 0, row = 4, text = \"shares_outstanding_total\")\n\ttable.cell(table_id = result_table, column = 1, row = 4, text = str.tostring(syminfo.shares_outstanding_total))"
        },
        {
          "name": "syminfo.target_price_average",
          "type": "series float",
          "desc": "The average of the last yearly price targets for the symbol predicted by analysts.",
          "kind": "Built-in Variable",
          "seeAlso": [
            "[syminfo.target_price_date](#var_syminfo.target_price_date)",
            "[syminfo.target_price_estimates](#var_syminfo.target_price_estimates)",
            "[syminfo.target_price_high](#var_syminfo.target_price_high)",
            "[syminfo.target_price_low](#var_syminfo.target_price_low)",
            "[syminfo.target_price_median](#var_syminfo.target_price_median)"
          ],
          "examples": "//@version=5\nindicator(\"syminfo target_price\")\nif barstate.islastconfirmedhistory\n\t//@variable The time value one year from the date of the last analyst recommendations.\n\tint YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000\n\t//@variable A line connecting the current `close` to the highest yearly price estimate.\n\thighLine = line.new(time, close, YTD, syminfo.target_price_high, color = color.green, xloc = xloc.bar_time)\n\t//@variable A line connecting the current `close` to the lowest yearly price estimate.\n\tlowLine = line.new(time, close, YTD, syminfo.target_price_low, color = color.red, xloc = xloc.bar_time)\n\t//@variable A line connecting the current `close` to the median yearly price estimate.\n\tmedianLine = line.new(time, close, YTD, syminfo.target_price_median, color = color.gray, xloc = xloc.bar_time)\n\t//@variable A line connecting the current `close` to the average yearly price estimate.\n\taverageLine = line.new(time, close, YTD, syminfo.target_price_average, color = color.orange, xloc = xloc.bar_time)\n\t// Fill the space between targets\n\tlinefill.new(lowLine, medianLine, color.new(color.red, 90))\n\tlinefill.new(medianLine, highLine, color.new(color.green, 90))\n\t// Create a label displaying the total number of analyst estimates.\n\tstring estimatesText = str.format(\"Number of estimates: {0}\", syminfo.target_price_estimates)\n\tlabel.new(bar_index, close, estimatesText, textcolor = color.white, size = size.large)"
        },
        {
          "name": "syminfo.target_price_date",
          "type": "series int",
          "desc": "The starting date of the last price target prediction for the current symbol.",
          "kind": "Built-in Variable",
          "seeAlso": [
            "[syminfo.target_price_average](#var_syminfo.target_price_average)",
            "[syminfo.target_price_estimates](#var_syminfo.target_price_estimates)",
            "[syminfo.target_price_high](#var_syminfo.target_price_high)",
            "[syminfo.target_price_low](#var_syminfo.target_price_low)",
            "[syminfo.target_price_median](#var_syminfo.target_price_median)"
          ],
          "examples": "//@version=5\nindicator(\"syminfo target_price\")\nif barstate.islastconfirmedhistory\n\t//@variable The time value one year from the date of the last analyst recommendations.\n\tint YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000\n\t//@variable A line connecting the current `close` to the highest yearly price estimate.\n\thighLine = line.new(time, close, YTD, syminfo.target_price_high, color = color.green, xloc = xloc.bar_time)\n\t//@variable A line connecting the current `close` to the lowest yearly price estimate.\n\tlowLine = line.new(time, close, YTD, syminfo.target_price_low, color = color.red, xloc = xloc.bar_time)\n\t//@variable A line connecting the current `close` to the median yearly price estimate.\n\tmedianLine = line.new(time, close, YTD, syminfo.target_price_median, color = color.gray, xloc = xloc.bar_time)\n\t//@variable A line connecting the current `close` to the average yearly price estimate.\n\taverageLine = line.new(time, close, YTD, syminfo.target_price_average, color = color.orange, xloc = xloc.bar_time)\n\t// Fill the space between targets\n\tlinefill.new(lowLine, medianLine, color.new(color.red, 90))\n\tlinefill.new(medianLine, highLine, color.new(color.green, 90))\n\t// Create a label displaying the total number of analyst estimates.\n\tstring estimatesText = str.format(\"Number of estimates: {0}\", syminfo.target_price_estimates)\n\tlabel.new(bar_index, close, estimatesText, textcolor = color.white, size = size.large)"
        },
        {
          "name": "syminfo.target_price_estimates",
          "type": "series float",
          "desc": "The latest total number of price target predictions for the current symbol.",
          "kind": "Built-in Variable",
          "seeAlso": [
            "[syminfo.target_price_average](#var_syminfo.target_price_average)",
            "[syminfo.target_price_date](#var_syminfo.target_price_date)",
            "[syminfo.target_price_high](#var_syminfo.target_price_high)",
            "[syminfo.target_price_low](#var_syminfo.target_price_low)",
            "[syminfo.target_price_median](#var_syminfo.target_price_median)"
          ],
          "examples": "//@version=5\nindicator(\"syminfo target_price\")\nif barstate.islastconfirmedhistory\n\t//@variable The time value one year from the date of the last analyst recommendations.\n\tint YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000\n\t//@variable A line connecting the current `close` to the highest yearly price estimate.\n\thighLine = line.new(time, close, YTD, syminfo.target_price_high, color = color.green, xloc = xloc.bar_time)\n\t//@variable A line connecting the current `close` to the lowest yearly price estimate.\n\tlowLine = line.new(time, close, YTD, syminfo.target_price_low, color = color.red, xloc = xloc.bar_time)\n\t//@variable A line connecting the current `close` to the median yearly price estimate.\n\tmedianLine = line.new(time, close, YTD, syminfo.target_price_median, color = color.gray, xloc = xloc.bar_time)\n\t//@variable A line connecting the current `close` to the average yearly price estimate.\n\taverageLine = line.new(time, close, YTD, syminfo.target_price_average, color = color.orange, xloc = xloc.bar_time)\n\t// Fill the space between targets\n\tlinefill.new(lowLine, medianLine, color.new(color.red, 90))\n\tlinefill.new(medianLine, highLine, color.new(color.green, 90))\n\t// Create a label displaying the total number of analyst estimates.\n\tstring estimatesText = str.format(\"Number of estimates: {0}\", syminfo.target_price_estimates)\n\tlabel.new(bar_index, close, estimatesText, textcolor = color.white, size = size.large)"
        },
        {
          "name": "syminfo.target_price_high",
          "type": "series float",
          "desc": "The last highest yearly price target for the symbol predicted by analysts.",
          "kind": "Built-in Variable",
          "seeAlso": [
            "[syminfo.target_price_average](#var_syminfo.target_price_average)",
            "[syminfo.target_price_date](#var_syminfo.target_price_date)",
            "[syminfo.target_price_estimates](#var_syminfo.target_price_estimates)",
            "[syminfo.target_price_low](#var_syminfo.target_price_low)",
            "[syminfo.target_price_median](#var_syminfo.target_price_median)"
          ],
          "examples": "//@version=5\nindicator(\"syminfo target_price\")\nif barstate.islastconfirmedhistory\n\t//@variable The time value one year from the date of the last analyst recommendations.\n\tint YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000\n\t//@variable A line connecting the current `close` to the highest yearly price estimate.\n\thighLine = line.new(time, close, YTD, syminfo.target_price_high, color = color.green, xloc = xloc.bar_time)\n\t//@variable A line connecting the current `close` to the lowest yearly price estimate.\n\tlowLine = line.new(time, close, YTD, syminfo.target_price_low, color = color.red, xloc = xloc.bar_time)\n\t//@variable A line connecting the current `close` to the median yearly price estimate.\n\tmedianLine = line.new(time, close, YTD, syminfo.target_price_median, color = color.gray, xloc = xloc.bar_time)\n\t//@variable A line connecting the current `close` to the average yearly price estimate.\n\taverageLine = line.new(time, close, YTD, syminfo.target_price_average, color = color.orange, xloc = xloc.bar_time)\n\t// Fill the space between targets\n\tlinefill.new(lowLine, medianLine, color.new(color.red, 90))\n\tlinefill.new(medianLine, highLine, color.new(color.green, 90))\n\t// Create a label displaying the total number of analyst estimates.\n\tstring estimatesText = str.format(\"Number of estimates: {0}\", syminfo.target_price_estimates)\n\tlabel.new(bar_index, close, estimatesText, textcolor = color.white, size = size.large)"
        },
        {
          "name": "syminfo.target_price_low",
          "type": "series float",
          "desc": "The last lowest yearly price target for the symbol predicted by analysts.",
          "kind": "Built-in Variable",
          "seeAlso": [
            "[syminfo.target_price_average](#var_syminfo.target_price_average)",
            "[syminfo.target_price_date](#var_syminfo.target_price_date)",
            "[syminfo.target_price_estimates](#var_syminfo.target_price_estimates)",
            "[syminfo.target_price_high](#var_syminfo.target_price_high)",
            "[syminfo.target_price_median](#var_syminfo.target_price_median)"
          ],
          "examples": "//@version=5\nindicator(\"syminfo target_price\")\nif barstate.islastconfirmedhistory\n\t//@variable The time value one year from the date of the last analyst recommendations.\n\tint YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000\n\t//@variable A line connecting the current `close` to the highest yearly price estimate.\n\thighLine = line.new(time, close, YTD, syminfo.target_price_high, color = color.green, xloc = xloc.bar_time)\n\t//@variable A line connecting the current `close` to the lowest yearly price estimate.\n\tlowLine = line.new(time, close, YTD, syminfo.target_price_low, color = color.red, xloc = xloc.bar_time)\n\t//@variable A line connecting the current `close` to the median yearly price estimate.\n\tmedianLine = line.new(time, close, YTD, syminfo.target_price_median, color = color.gray, xloc = xloc.bar_time)\n\t//@variable A line connecting the current `close` to the average yearly price estimate.\n\taverageLine = line.new(time, close, YTD, syminfo.target_price_average, color = color.orange, xloc = xloc.bar_time)\n\t// Fill the space between targets\n\tlinefill.new(lowLine, medianLine, color.new(color.red, 90))\n\tlinefill.new(medianLine, highLine, color.new(color.green, 90))\n\t// Create a label displaying the total number of analyst estimates.\n\tstring estimatesText = str.format(\"Number of estimates: {0}\", syminfo.target_price_estimates)\n\tlabel.new(bar_index, close, estimatesText, textcolor = color.white, size = size.large)"
        },
        {
          "name": "syminfo.target_price_median",
          "type": "series float",
          "desc": "The median of the last yearly price targets for the symbol predicted by analysts.",
          "kind": "Built-in Variable",
          "seeAlso": [
            "[syminfo.target_price_average](#var_syminfo.target_price_average)",
            "[syminfo.target_price_date](#var_syminfo.target_price_date)",
            "[syminfo.target_price_estimates](#var_syminfo.target_price_estimates)",
            "[syminfo.target_price_high](#var_syminfo.target_price_high)",
            "[syminfo.target_price_low](#var_syminfo.target_price_low)"
          ],
          "examples": "//@version=5\nindicator(\"syminfo target_price\")\nif barstate.islastconfirmedhistory\n\t//@variable The time value one year from the date of the last analyst recommendations.\n\tint YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000\n\t//@variable A line connecting the current `close` to the highest yearly price estimate.\n\thighLine = line.new(time, close, YTD, syminfo.target_price_high, color = color.green, xloc = xloc.bar_time)\n\t//@variable A line connecting the current `close` to the lowest yearly price estimate.\n\tlowLine = line.new(time, close, YTD, syminfo.target_price_low, color = color.red, xloc = xloc.bar_time)\n\t//@variable A line connecting the current `close` to the median yearly price estimate.\n\tmedianLine = line.new(time, close, YTD, syminfo.target_price_median, color = color.gray, xloc = xloc.bar_time)\n\t//@variable A line connecting the current `close` to the average yearly price estimate.\n\taverageLine = line.new(time, close, YTD, syminfo.target_price_average, color = color.orange, xloc = xloc.bar_time)\n\t// Fill the space between targets\n\tlinefill.new(lowLine, medianLine, color.new(color.red, 90))\n\tlinefill.new(medianLine, highLine, color.new(color.green, 90))\n\t// Create a label displaying the total number of analyst estimates.\n\tstring estimatesText = str.format(\"Number of estimates: {0}\", syminfo.target_price_estimates)\n\tlabel.new(bar_index, close, estimatesText, textcolor = color.white, size = size.large)"
        },
        {
          "name": "syminfo.recommendations_buy",
          "type": "series int",
          "desc": "The number of analysts who gave the current symbol a \"Buy\" rating.",
          "kind": "Built-in Variable",
          "seeAlso": [
            "[syminfo.recommendations_buy_strong](#var_syminfo.recommendations_buy_strong)",
            "[syminfo.recommendations_date](#var_syminfo.recommendations_date)",
            "[syminfo.recommendations_hold](#var_syminfo.recommendations_hold)",
            "[syminfo.recommendations_total](#var_syminfo.recommendations_total)",
            "[syminfo.recommendations_sell](#var_syminfo.recommendations_sell)",
            "[syminfo.recommendations_sell_strong](#var_syminfo.recommendations_sell_strong)"
          ],
          "examples": "//@version=5\nindicator(\"syminfo recommendations\", overlay = true)\n//@variable A table containing information about analyst recommendations.\nvar table ratings = table.new(position.top_right, 8, 2, frame_color = #000000)\nif barstate.islastconfirmedhistory\n\t//@variable The time value one year from the date of the last analyst recommendations.\n\tint YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000\n\t// Add header cells.\n\ttable.cell(ratings, 0, 0, \"Start Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 1, 0, \"End Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 2, 0, \"Buy\", bgcolor = color.teal, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 3, 0, \"Strong Buy\", bgcolor = color.lime, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 4, 0, \"Sell\", bgcolor = color.maroon, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 5, 0, \"Strong Sell\", bgcolor = color.red, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 6, 0, \"Hold\", bgcolor = color.orange, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 7, 0, \"Total\", bgcolor = color.silver, text_color = #000000, text_size = size.large)\n\t// Recommendation strings\n\tstring startDate         = str.format_time(syminfo.recommendations_date, \"yyyy-MM-dd\")\n\tstring endDate           = str.format_time(YTD, \"yyyy-MM-dd\")\n\tstring buyRatings        = str.tostring(syminfo.recommendations_buy)\n\tstring strongBuyRatings  = str.tostring(syminfo.recommendations_buy_strong)\n\tstring sellRatings       = str.tostring(syminfo.recommendations_sell)\n\tstring strongSellRatings = str.tostring(syminfo.recommendations_sell_strong)\n\tstring holdRatings       = str.tostring(syminfo.recommendations_hold)\n\tstring totalRatings      = str.tostring(syminfo.recommendations_total)\n\t// Add value cells\n\ttable.cell(ratings, 0, 1, startDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 1, 1, endDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 2, 1, buyRatings, bgcolor = color.teal, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 3, 1, strongBuyRatings, bgcolor = color.lime, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 4, 1, sellRatings, bgcolor = color.maroon, text_color = #000000, text_size = size.large)"
        },
        {
          "name": "syminfo.recommendations_buy_strong",
          "type": "series int",
          "desc": "The number of analysts who gave the current symbol a \"Strong Buy\" rating.",
          "kind": "Built-in Variable",
          "seeAlso": [
            "[syminfo.recommendations_buy](#var_syminfo.recommendations_buy)",
            "[syminfo.recommendations_date](#var_syminfo.recommendations_date)",
            "[syminfo.recommendations_hold](#var_syminfo.recommendations_hold)",
            "[syminfo.recommendations_total](#var_syminfo.recommendations_total)",
            "[syminfo.recommendations_sell](#var_syminfo.recommendations_sell)",
            "[syminfo.recommendations_sell_strong](#var_syminfo.recommendations_sell_strong)"
          ],
          "examples": "//@version=5\nindicator(\"syminfo recommendations\", overlay = true)\n//@variable A table containing information about analyst recommendations.\nvar table ratings = table.new(position.top_right, 8, 2, frame_color = #000000)\nif barstate.islastconfirmedhistory\n\t//@variable The time value one year from the date of the last analyst recommendations.\n\tint YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000\n\t// Add header cells.\n\ttable.cell(ratings, 0, 0, \"Start Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 1, 0, \"End Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 2, 0, \"Buy\", bgcolor = color.teal, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 3, 0, \"Strong Buy\", bgcolor = color.lime, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 4, 0, \"Sell\", bgcolor = color.maroon, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 5, 0, \"Strong Sell\", bgcolor = color.red, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 6, 0, \"Hold\", bgcolor = color.orange, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 7, 0, \"Total\", bgcolor = color.silver, text_color = #000000, text_size = size.large)\n\t// Recommendation strings\n\tstring startDate         = str.format_time(syminfo.recommendations_date, \"yyyy-MM-dd\")\n\tstring endDate           = str.format_time(YTD, \"yyyy-MM-dd\")\n\tstring buyRatings        = str.tostring(syminfo.recommendations_buy)\n\tstring strongBuyRatings  = str.tostring(syminfo.recommendations_buy_strong)\n\tstring sellRatings       = str.tostring(syminfo.recommendations_sell)\n\tstring strongSellRatings = str.tostring(syminfo.recommendations_sell_strong)\n\tstring holdRatings       = str.tostring(syminfo.recommendations_hold)\n\tstring totalRatings      = str.tostring(syminfo.recommendations_total)\n\t// Add value cells\n\ttable.cell(ratings, 0, 1, startDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 1, 1, endDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 2, 1, buyRatings, bgcolor = color.teal, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 3, 1, strongBuyRatings, bgcolor = color.lime, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 4, 1, sellRatings, bgcolor = color.maroon, text_color = #000000, text_size = size.large)"
        },
        {
          "name": "syminfo.recommendations_date",
          "type": "series int",
          "desc": "The starting date of the last set of recommendations for the current symbol.",
          "kind": "Built-in Variable",
          "seeAlso": [
            "[syminfo.recommendations_buy](#var_syminfo.recommendations_buy)",
            "[syminfo.recommendations_buy_strong](#var_syminfo.recommendations_buy_strong)",
            "[syminfo.recommendations_hold](#var_syminfo.recommendations_hold)",
            "[syminfo.recommendations_total](#var_syminfo.recommendations_total)",
            "[syminfo.recommendations_sell](#var_syminfo.recommendations_sell)",
            "[syminfo.recommendations_sell_strong](#var_syminfo.recommendations_sell_strong)"
          ],
          "examples": "//@version=5\nindicator(\"syminfo recommendations\", overlay = true)\n//@variable A table containing information about analyst recommendations.\nvar table ratings = table.new(position.top_right, 8, 2, frame_color = #000000)\nif barstate.islastconfirmedhistory\n\t//@variable The time value one year from the date of the last analyst recommendations.\n\tint YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000\n\t// Add header cells.\n\ttable.cell(ratings, 0, 0, \"Start Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 1, 0, \"End Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 2, 0, \"Buy\", bgcolor = color.teal, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 3, 0, \"Strong Buy\", bgcolor = color.lime, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 4, 0, \"Sell\", bgcolor = color.maroon, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 5, 0, \"Strong Sell\", bgcolor = color.red, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 6, 0, \"Hold\", bgcolor = color.orange, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 7, 0, \"Total\", bgcolor = color.silver, text_color = #000000, text_size = size.large)\n\t// Recommendation strings\n\tstring startDate         = str.format_time(syminfo.recommendations_date, \"yyyy-MM-dd\")\n\tstring endDate           = str.format_time(YTD, \"yyyy-MM-dd\")\n\tstring buyRatings        = str.tostring(syminfo.recommendations_buy)\n\tstring strongBuyRatings  = str.tostring(syminfo.recommendations_buy_strong)\n\tstring sellRatings       = str.tostring(syminfo.recommendations_sell)\n\tstring strongSellRatings = str.tostring(syminfo.recommendations_sell_strong)\n\tstring holdRatings       = str.tostring(syminfo.recommendations_hold)\n\tstring totalRatings      = str.tostring(syminfo.recommendations_total)\n\t// Add value cells\n\ttable.cell(ratings, 0, 1, startDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 1, 1, endDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 2, 1, buyRatings, bgcolor = color.teal, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 3, 1, strongBuyRatings, bgcolor = color.lime, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 4, 1, sellRatings, bgcolor = color.maroon, text_color = #000000, text_size = size.large)"
        },
        {
          "name": "syminfo.recommendations_hold",
          "type": "series int",
          "desc": "The number of analysts who gave the current symbol a \"Hold\" rating.",
          "kind": "Built-in Variable",
          "seeAlso": [
            "[syminfo.recommendations_buy](#var_syminfo.recommendations_buy)",
            "[syminfo.recommendations_buy_strong](#var_syminfo.recommendations_buy_strong)",
            "[syminfo.recommendations_date](#var_syminfo.recommendations_date)",
            "[syminfo.recommendations_total](#var_syminfo.recommendations_total)",
            "[syminfo.recommendations_sell](#var_syminfo.recommendations_sell)",
            "[syminfo.recommendations_sell_strong](#var_syminfo.recommendations_sell_strong)"
          ],
          "examples": "//@version=5\nindicator(\"syminfo recommendations\", overlay = true)\n//@variable A table containing information about analyst recommendations.\nvar table ratings = table.new(position.top_right, 8, 2, frame_color = #000000)\nif barstate.islastconfirmedhistory\n\t//@variable The time value one year from the date of the last analyst recommendations.\n\tint YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000\n\t// Add header cells.\n\ttable.cell(ratings, 0, 0, \"Start Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 1, 0, \"End Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 2, 0, \"Buy\", bgcolor = color.teal, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 3, 0, \"Strong Buy\", bgcolor = color.lime, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 4, 0, \"Sell\", bgcolor = color.maroon, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 5, 0, \"Strong Sell\", bgcolor = color.red, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 6, 0, \"Hold\", bgcolor = color.orange, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 7, 0, \"Total\", bgcolor = color.silver, text_color = #000000, text_size = size.large)\n\t// Recommendation strings\n\tstring startDate         = str.format_time(syminfo.recommendations_date, \"yyyy-MM-dd\")\n\tstring endDate           = str.format_time(YTD, \"yyyy-MM-dd\")\n\tstring buyRatings        = str.tostring(syminfo.recommendations_buy)\n\tstring strongBuyRatings  = str.tostring(syminfo.recommendations_buy_strong)\n\tstring sellRatings       = str.tostring(syminfo.recommendations_sell)\n\tstring strongSellRatings = str.tostring(syminfo.recommendations_sell_strong)\n\tstring holdRatings       = str.tostring(syminfo.recommendations_hold)\n\tstring totalRatings      = str.tostring(syminfo.recommendations_total)\n\t// Add value cells\n\ttable.cell(ratings, 0, 1, startDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 1, 1, endDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 2, 1, buyRatings, bgcolor = color.teal, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 3, 1, strongBuyRatings, bgcolor = color.lime, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 4, 1, sellRatings, bgcolor = color.maroon, text_color = #000000, text_size = size.large)"
        },
        {
          "name": "syminfo.recommendations_total",
          "type": "series int",
          "desc": "The total number of recommendations for the current symbol.",
          "kind": "Built-in Variable",
          "seeAlso": [
            "[syminfo.recommendations_buy](#var_syminfo.recommendations_buy)",
            "[syminfo.recommendations_buy_strong](#var_syminfo.recommendations_buy_strong)",
            "[syminfo.recommendations_date](#var_syminfo.recommendations_date)",
            "[syminfo.recommendations_hold](#var_syminfo.recommendations_hold)",
            "[syminfo.recommendations_sell](#var_syminfo.recommendations_sell)",
            "[syminfo.recommendations_sell_strong](#var_syminfo.recommendations_sell_strong)"
          ],
          "examples": "//@version=5\nindicator(\"syminfo recommendations\", overlay = true)\n//@variable A table containing information about analyst recommendations.\nvar table ratings = table.new(position.top_right, 8, 2, frame_color = #000000)\nif barstate.islastconfirmedhistory\n\t//@variable The time value one year from the date of the last analyst recommendations.\n\tint YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000\n\t// Add header cells.\n\ttable.cell(ratings, 0, 0, \"Start Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 1, 0, \"End Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 2, 0, \"Buy\", bgcolor = color.teal, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 3, 0, \"Strong Buy\", bgcolor = color.lime, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 4, 0, \"Sell\", bgcolor = color.maroon, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 5, 0, \"Strong Sell\", bgcolor = color.red, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 6, 0, \"Hold\", bgcolor = color.orange, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 7, 0, \"Total\", bgcolor = color.silver, text_color = #000000, text_size = size.large)\n\t// Recommendation strings\n\tstring startDate         = str.format_time(syminfo.recommendations_date, \"yyyy-MM-dd\")\n\tstring endDate           = str.format_time(YTD, \"yyyy-MM-dd\")\n\tstring buyRatings        = str.tostring(syminfo.recommendations_buy)\n\tstring strongBuyRatings  = str.tostring(syminfo.recommendations_buy_strong)\n\tstring sellRatings       = str.tostring(syminfo.recommendations_sell)\n\tstring strongSellRatings = str.tostring(syminfo.recommendations_sell_strong)\n\tstring holdRatings       = str.tostring(syminfo.recommendations_hold)\n\tstring totalRatings      = str.tostring(syminfo.recommendations_total)\n\t// Add value cells\n\ttable.cell(ratings, 0, 1, startDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 1, 1, endDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 2, 1, buyRatings, bgcolor = color.teal, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 3, 1, strongBuyRatings, bgcolor = color.lime, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 4, 1, sellRatings, bgcolor = color.maroon, text_color = #000000, text_size = size.large)"
        },
        {
          "name": "syminfo.recommendations_sell",
          "type": "series int",
          "desc": "The number of analysts who gave the current symbol a \"Sell\" rating.",
          "kind": "Built-in Variable",
          "seeAlso": [
            "[syminfo.recommendations_buy](#var_syminfo.recommendations_buy)",
            "[syminfo.recommendations_buy_strong](#var_syminfo.recommendations_buy_strong)",
            "[syminfo.recommendations_date](#var_syminfo.recommendations_date)",
            "[syminfo.recommendations_hold](#var_syminfo.recommendations_hold)",
            "[syminfo.recommendations_total](#var_syminfo.recommendations_total)",
            "[syminfo.recommendations_sell_strong](#var_syminfo.recommendations_sell_strong)"
          ],
          "examples": "//@version=5\nindicator(\"syminfo recommendations\", overlay = true)\n//@variable A table containing information about analyst recommendations.\nvar table ratings = table.new(position.top_right, 8, 2, frame_color = #000000)\nif barstate.islastconfirmedhistory\n\t//@variable The time value one year from the date of the last analyst recommendations.\n\tint YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000\n\t// Add header cells.\n\ttable.cell(ratings, 0, 0, \"Start Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 1, 0, \"End Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 2, 0, \"Buy\", bgcolor = color.teal, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 3, 0, \"Strong Buy\", bgcolor = color.lime, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 4, 0, \"Sell\", bgcolor = color.maroon, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 5, 0, \"Strong Sell\", bgcolor = color.red, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 6, 0, \"Hold\", bgcolor = color.orange, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 7, 0, \"Total\", bgcolor = color.silver, text_color = #000000, text_size = size.large)\n\t// Recommendation strings\n\tstring startDate         = str.format_time(syminfo.recommendations_date, \"yyyy-MM-dd\")\n\tstring endDate           = str.format_time(YTD, \"yyyy-MM-dd\")\n\tstring buyRatings        = str.tostring(syminfo.recommendations_buy)\n\tstring strongBuyRatings  = str.tostring(syminfo.recommendations_buy_strong)\n\tstring sellRatings       = str.tostring(syminfo.recommendations_sell)\n\tstring strongSellRatings = str.tostring(syminfo.recommendations_sell_strong)\n\tstring holdRatings       = str.tostring(syminfo.recommendations_hold)\n\tstring totalRatings      = str.tostring(syminfo.recommendations_total)\n\t// Add value cells\n\ttable.cell(ratings, 0, 1, startDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 1, 1, endDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 2, 1, buyRatings, bgcolor = color.teal, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 3, 1, strongBuyRatings, bgcolor = color.lime, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 4, 1, sellRatings, bgcolor = color.maroon, text_color = #000000, text_size = size.large)"
        },
        {
          "name": "syminfo.recommendations_sell_strong",
          "type": "series int",
          "desc": "The number of analysts who gave the current symbol a \"Strong Sell\" rating.",
          "kind": "Built-in Variable",
          "seeAlso": [
            "[syminfo.recommendations_buy](#var_syminfo.recommendations_buy)",
            "[syminfo.recommendations_buy_strong](#var_syminfo.recommendations_buy_strong)",
            "[syminfo.recommendations_date](#var_syminfo.recommendations_date)",
            "[syminfo.recommendations_hold](#var_syminfo.recommendations_hold)",
            "[syminfo.recommendations_total](#var_syminfo.recommendations_total)",
            "[syminfo.recommendations_sell](#var_syminfo.recommendations_sell)"
          ],
          "examples": "//@version=5\nindicator(\"syminfo recommendations\", overlay = true)\n//@variable A table containing information about analyst recommendations.\nvar table ratings = table.new(position.top_right, 8, 2, frame_color = #000000)\nif barstate.islastconfirmedhistory\n\t//@variable The time value one year from the date of the last analyst recommendations.\n\tint YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000\n\t// Add header cells.\n\ttable.cell(ratings, 0, 0, \"Start Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 1, 0, \"End Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 2, 0, \"Buy\", bgcolor = color.teal, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 3, 0, \"Strong Buy\", bgcolor = color.lime, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 4, 0, \"Sell\", bgcolor = color.maroon, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 5, 0, \"Strong Sell\", bgcolor = color.red, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 6, 0, \"Hold\", bgcolor = color.orange, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 7, 0, \"Total\", bgcolor = color.silver, text_color = #000000, text_size = size.large)\n\t// Recommendation strings\n\tstring startDate         = str.format_time(syminfo.recommendations_date, \"yyyy-MM-dd\")\n\tstring endDate           = str.format_time(YTD, \"yyyy-MM-dd\")\n\tstring buyRatings        = str.tostring(syminfo.recommendations_buy)\n\tstring strongBuyRatings  = str.tostring(syminfo.recommendations_buy_strong)\n\tstring sellRatings       = str.tostring(syminfo.recommendations_sell)\n\tstring strongSellRatings = str.tostring(syminfo.recommendations_sell_strong)\n\tstring holdRatings       = str.tostring(syminfo.recommendations_hold)\n\tstring totalRatings      = str.tostring(syminfo.recommendations_total)\n\t// Add value cells\n\ttable.cell(ratings, 0, 1, startDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 1, 1, endDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 2, 1, buyRatings, bgcolor = color.teal, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 3, 1, strongBuyRatings, bgcolor = color.lime, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 4, 1, sellRatings, bgcolor = color.maroon, text_color = #000000, text_size = size.large)"
        }
      ],
      "title": "Built-in Variable"
    }
  ],
  "constants": [
    {
      "docs": [
        {
          "name": "math.pi",
          "kind": "Built-in Constant",
          "desc": "Is a named constant for [Archimedes' constant](https://en.wikipedia.org/wiki/Pi).  \nIt is equal to 3.1415926535897932.",
          "type": "float",
          "seeAlso": [
            "[math.e](#const_math.e)",
            "[math.phi](#const_math.phi)",
            "[math.rphi](#const_math.rphi)"
          ],
          "displayType": "const float"
        },
        {
          "name": "math.phi",
          "kind": "Built-in Constant",
          "desc": "Is a named constant for the [golden ratio](https://en.wikipedia.org/wiki/Golden_ratio).  \nIt is equal to 1.6180339887498948.",
          "type": "float",
          "seeAlso": [
            "[math.e](#const_math.e)",
            "[math.pi](#const_math.pi)",
            "[math.rphi](#const_math.rphi)"
          ],
          "displayType": "const float"
        },
        {
          "name": "math.rphi",
          "kind": "Built-in Constant",
          "desc": "Is a named constant for the [golden ratio conjugate](https://en.wikipedia.org/wiki/Golden_ratio#Golden_ratio_conjugate).  \nIt is equal to 0.6180339887498948.",
          "type": "float",
          "seeAlso": [
            "[math.e](#const_math.e)",
            "[math.pi](#const_math.pi)",
            "[math.phi](#const_math.phi)"
          ],
          "displayType": "const float"
        },
        {
          "name": "math.e",
          "kind": "Built-in Constant",
          "desc": "Is a named constant for [Euler\\`s number](https://en.wikipedia.org/wiki/E_(mathematical_constant)).  \nIt is equal to 2.7182818284590452.",
          "type": "float",
          "seeAlso": [
            "[math.phi](#const_math.phi)",
            "[math.pi](#const_math.pi)",
            "[math.rphi](#const_math.rphi)"
          ],
          "displayType": "const float"
        },
        {
          "name": "session.regular",
          "kind": "Built-in Constant",
          "desc": "Constant for regular session type (no extended hours data).",
          "type": "string",
          "seeAlso": [
            "[session.extended](#const_session.extended)",
            "[syminfo.session](#const_syminfo.session)"
          ],
          "displayType": "const string"
        },
        {
          "name": "session.extended",
          "kind": "Built-in Constant",
          "desc": "Constant for extended session type (with extended hours data).",
          "type": "string",
          "seeAlso": [
            "[session.regular](#const_session.regular)",
            "[syminfo.session](#const_syminfo.session)"
          ],
          "displayType": "const string"
        },
        {
          "name": "adjustment.none",
          "kind": "Built-in Constant",
          "desc": "Constant for none adjustment type (no adjustment is applied).",
          "type": "string",
          "seeAlso": [
            "[adjustment.splits](#const_adjustment.splits)",
            "[adjustment.dividends](#const_adjustment.dividends)",
            "[ticker.new](#fun_ticker.new)"
          ],
          "displayType": "const string"
        },
        {
          "name": "adjustment.splits",
          "kind": "Built-in Constant",
          "desc": "Constant for splits adjustment type (splits adjustment is applied).",
          "type": "string",
          "seeAlso": [
            "[adjustment.none](#const_adjustment.none)",
            "[adjustment.dividends](#const_adjustment.dividends)",
            "[ticker.new](#fun_ticker.new)"
          ],
          "displayType": "const string"
        },
        {
          "name": "adjustment.dividends",
          "kind": "Built-in Constant",
          "desc": "Constant for dividends adjustment type (dividends adjustment is applied).",
          "type": "string",
          "seeAlso": [
            "[adjustment.none](#const_adjustment.none)",
            "[adjustment.splits](#const_adjustment.splits)",
            "[ticker.new](#fun_ticker.new)"
          ],
          "displayType": "const string"
        },
        {
          "name": "hline.style_solid",
          "kind": "Built-in Constant",
          "desc": "Is a named constant for solid linestyle of [hline](#fun_hline) function.",
          "type": "hline_style",
          "seeAlso": [
            "[hline.style_dotted](#const_hline.style_dotted)",
            "[hline.style_dashed](#const_hline.style_dashed)"
          ],
          "displayType": "const hline_style"
        },
        {
          "name": "hline.style_dotted",
          "kind": "Built-in Constant",
          "desc": "Is a named constant for dotted linestyle of [hline](#fun_hline) function.",
          "type": "hline_style",
          "seeAlso": [
            "[hline.style_solid](#const_hline.style_solid)",
            "[hline.style_dashed](#const_hline.style_dashed)"
          ],
          "displayType": "const hline_style"
        },
        {
          "name": "hline.style_dashed",
          "kind": "Built-in Constant",
          "desc": "Is a named constant for dashed linestyle of [hline](#fun_hline) function.",
          "type": "hline_style",
          "seeAlso": [
            "[hline.style_solid](#const_hline.style_solid)",
            "[hline.style_dotted](#const_hline.style_dotted)"
          ],
          "displayType": "const hline_style"
        },
        {
          "name": "position.top_left",
          "kind": "Built-in Constant",
          "desc": "Table position is used in [table.new](#fun_table.new), [table.cell](#fun_table.cell) functions.\nBinds the table to the upper-left edge.",
          "type": "string",
          "seeAlso": [
            "[table.new](#fun_table.new)",
            "[table.cell](#fun_table.cell)",
            "[table.set_position](#fun_table.set_position)",
            "[position.top_center](#const_position.top_center)",
            "[position.top_right](#const_position.top_right)",
            "[position.middle_left](#const_position.middle_left)",
            "[position.middle_center](#const_position.middle_center)",
            "[position.middle_right](#const_position.middle_right)",
            "[position.bottom_left](#const_position.bottom_left)",
            "[position.bottom_center](#const_position.bottom_center)",
            "[position.bottom_right](#const_position.bottom_right)"
          ],
          "displayType": "const string"
        },
        {
          "name": "position.top_center",
          "kind": "Built-in Constant",
          "desc": "Table position is used in [table.new](#fun_table.new), [table.cell](#fun_table.cell) functions.\nBinds the table to the top edge in the center.",
          "type": "string",
          "seeAlso": [
            "[table.new](#fun_table.new)",
            "[table.cell](#fun_table.cell)",
            "[table.set_position](#fun_table.set_position)",
            "[position.top_left](#const_position.top_left)",
            "[position.top_right](#const_position.top_right)",
            "[position.middle_left](#const_position.middle_left)",
            "[position.middle_center](#const_position.middle_center)",
            "[position.middle_right](#const_position.middle_right)",
            "[position.bottom_left](#const_position.bottom_left)",
            "[position.bottom_center](#const_position.bottom_center)",
            "[position.bottom_right](#const_position.bottom_right)"
          ],
          "displayType": "const string"
        },
        {
          "name": "position.top_right",
          "kind": "Built-in Constant",
          "desc": "Table position is used in [table.new](#fun_table.new), [table.cell](#fun_table.cell) functions.\nBinds the table to the upper-right edge.",
          "type": "string",
          "seeAlso": [
            "[table.new](#fun_table.new)",
            "[table.cell](#fun_table.cell)",
            "[table.set_position](#fun_table.set_position)",
            "[position.top_left](#const_position.top_left)",
            "[position.top_center](#const_position.top_center)",
            "[position.middle_left](#const_position.middle_left)",
            "[position.middle_center](#const_position.middle_center)",
            "[position.middle_right](#const_position.middle_right)",
            "[position.bottom_left](#const_position.bottom_left)",
            "[position.bottom_center](#const_position.bottom_center)",
            "[position.bottom_right](#const_position.bottom_right)"
          ],
          "displayType": "const string"
        },
        {
          "name": "position.middle_left",
          "kind": "Built-in Constant",
          "desc": "Table position is used in [table.new](#fun_table.new), [table.cell](#fun_table.cell) functions.\nBinds the table to the left side of the screen.",
          "type": "string",
          "seeAlso": [
            "[table.new](#fun_table.new)",
            "[table.cell](#fun_table.cell)",
            "[table.set_position](#fun_table.set_position)",
            "[position.top_left](#const_position.top_left)",
            "[position.top_center](#const_position.top_center)",
            "[position.top_right](#const_position.top_right)",
            "[position.middle_center](#const_position.middle_center)",
            "[position.middle_right](#const_position.middle_right)",
            "[position.bottom_left](#const_position.bottom_left)",
            "[position.bottom_center](#const_position.bottom_center)",
            "[position.bottom_right](#const_position.bottom_right)"
          ],
          "displayType": "const string"
        },
        {
          "name": "position.middle_center",
          "kind": "Built-in Constant",
          "desc": "Table position is used in [table.new](#fun_table.new), [table.cell](#fun_table.cell) functions.\nBinds the table to the center of the screen.",
          "type": "string",
          "seeAlso": [
            "[table.new](#fun_table.new)",
            "[table.cell](#fun_table.cell)",
            "[table.set_position](#fun_table.set_position)",
            "[position.top_left](#const_position.top_left)",
            "[position.top_center](#const_position.top_center)",
            "[position.top_right](#const_position.top_right)",
            "[position.middle_left](#const_position.middle_left)",
            "[position.middle_right](#const_position.middle_right)",
            "[position.bottom_left](#const_position.bottom_left)",
            "[position.bottom_center](#const_position.bottom_center)",
            "[position.bottom_right](#const_position.bottom_right)"
          ],
          "displayType": "const string"
        },
        {
          "name": "position.middle_right",
          "kind": "Built-in Constant",
          "desc": "Table position is used in [table.new](#fun_table.new), [table.cell](#fun_table.cell) functions.\nBinds the table to the right side of the screen.",
          "type": "string",
          "seeAlso": [
            "[table.new](#fun_table.new)",
            "[table.cell](#fun_table.cell)",
            "[table.set_position](#fun_table.set_position)",
            "[position.top_left](#const_position.top_left)",
            "[position.top_center](#const_position.top_center)",
            "[position.top_right](#const_position.top_right)",
            "[position.middle_left](#const_position.middle_left)",
            "[position.middle_center](#const_position.middle_center)",
            "[position.bottom_left](#const_position.bottom_left)",
            "[position.bottom_center](#const_position.bottom_center)",
            "[position.bottom_right](#const_position.bottom_right)"
          ],
          "displayType": "const string"
        },
        {
          "name": "position.bottom_left",
          "kind": "Built-in Constant",
          "desc": "Table position is used in [table.new](#fun_table.new), [table.cell](#fun_table.cell) functions.\nBinds the table to the bottom left of the screen.",
          "type": "string",
          "seeAlso": [
            "[table.new](#fun_table.new)",
            "[table.cell](#fun_table.cell)",
            "[table.set_position](#fun_table.set_position)",
            "[position.top_left](#const_position.top_left)",
            "[position.top_center](#const_position.top_center)",
            "[position.top_right](#const_position.top_right)",
            "[position.middle_left](#const_position.middle_left)",
            "[position.middle_center](#const_position.middle_center)",
            "[position.middle_right](#const_position.middle_right)",
            "[position.bottom_center](#const_position.bottom_center)",
            "[position.bottom_right](#const_position.bottom_right)"
          ],
          "displayType": "const string"
        },
        {
          "name": "position.bottom_center",
          "kind": "Built-in Constant",
          "desc": "Table position is used in [table.new](#fun_table.new), [table.cell](#fun_table.cell) functions.\nBinds the table to the bottom edge in the center.",
          "type": "string",
          "seeAlso": [
            "[table.new](#fun_table.new)",
            "[table.cell](#fun_table.cell)",
            "[table.set_position](#fun_table.set_position)",
            "[position.top_left](#const_position.top_left)",
            "[position.top_center](#const_position.top_center)",
            "[position.top_right](#const_position.top_right)",
            "[position.middle_left](#const_position.middle_left)",
            "[position.middle_center](#const_position.middle_center)",
            "[position.middle_right](#const_position.middle_right)",
            "[position.bottom_left](#const_position.bottom_left)",
            "[position.bottom_right](#const_position.bottom_right)"
          ],
          "displayType": "const string"
        },
        {
          "name": "position.bottom_right",
          "kind": "Built-in Constant",
          "desc": "Table position is used in [table.new](#fun_table.new), [table.cell](#fun_table.cell) functions.\nBinds the table to the bottom right of the screen.",
          "type": "string",
          "seeAlso": [
            "[table.new](#fun_table.new)",
            "[table.cell](#fun_table.cell)",
            "[table.set_position](#fun_table.set_position)",
            "[position.top_left](#const_position.top_left)",
            "[position.top_center](#const_position.top_center)",
            "[position.top_right](#const_position.top_right)",
            "[position.middle_left](#const_position.middle_left)",
            "[position.middle_center](#const_position.middle_center)",
            "[position.middle_right](#const_position.middle_right)",
            "[position.bottom_left](#const_position.bottom_left)",
            "[position.bottom_center](#const_position.bottom_center)"
          ],
          "displayType": "const string"
        },
        {
          "name": "size.auto",
          "kind": "Built-in Constant",
          "desc": "Size value for [plotshape](#fun_plotshape), [plotchar](#fun_plotchar) functions.  \nThe size of the shape automatically adapts to the size of the bars.",
          "type": "string",
          "seeAlso": [
            "[plotshape](#fun_plotshape)",
            "[plotchar](#fun_plotchar)",
            "[label.set_size](#fun_label.set_size)",
            "[size.tiny](#const_size.tiny)",
            "[size.small](#const_size.small)",
            "[size.normal](#const_size.normal)",
            "[size.large](#const_size.large)",
            "[size.huge](#const_size.huge)"
          ],
          "displayType": "const string"
        },
        {
          "name": "size.tiny",
          "kind": "Built-in Constant",
          "desc": "Size value for [plotshape](#fun_plotshape), [plotchar](#fun_plotchar) functions.  \nThe size of the shape constantly tiny.",
          "type": "string",
          "seeAlso": [
            "[plotshape](#fun_plotshape)",
            "[plotchar](#fun_plotchar)",
            "[label.set_size](#fun_label.set_size)",
            "[size.auto](#const_size.auto)",
            "[size.small](#const_size.small)",
            "[size.normal](#const_size.normal)",
            "[size.large](#const_size.large)",
            "[size.huge](#const_size.huge)"
          ],
          "displayType": "const string"
        },
        {
          "name": "size.small",
          "kind": "Built-in Constant",
          "desc": "Size value for [plotshape](#fun_plotshape), [plotchar](#fun_plotchar) functions.  \nThe size of the shape constantly small.",
          "type": "string",
          "seeAlso": [
            "[plotshape](#fun_plotshape)",
            "[plotchar](#fun_plotchar)",
            "[label.set_size](#fun_label.set_size)",
            "[size.auto](#const_size.auto)",
            "[size.tiny](#const_size.tiny)",
            "[size.normal](#const_size.normal)",
            "[size.large](#const_size.large)",
            "[size.huge](#const_size.huge)"
          ],
          "displayType": "const string"
        },
        {
          "name": "size.normal",
          "kind": "Built-in Constant",
          "desc": "Size value for [plotshape](#fun_plotshape), [plotchar](#fun_plotchar) functions.  \nThe size of the shape constantly normal.",
          "type": "string",
          "seeAlso": [
            "[plotshape](#fun_plotshape)",
            "[plotchar](#fun_plotchar)",
            "[label.set_size](#fun_label.set_size)",
            "[size.auto](#const_size.auto)",
            "[size.tiny](#const_size.tiny)",
            "[size.small](#const_size.small)",
            "[size.large](#const_size.large)",
            "[size.huge](#const_size.huge)"
          ],
          "displayType": "const string"
        },
        {
          "name": "size.large",
          "kind": "Built-in Constant",
          "desc": "Size value for [plotshape](#fun_plotshape), [plotchar](#fun_plotchar) functions.  \nThe size of the shape constantly large.",
          "type": "string",
          "seeAlso": [
            "[plotshape](#fun_plotshape)",
            "[plotchar](#fun_plotchar)",
            "[label.set_size](#fun_label.set_size)",
            "[size.auto](#const_size.auto)",
            "[size.tiny](#const_size.tiny)",
            "[size.small](#const_size.small)",
            "[size.normal](#const_size.normal)",
            "[size.huge](#const_size.huge)"
          ],
          "displayType": "const string"
        },
        {
          "name": "size.huge",
          "kind": "Built-in Constant",
          "desc": "Size value for [plotshape](#fun_plotshape), [plotchar](#fun_plotchar) functions.  \nThe size of the shape constantly huge.",
          "type": "string",
          "seeAlso": [
            "[plotshape](#fun_plotshape)",
            "[plotchar](#fun_plotchar)",
            "[label.set_size](#fun_label.set_size)",
            "[size.auto](#const_size.auto)",
            "[size.tiny](#const_size.tiny)",
            "[size.small](#const_size.small)",
            "[size.normal](#const_size.normal)",
            "[size.large](#const_size.large)"
          ],
          "displayType": "const string"
        },
        {
          "name": "plot.style_line",
          "kind": "Built-in Constant",
          "desc": "A named constant for the 'Line' style, to be used as an argument for the `style` parameter in the [plot](#fun_plot) function.",
          "type": "plot_style",
          "seeAlso": [
            "[plot](#fun_plot)",
            "[plot.style_steplinebr](#const_plot.style_steplinebr)",
            "[plot.style_linebr](#const_plot.style_linebr)",
            "[plot.style_stepline](#const_plot.style_stepline)",
            "[plot.style_stepline_diamond](#const_plot.style_stepline_diamond)",
            "[plot.style_histogram](#const_plot.style_histogram)",
            "[plot.style_cross](#const_plot.style_cross)",
            "[plot.style_area](#const_plot.style_area)",
            "[plot.style_areabr](#const_plot.style_areabr)",
            "[plot.style_columns](#const_plot.style_columns)",
            "[plot.style_circles](#const_plot.style_circles)"
          ],
          "displayType": "const plot_style"
        },
        {
          "name": "plot.style_linebr",
          "kind": "Built-in Constant",
          "desc": "A named constant for the 'Line With Breaks' style, to be used as an argument for the `style` parameter in the [plot](#fun_plot) function.  \nSimilar to [plot.style_line](#var_plot.style_line), except the gaps in the data are not filled.",
          "type": "plot_style",
          "seeAlso": [
            "[plot](#fun_plot)",
            "[plot.style_steplinebr](#const_plot.style_steplinebr)",
            "[plot.style_line](#const_plot.style_line)",
            "[plot.style_stepline](#const_plot.style_stepline)",
            "[plot.style_stepline_diamond](#const_plot.style_stepline_diamond)",
            "[plot.style_histogram](#const_plot.style_histogram)",
            "[plot.style_cross](#const_plot.style_cross)",
            "[plot.style_area](#const_plot.style_area)",
            "[plot.style_areabr](#const_plot.style_areabr)",
            "[plot.style_columns](#const_plot.style_columns)",
            "[plot.style_circles](#const_plot.style_circles)"
          ],
          "displayType": "const plot_style"
        },
        {
          "name": "plot.style_stepline",
          "kind": "Built-in Constant",
          "desc": "A named constant for the 'Step Line' style, to be used as an argument for the `style` parameter in the [plot](#fun_plot) function.",
          "type": "plot_style",
          "seeAlso": [
            "[plot](#fun_plot)",
            "[plot.style_line](#const_plot.style_line)",
            "[plot.style_steplinebr](#const_plot.style_steplinebr)",
            "[plot.style_stepline_diamond](#const_plot.style_stepline_diamond)",
            "[plot.style_linebr](#const_plot.style_linebr)",
            "[plot.style_histogram](#const_plot.style_histogram)",
            "[plot.style_cross](#const_plot.style_cross)",
            "[plot.style_area](#const_plot.style_area)",
            "[plot.style_areabr](#const_plot.style_areabr)",
            "[plot.style_columns](#const_plot.style_columns)",
            "[plot.style_circles](#const_plot.style_circles)"
          ],
          "displayType": "const plot_style"
        },
        {
          "name": "plot.style_stepline_diamond",
          "kind": "Built-in Constant",
          "desc": "A named constant for the 'Step Line With Diamonds' style, to be used as an argument for the `style` parameter in the [plot](#fun_plot) function.  \nSimilar to [plot.style_stepline](#var_plot.style_stepline), except the data changes are also marked with the Diamond shapes.",
          "type": "plot_style",
          "seeAlso": [
            "[plot](#fun_plot)",
            "[plot.style_steplinebr](#const_plot.style_steplinebr)",
            "[plot.style_line](#const_plot.style_line)",
            "[plot.style_linebr](#const_plot.style_linebr)",
            "[plot.style_histogram](#const_plot.style_histogram)",
            "[plot.style_cross](#const_plot.style_cross)",
            "[plot.style_area](#const_plot.style_area)",
            "[plot.style_areabr](#const_plot.style_areabr)",
            "[plot.style_columns](#const_plot.style_columns)",
            "[plot.style_circles](#const_plot.style_circles)"
          ],
          "displayType": "const plot_style"
        },
        {
          "name": "plot.style_histogram",
          "kind": "Built-in Constant",
          "desc": "A named constant for the 'Histogram' style, to be used as an argument for the `style` parameter in the [plot](#fun_plot) function.",
          "type": "plot_style",
          "seeAlso": [
            "[plot](#fun_plot)",
            "[plot.style_steplinebr](#const_plot.style_steplinebr)",
            "[plot.style_line](#const_plot.style_line)",
            "[plot.style_linebr](#const_plot.style_linebr)",
            "[plot.style_stepline](#const_plot.style_stepline)",
            "[plot.style_stepline_diamond](#const_plot.style_stepline_diamond)",
            "[plot.style_cross](#const_plot.style_cross)",
            "[plot.style_area](#const_plot.style_area)",
            "[plot.style_areabr](#const_plot.style_areabr)",
            "[plot.style_columns](#const_plot.style_columns)",
            "[plot.style_circles](#const_plot.style_circles)"
          ],
          "displayType": "const plot_style"
        },
        {
          "name": "plot.style_cross",
          "kind": "Built-in Constant",
          "desc": "A named constant for the 'Cross' style, to be used as an argument for the `style` parameter in the [plot](#fun_plot) function.",
          "type": "plot_style",
          "seeAlso": [
            "[plot](#fun_plot)",
            "[plot.style_steplinebr](#const_plot.style_steplinebr)",
            "[plot.style_line](#const_plot.style_line)",
            "[plot.style_linebr](#const_plot.style_linebr)",
            "[plot.style_stepline](#const_plot.style_stepline)",
            "[plot.style_stepline_diamond](#const_plot.style_stepline_diamond)",
            "[plot.style_histogram](#const_plot.style_histogram)",
            "[plot.style_area](#const_plot.style_area)",
            "[plot.style_areabr](#const_plot.style_areabr)",
            "[plot.style_columns](#const_plot.style_columns)",
            "[plot.style_circles](#const_plot.style_circles)"
          ],
          "displayType": "const plot_style"
        },
        {
          "name": "plot.style_area",
          "kind": "Built-in Constant",
          "desc": "A named constant for the 'Area' style, to be used as an argument for the `style` parameter in the [plot](#fun_plot) function.",
          "type": "plot_style",
          "seeAlso": [
            "[plot](#fun_plot)",
            "[plot.style_steplinebr](#const_plot.style_steplinebr)",
            "[plot.style_line](#const_plot.style_line)",
            "[plot.style_linebr](#const_plot.style_linebr)",
            "[plot.style_stepline](#const_plot.style_stepline)",
            "[plot.style_stepline_diamond](#const_plot.style_stepline_diamond)",
            "[plot.style_histogram](#const_plot.style_histogram)",
            "[plot.style_areabr](#const_plot.style_areabr)",
            "[plot.style_cross](#const_plot.style_cross)",
            "[plot.style_columns](#const_plot.style_columns)",
            "[plot.style_circles](#const_plot.style_circles)"
          ],
          "displayType": "const plot_style"
        },
        {
          "name": "plot.style_areabr",
          "kind": "Built-in Constant",
          "desc": "A named constant for the 'Area With Breaks' style, to be used as an argument for the `style` parameter in the [plot](#fun_plot) function.  \nSimilar to [plot.style_area](#var_plot.style_area), except the gaps in the data are not filled.",
          "type": "plot_style",
          "seeAlso": [
            "[plot](#fun_plot)",
            "[plot.style_steplinebr](#const_plot.style_steplinebr)",
            "[plot.style_line](#const_plot.style_line)",
            "[plot.style_linebr](#const_plot.style_linebr)",
            "[plot.style_stepline](#const_plot.style_stepline)",
            "[plot.style_stepline_diamond](#const_plot.style_stepline_diamond)",
            "[plot.style_histogram](#const_plot.style_histogram)",
            "[plot.style_cross](#const_plot.style_cross)",
            "[plot.style_area](#const_plot.style_area)",
            "[plot.style_columns](#const_plot.style_columns)",
            "[plot.style_circles](#const_plot.style_circles)"
          ],
          "displayType": "const plot_style"
        },
        {
          "name": "plot.style_columns",
          "kind": "Built-in Constant",
          "desc": "A named constant for the 'Columns' style, to be used as an argument for the `style` parameter in the [plot](#fun_plot) function.",
          "type": "plot_style",
          "seeAlso": [
            "[plot](#fun_plot)",
            "[plot.style_steplinebr](#const_plot.style_steplinebr)",
            "[plot.style_line](#const_plot.style_line)",
            "[plot.style_linebr](#const_plot.style_linebr)",
            "[plot.style_stepline](#const_plot.style_stepline)",
            "[plot.style_stepline_diamond](#const_plot.style_stepline_diamond)",
            "[plot.style_histogram](#const_plot.style_histogram)",
            "[plot.style_cross](#const_plot.style_cross)",
            "[plot.style_area](#const_plot.style_area)",
            "[plot.style_areabr](#const_plot.style_areabr)",
            "[plot.style_circles](#const_plot.style_circles)"
          ],
          "displayType": "const plot_style"
        },
        {
          "name": "plot.style_circles",
          "kind": "Built-in Constant",
          "desc": "A named constant for the 'Circles' style, to be used as an argument for the `style` parameter in the [plot](#fun_plot) function.",
          "type": "plot_style",
          "seeAlso": [
            "[plot](#fun_plot)",
            "[plot.style_steplinebr](#const_plot.style_steplinebr)",
            "[plot.style_line](#const_plot.style_line)",
            "[plot.style_linebr](#const_plot.style_linebr)",
            "[plot.style_stepline](#const_plot.style_stepline)",
            "[plot.style_stepline_diamond](#const_plot.style_stepline_diamond)",
            "[plot.style_histogram](#const_plot.style_histogram)",
            "[plot.style_cross](#const_plot.style_cross)",
            "[plot.style_area](#const_plot.style_area)",
            "[plot.style_areabr](#const_plot.style_areabr)",
            "[plot.style_columns](#const_plot.style_columns)"
          ],
          "displayType": "const plot_style"
        },
        {
          "name": "plot.style_steplinebr",
          "kind": "Built-in Constant",
          "desc": "A named constant for the 'Step line with Breaks' style, to be used as an argument for the `style` parameter in the [plot](#fun_plot) function.",
          "type": "plot_style",
          "seeAlso": [
            "[plot](#fun_plot)",
            "[plot.style_circles](#const_plot.style_circles)",
            "[plot.style_line](#const_plot.style_line)",
            "[plot.style_linebr](#const_plot.style_linebr)",
            "[plot.style_stepline](#const_plot.style_stepline)",
            "[plot.style_stepline_diamond](#const_plot.style_stepline_diamond)",
            "[plot.style_histogram](#const_plot.style_histogram)",
            "[plot.style_cross](#const_plot.style_cross)",
            "[plot.style_area](#const_plot.style_area)",
            "[plot.style_areabr](#const_plot.style_areabr)",
            "[plot.style_columns](#const_plot.style_columns)"
          ],
          "displayType": "const plot_style"
        },
        {
          "name": "format.inherit",
          "kind": "Built-in Constant",
          "desc": "Is a named constant for selecting the formatting of the script output values from the parent series in the [indicator](#fun_indicator) function.",
          "type": "string",
          "seeAlso": [
            "[indicator](#fun_indicator)",
            "[format.price](#const_format.price)",
            "[format.volume](#const_format.volume)",
            "[format.percent](#const_format.percent)"
          ],
          "displayType": "const string"
        },
        {
          "name": "format.price",
          "kind": "Built-in Constant",
          "desc": "Is a named constant for selecting the formatting of the script output values as prices in the [indicator](#fun_indicator) function.",
          "type": "string",
          "remarks": "If format is format.price, default precision value is set. You can use the precision argument of indicator function to change the precision value.",
          "seeAlso": [
            "[indicator](#fun_indicator)",
            "[format.inherit](#const_format.inherit)",
            "[format.volume](#const_format.volume)",
            "[format.percent](#const_format.percent)"
          ],
          "displayType": "const string"
        },
        {
          "name": "format.volume",
          "kind": "Built-in Constant",
          "desc": "Is a named constant for selecting the formatting of the script output values as volume in the [indicator](#fun_indicator) function, e.g. '5183' will be formatted as '5.183K'.",
          "type": "string",
          "seeAlso": [
            "[indicator](#fun_indicator)",
            "[format.inherit](#const_format.inherit)",
            "[format.price](#const_format.price)",
            "[format.percent](#const_format.percent)"
          ],
          "displayType": "const string"
        },
        {
          "name": "format.percent",
          "kind": "Built-in Constant",
          "desc": "Is a named constant for selecting the formatting of the script output values as a percentage in the indicator function. It adds a percent sign after values.",
          "type": "string",
          "remarks": "The default precision is 2, regardless of the precision of the chart itself. This can be changed with the 'precision' argument of the [indicator](#fun_indicator) function.",
          "seeAlso": [
            "[indicator](#fun_indicator)",
            "[format.inherit](#const_format.inherit)",
            "[format.price](#const_format.price)",
            "[format.volume](#const_format.volume)"
          ],
          "displayType": "const string"
        },
        {
          "name": "format.mintick",
          "kind": "Built-in Constant",
          "desc": "Is a named constant to use with the [str.tostring](#fun_str.tostring) function.  \nPassing a number to [str.tostring](#fun_str.tostring) with this argument rounds the number to the nearest value that can be divided by [syminfo.mintick](#var_syminfo.mintick), without the remainder, with ties rounding up, and returns the string version of said value with trailing zeroes.",
          "type": "string",
          "seeAlso": [
            "[indicator](#fun_indicator)",
            "[format.inherit](#const_format.inherit)",
            "[format.price](#const_format.price)",
            "[format.volume](#const_format.volume)"
          ],
          "displayType": "const string"
        },
        {
          "name": "dayofweek.sunday",
          "kind": "Built-in Constant",
          "desc": "Is a named constant for return value of [dayofweek](#fun_dayofweek) function and value of [dayofweek](#var_dayofweek) variable.",
          "type": "int",
          "seeAlso": [
            "[dayofweek.monday](#const_dayofweek.monday)",
            "[dayofweek.tuesday](#const_dayofweek.tuesday)",
            "[dayofweek.wednesday](#const_dayofweek.wednesday)",
            "[dayofweek.thursday](#const_dayofweek.thursday)",
            "[dayofweek.friday](#const_dayofweek.friday)",
            "[dayofweek.saturday](#const_dayofweek.saturday)"
          ],
          "displayType": "const int"
        },
        {
          "name": "dayofweek.monday",
          "kind": "Built-in Constant",
          "desc": "Is a named constant for return value of [dayofweek](#fun_dayofweek) function and value of [dayofweek](#var_dayofweek) variable.",
          "type": "int",
          "seeAlso": [
            "[dayofweek.sunday](#const_dayofweek.sunday)",
            "[dayofweek.tuesday](#const_dayofweek.tuesday)",
            "[dayofweek.wednesday](#const_dayofweek.wednesday)",
            "[dayofweek.thursday](#const_dayofweek.thursday)",
            "[dayofweek.friday](#const_dayofweek.friday)",
            "[dayofweek.saturday](#const_dayofweek.saturday)"
          ],
          "displayType": "const int"
        },
        {
          "name": "dayofweek.tuesday",
          "kind": "Built-in Constant",
          "desc": "Is a named constant for return value of [dayofweek](#fun_dayofweek) function and value of [dayofweek](#var_dayofweek) variable.",
          "type": "int",
          "seeAlso": [
            "[dayofweek.sunday](#const_dayofweek.sunday)",
            "[dayofweek.monday](#const_dayofweek.monday)",
            "[dayofweek.wednesday](#const_dayofweek.wednesday)",
            "[dayofweek.thursday](#const_dayofweek.thursday)",
            "[dayofweek.friday](#const_dayofweek.friday)",
            "[dayofweek.saturday](#const_dayofweek.saturday)"
          ],
          "displayType": "const int"
        },
        {
          "name": "dayofweek.wednesday",
          "kind": "Built-in Constant",
          "desc": "Is a named constant for return value of [dayofweek](#fun_dayofweek) function and value of [dayofweek](#var_dayofweek) variable.",
          "type": "int",
          "seeAlso": [
            "[dayofweek.sunday](#const_dayofweek.sunday)",
            "[dayofweek.monday](#const_dayofweek.monday)",
            "[dayofweek.tuesday](#const_dayofweek.tuesday)",
            "[dayofweek.thursday](#const_dayofweek.thursday)",
            "[dayofweek.friday](#const_dayofweek.friday)",
            "[dayofweek.saturday](#const_dayofweek.saturday)"
          ],
          "displayType": "const int"
        },
        {
          "name": "dayofweek.thursday",
          "kind": "Built-in Constant",
          "desc": "Is a named constant for return value of [dayofweek](#fun_dayofweek) function and value of [dayofweek](#var_dayofweek) variable.",
          "type": "int",
          "seeAlso": [
            "[dayofweek.sunday](#const_dayofweek.sunday)",
            "[dayofweek.monday](#const_dayofweek.monday)",
            "[dayofweek.tuesday](#const_dayofweek.tuesday)",
            "[dayofweek.wednesday](#const_dayofweek.wednesday)",
            "[dayofweek.friday](#const_dayofweek.friday)",
            "[dayofweek.saturday](#const_dayofweek.saturday)"
          ],
          "displayType": "const int"
        },
        {
          "name": "dayofweek.friday",
          "kind": "Built-in Constant",
          "desc": "Is a named constant for return value of [dayofweek](#fun_dayofweek) function and value of [dayofweek](#var_dayofweek) variable.",
          "type": "int",
          "seeAlso": [
            "[dayofweek.sunday](#const_dayofweek.sunday)",
            "[dayofweek.monday](#const_dayofweek.monday)",
            "[dayofweek.tuesday](#const_dayofweek.tuesday)",
            "[dayofweek.wednesday](#const_dayofweek.wednesday)",
            "[dayofweek.thursday](#const_dayofweek.thursday)",
            "[dayofweek.saturday](#const_dayofweek.saturday)"
          ],
          "displayType": "const int"
        },
        {
          "name": "dayofweek.saturday",
          "kind": "Built-in Constant",
          "desc": "Is a named constant for return value of [dayofweek](#fun_dayofweek) function and value of [dayofweek](#var_dayofweek) variable.",
          "type": "int",
          "seeAlso": [
            "[dayofweek.sunday](#const_dayofweek.sunday)",
            "[dayofweek.monday](#const_dayofweek.monday)",
            "[dayofweek.tuesday](#const_dayofweek.tuesday)",
            "[dayofweek.wednesday](#const_dayofweek.wednesday)",
            "[dayofweek.thursday](#const_dayofweek.thursday)",
            "[dayofweek.friday](#const_dayofweek.friday)"
          ],
          "displayType": "const int"
        },
        {
          "name": "shape.xcross",
          "kind": "Built-in Constant",
          "desc": "Shape style for [plotshape](#fun_plotshape) function.",
          "type": "string",
          "seeAlso": [
            "[plotshape](#fun_plotshape)"
          ],
          "displayType": "const string"
        },
        {
          "name": "shape.cross",
          "kind": "Built-in Constant",
          "desc": "Shape style for [plotshape](#fun_plotshape) function.",
          "type": "string",
          "seeAlso": [
            "[plotshape](#fun_plotshape)"
          ],
          "displayType": "const string"
        },
        {
          "name": "shape.circle",
          "kind": "Built-in Constant",
          "desc": "Shape style for [plotshape](#fun_plotshape) function.",
          "type": "string",
          "seeAlso": [
            "[plotshape](#fun_plotshape)"
          ],
          "displayType": "const string"
        },
        {
          "name": "shape.triangleup",
          "kind": "Built-in Constant",
          "desc": "Shape style for [plotshape](#fun_plotshape) function.",
          "type": "string",
          "seeAlso": [
            "[plotshape](#fun_plotshape)"
          ],
          "displayType": "const string"
        },
        {
          "name": "shape.triangledown",
          "kind": "Built-in Constant",
          "desc": "Shape style for [plotshape](#fun_plotshape) function.",
          "type": "string",
          "seeAlso": [
            "[plotshape](#fun_plotshape)"
          ],
          "displayType": "const string"
        },
        {
          "name": "shape.flag",
          "kind": "Built-in Constant",
          "desc": "Shape style for [plotshape](#fun_plotshape) function.",
          "type": "string",
          "seeAlso": [
            "[plotshape](#fun_plotshape)"
          ],
          "displayType": "const string"
        },
        {
          "name": "shape.arrowup",
          "kind": "Built-in Constant",
          "desc": "Shape style for [plotshape](#fun_plotshape) function.",
          "type": "string",
          "seeAlso": [
            "[plotshape](#fun_plotshape)"
          ],
          "displayType": "const string"
        },
        {
          "name": "shape.arrowdown",
          "kind": "Built-in Constant",
          "desc": "Shape style for [plotshape](#fun_plotshape) function.",
          "type": "string",
          "seeAlso": [
            "[plotshape](#fun_plotshape)"
          ],
          "displayType": "const string"
        },
        {
          "name": "shape.labelup",
          "kind": "Built-in Constant",
          "desc": "Shape style for [plotshape](#fun_plotshape) function.",
          "type": "string",
          "seeAlso": [
            "[plotshape](#fun_plotshape)"
          ],
          "displayType": "const string"
        },
        {
          "name": "shape.labeldown",
          "kind": "Built-in Constant",
          "desc": "Shape style for [plotshape](#fun_plotshape) function.",
          "type": "string",
          "seeAlso": [
            "[plotshape](#fun_plotshape)"
          ],
          "displayType": "const string"
        },
        {
          "name": "shape.square",
          "kind": "Built-in Constant",
          "desc": "Shape style for [plotshape](#fun_plotshape) function.",
          "type": "string",
          "seeAlso": [
            "[plotshape](#fun_plotshape)"
          ],
          "displayType": "const string"
        },
        {
          "name": "shape.diamond",
          "kind": "Built-in Constant",
          "desc": "Shape style for [plotshape](#fun_plotshape) function.",
          "type": "string",
          "seeAlso": [
            "[plotshape](#fun_plotshape)"
          ],
          "displayType": "const string"
        },
        {
          "name": "location.abovebar",
          "kind": "Built-in Constant",
          "desc": "Location value for [plotshape](#fun_plotshape), [plotchar](#fun_plotchar) functions.  \nShape is plotted above main series bars.",
          "type": "string",
          "seeAlso": [
            "[plotshape](#fun_plotshape)",
            "[plotchar](#fun_plotchar)",
            "[location.belowbar](#const_location.belowbar)",
            "[location.top](#const_location.top)",
            "[location.bottom](#const_location.bottom)",
            "[location.absolute](#const_location.absolute)"
          ],
          "displayType": "const string"
        },
        {
          "name": "location.belowbar",
          "kind": "Built-in Constant",
          "desc": "Location value for [plotshape](#fun_plotshape), [plotchar](#fun_plotchar) functions.  \nShape is plotted below main series bars.",
          "type": "string",
          "seeAlso": [
            "[plotshape](#fun_plotshape)",
            "[plotchar](#fun_plotchar)",
            "[location.abovebar](#const_location.abovebar)",
            "[location.top](#const_location.top)",
            "[location.bottom](#const_location.bottom)",
            "[location.absolute](#const_location.absolute)"
          ],
          "displayType": "const string"
        },
        {
          "name": "location.top",
          "kind": "Built-in Constant",
          "desc": "Location value for [plotshape](#fun_plotshape), [plotchar](#fun_plotchar) functions.  \nShape is plotted near the top chart border.",
          "type": "string",
          "seeAlso": [
            "[plotshape](#fun_plotshape)",
            "[plotchar](#fun_plotchar)",
            "[location.abovebar](#const_location.abovebar)",
            "[location.belowbar](#const_location.belowbar)",
            "[location.bottom](#const_location.bottom)",
            "[location.absolute](#const_location.absolute)"
          ],
          "displayType": "const string"
        },
        {
          "name": "location.bottom",
          "kind": "Built-in Constant",
          "desc": "Location value for [plotshape](#fun_plotshape), [plotchar](#fun_plotchar) functions.  \nShape is plotted near the bottom chart border.",
          "type": "string",
          "seeAlso": [
            "[plotshape](#fun_plotshape)",
            "[plotchar](#fun_plotchar)",
            "[location.abovebar](#const_location.abovebar)",
            "[location.belowbar](#const_location.belowbar)",
            "[location.top](#const_location.top)",
            "[location.absolute](#const_location.absolute)"
          ],
          "displayType": "const string"
        },
        {
          "name": "location.absolute",
          "kind": "Built-in Constant",
          "desc": "Location value for [plotshape](#fun_plotshape), [plotchar](#fun_plotchar) functions.  \nShape is plotted on chart using indicator value as a price coordinate.",
          "type": "string",
          "seeAlso": [
            "[plotshape](#fun_plotshape)",
            "[plotchar](#fun_plotchar)",
            "[location.abovebar](#const_location.abovebar)",
            "[location.belowbar](#const_location.belowbar)",
            "[location.top](#const_location.top)",
            "[location.bottom](#const_location.bottom)"
          ],
          "displayType": "const string"
        },
        {
          "name": "scale.right",
          "kind": "Built-in Constant",
          "desc": "Scale value for [indicator](#fun_indicator) function.  \nIndicator is added to the right price scale.",
          "type": "scale_type",
          "seeAlso": [
            "[indicator](#fun_indicator)"
          ],
          "displayType": "const scale_type"
        },
        {
          "name": "scale.left",
          "kind": "Built-in Constant",
          "desc": "Scale value for [indicator](#fun_indicator) function.  \nIndicator is added to the left price scale.",
          "type": "scale_type",
          "seeAlso": [
            "[indicator](#fun_indicator)"
          ],
          "displayType": "const scale_type"
        },
        {
          "name": "scale.none",
          "kind": "Built-in Constant",
          "desc": "Scale value for [indicator](#fun_indicator) function.  \nIndicator is added in 'No Scale' mode.  \nCan be used only with 'overlay=true'.",
          "type": "scale_type",
          "seeAlso": [
            "[indicator](#fun_indicator)"
          ],
          "displayType": "const scale_type"
        },
        {
          "name": "strategy.oca.none",
          "kind": "Built-in Constant",
          "desc": "OCA type value for strategy\\`s functions. The parameter determines that an order should not belong to any particular OCO group.",
          "type": "string",
          "seeAlso": [
            "[strategy.entry](#fun_strategy.entry)",
            "[strategy.exit](#fun_strategy.exit)",
            "[strategy.order](#fun_strategy.order)"
          ],
          "displayType": "const string"
        },
        {
          "name": "strategy.oca.cancel",
          "kind": "Built-in Constant",
          "desc": "OCA type value for strategy\\`s functions. The parameter determines that an order should belong to an OCO group, where as soon as an order is filled, all other orders of the same group are cancelled. Note: if more than 1 guaranteed-to-be-executed orders of the same OCA group are placed at once, all those orders are filled.",
          "type": "string",
          "seeAlso": [
            "[strategy.entry](#fun_strategy.entry)",
            "[strategy.exit](#fun_strategy.exit)",
            "[strategy.order](#fun_strategy.order)"
          ],
          "displayType": "const string"
        },
        {
          "name": "strategy.oca.reduce",
          "kind": "Built-in Constant",
          "desc": "OCA type value for strategy\\`s functions. The parameter determines that an order should belong to an OCO group, where if X number of contracts of an order is filled, number of contracts for each other order of the same OCO group is decreased by X. Note: if more than 1 guaranteed-to-be-executed orders of the same OCA group are placed at once, all those orders are filled.",
          "type": "string",
          "seeAlso": [
            "[strategy.entry](#fun_strategy.entry)",
            "[strategy.exit](#fun_strategy.exit)",
            "[strategy.order](#fun_strategy.order)"
          ],
          "displayType": "const string"
        },
        {
          "name": "strategy.commission.percent",
          "kind": "Built-in Constant",
          "desc": "Commission type for an order. A percentage of the cash volume of order.",
          "type": "string",
          "seeAlso": [
            "[strategy](#fun_strategy)"
          ],
          "displayType": "const string"
        },
        {
          "name": "strategy.commission.cash_per_contract",
          "kind": "Built-in Constant",
          "desc": "Commission type for an order. Money displayed in the account currency per contract.",
          "type": "string",
          "seeAlso": [
            "[strategy](#fun_strategy)"
          ],
          "displayType": "const string"
        },
        {
          "name": "strategy.commission.cash_per_order",
          "kind": "Built-in Constant",
          "desc": "Commission type for an order. Money displayed in the account currency per order.",
          "type": "string",
          "seeAlso": [
            "[strategy](#fun_strategy)"
          ],
          "displayType": "const string"
        },
        {
          "name": "strategy.fixed",
          "kind": "Built-in Constant",
          "desc": "This is one of the arguments that can be supplied to the `default_qty_type` parameter in the [strategy](#fun_strategy) declaration statement.  \nIt is only relevant when no value is used for the ‘qty’ parameter in [strategy.entry](#fun_strategy.entry) or [strategy.order](#fun_strategy.order) function calls.  \nIt specifies that a number of contracts/shares/lots will be used to enter trades.",
          "type": "string",
          "seeAlso": [
            "[strategy](#fun_strategy)"
          ],
          "examples": "//@version=5\nstrategy(\"strategy.fixed\", overlay = true, default_qty_value = 50, default_qty_type = strategy.fixed, initial_capital = 1000000)\n\nif bar_index == 0\n    // As ‘qty’ is not defined, the previously defined values for the `default_qty_type` and `default_qty_value` parameters are used to enter trades, namely 50 contracts.\n    // qty = 50\n    strategy.entry(\"EN\", strategy.long)\nif bar_index == 2\n    strategy.close(\"EN\")",
          "displayType": "const string"
        },
        {
          "name": "strategy.cash",
          "kind": "Built-in Constant",
          "desc": "This is one of the arguments that can be supplied to the `default_qty_type` parameter in the [strategy](#fun_strategy) declaration statement.  \nIt is only relevant when no value is used for the ‘qty’ parameter in [strategy.entry](#fun_strategy.entry) or [strategy.order](#fun_strategy.order) function calls.  \nIt specifies that an amount of cash in the `strategy.account_currency` will be used to enter trades.",
          "type": "string",
          "seeAlso": [
            "[strategy](#fun_strategy)"
          ],
          "examples": "//@version=5\nstrategy(\"strategy.cash\", overlay = true, default_qty_value = 50, default_qty_type = strategy.cash, initial_capital = 1000000)\n\nif bar_index == 0\n    // As ‘qty’ is not defined, the previously defined values for the `default_qty_type` and `default_qty_value` parameters are used to enter trades, namely 50 units of cash in the currency of `strategy.account_currency`.\n    // `qty` is calculated as (default_qty_value)/(close price). If current price is $5, then qty = 50/5 = 10.\n    strategy.entry(\"EN\", strategy.long)\nif bar_index == 2\n    strategy.close(\"EN\")",
          "displayType": "const string"
        },
        {
          "name": "strategy.percent_of_equity",
          "kind": "Built-in Constant",
          "desc": "This is one of the arguments that can be supplied to the `default_qty_type` parameter in the [strategy](#fun_strategy) declaration statement.  \nIt is only relevant when no value is used for the ‘qty’ parameter in [strategy.entry](#fun_strategy.entry) or [strategy.order](#fun_strategy.order) function calls.  \nIt specifies that a percentage (0-100) of equity will be used to enter trades.",
          "type": "string",
          "seeAlso": [
            "[strategy](#fun_strategy)"
          ],
          "examples": "//@version=5\nstrategy(\"strategy.percent_of_equity\", overlay = false, default_qty_value = 100, default_qty_type = strategy.percent_of_equity, initial_capital = 1000000)\n\n// As ‘qty’ is not defined, the previously defined values for the `default_qty_type` and `default_qty_value` parameters are used to enter trades, namely 100% of available equity.\nif bar_index == 0\n    strategy.entry(\"EN\", strategy.long)\nif bar_index == 2\n    strategy.close(\"EN\")\nplot(strategy.equity)\n\n // The ‘qty’ parameter is set to 10. Entering position with fixed size of 10 contracts and entry market price = (10 * close).\nif bar_index == 4\n    strategy.entry(\"EN\", strategy.long, qty = 10)\nif bar_index == 6\n    strategy.close(\"EN\")",
          "displayType": "const string"
        },
        {
          "name": "strategy.direction.all",
          "kind": "Built-in Constant",
          "desc": "It allows strategy to open both long and short positions.",
          "type": "string",
          "seeAlso": [
            "[strategy.risk.allow_entry_in](#fun_strategy.risk.allow_entry_in)"
          ],
          "displayType": "const string"
        },
        {
          "name": "strategy.direction.long",
          "kind": "Built-in Constant",
          "desc": "It allows strategy to open only long positions.",
          "type": "string",
          "seeAlso": [
            "[strategy.risk.allow_entry_in](#fun_strategy.risk.allow_entry_in)"
          ],
          "displayType": "const string"
        },
        {
          "name": "strategy.direction.short",
          "kind": "Built-in Constant",
          "desc": "It allows strategy to open only short positions.",
          "type": "string",
          "seeAlso": [
            "[strategy.risk.allow_entry_in](#fun_strategy.risk.allow_entry_in)"
          ],
          "displayType": "const string"
        },
        {
          "name": "currency.NONE",
          "kind": "Built-in Constant",
          "desc": "Unspecified currency.",
          "type": "string",
          "seeAlso": [
            "[strategy](#fun_strategy)"
          ],
          "displayType": "const string"
        },
        {
          "name": "currency.USD",
          "kind": "Built-in Constant",
          "desc": "United States dollar.",
          "type": "string",
          "seeAlso": [
            "[strategy](#fun_strategy)"
          ],
          "displayType": "const string"
        },
        {
          "name": "currency.EUR",
          "kind": "Built-in Constant",
          "desc": "Euro.",
          "type": "string",
          "seeAlso": [
            "[strategy](#fun_strategy)"
          ],
          "displayType": "const string"
        },
        {
          "name": "currency.AUD",
          "kind": "Built-in Constant",
          "desc": "Australian dollar.",
          "type": "string",
          "seeAlso": [
            "[strategy](#fun_strategy)"
          ],
          "displayType": "const string"
        },
        {
          "name": "currency.GBP",
          "kind": "Built-in Constant",
          "desc": "Pound sterling.",
          "type": "string",
          "seeAlso": [
            "[strategy](#fun_strategy)"
          ],
          "displayType": "const string"
        },
        {
          "name": "currency.NZD",
          "kind": "Built-in Constant",
          "desc": "New Zealand dollar.",
          "type": "string",
          "seeAlso": [
            "[strategy](#fun_strategy)"
          ],
          "displayType": "const string"
        },
        {
          "name": "currency.CAD",
          "kind": "Built-in Constant",
          "desc": "Canadian dollar.",
          "type": "string",
          "seeAlso": [
            "[strategy](#fun_strategy)"
          ],
          "displayType": "const string"
        },
        {
          "name": "currency.CHF",
          "kind": "Built-in Constant",
          "desc": "Swiss franc.",
          "type": "string",
          "seeAlso": [
            "[strategy](#fun_strategy)"
          ],
          "displayType": "const string"
        },
        {
          "name": "currency.HKD",
          "kind": "Built-in Constant",
          "desc": "Hong Kong dollar.",
          "type": "string",
          "seeAlso": [
            "[strategy](#fun_strategy)"
          ],
          "displayType": "const string"
        },
        {
          "name": "currency.JPY",
          "kind": "Built-in Constant",
          "desc": "Japanese yen.",
          "type": "string",
          "seeAlso": [
            "[strategy](#fun_strategy)"
          ],
          "displayType": "const string"
        },
        {
          "name": "currency.NOK",
          "kind": "Built-in Constant",
          "desc": "Norwegian krone.",
          "type": "string",
          "seeAlso": [
            "[strategy](#fun_strategy)"
          ],
          "displayType": "const string"
        },
        {
          "name": "currency.SEK",
          "kind": "Built-in Constant",
          "desc": "Swedish krona.",
          "type": "string",
          "seeAlso": [
            "[strategy](#fun_strategy)"
          ],
          "displayType": "const string"
        },
        {
          "name": "currency.SGD",
          "kind": "Built-in Constant",
          "desc": "Singapore dollar.",
          "type": "string",
          "seeAlso": [
            "[strategy](#fun_strategy)"
          ],
          "displayType": "const string"
        },
        {
          "name": "currency.TRY",
          "kind": "Built-in Constant",
          "desc": "Turkish lira.",
          "type": "string",
          "seeAlso": [
            "[strategy](#fun_strategy)"
          ],
          "displayType": "const string"
        },
        {
          "name": "currency.ZAR",
          "kind": "Built-in Constant",
          "desc": "South African rand.",
          "type": "string",
          "seeAlso": [
            "[strategy](#fun_strategy)"
          ],
          "displayType": "const string"
        },
        {
          "name": "currency.RUB",
          "kind": "Built-in Constant",
          "desc": "Russian ruble.",
          "type": "string",
          "seeAlso": [
            "[strategy](#fun_strategy)"
          ],
          "displayType": "const string"
        },
        {
          "name": "currency.BTC",
          "kind": "Built-in Constant",
          "desc": "Bitcoin.",
          "type": "string",
          "seeAlso": [
            "[strategy](#fun_strategy)"
          ],
          "displayType": "const string"
        },
        {
          "name": "currency.ETH",
          "kind": "Built-in Constant",
          "desc": "Ethereum.",
          "type": "string",
          "seeAlso": [
            "[strategy](#fun_strategy)"
          ],
          "displayType": "const string"
        },
        {
          "name": "currency.MYR",
          "kind": "Built-in Constant",
          "desc": "Malaysian ringgit.",
          "type": "string",
          "seeAlso": [
            "[strategy](#fun_strategy)"
          ],
          "displayType": "const string"
        },
        {
          "name": "currency.KRW",
          "kind": "Built-in Constant",
          "desc": "South Korean won.",
          "type": "string",
          "seeAlso": [
            "[strategy](#fun_strategy)"
          ],
          "displayType": "const string"
        },
        {
          "name": "currency.USDT",
          "kind": "Built-in Constant",
          "desc": "Tether.",
          "type": "string",
          "seeAlso": [
            "[strategy](#fun_strategy)"
          ],
          "displayType": "const string"
        },
        {
          "name": "currency.INR",
          "kind": "Built-in Constant",
          "desc": "Indian rupee.",
          "type": "string",
          "seeAlso": [
            "[strategy](#fun_strategy)"
          ],
          "displayType": "const string"
        },
        {
          "name": "barmerge.lookahead_off",
          "kind": "Built-in Constant",
          "desc": "Merge strategy for the requested data position. Requested barset is merged with current barset in the order of sorting bars by their close time. This merge strategy disables effect of getting data from \"future\" on calculation on history.",
          "type": "barmerge_lookahead",
          "seeAlso": [
            "[request.security](#fun_request.security)",
            "[barmerge.lookahead_on](#const_barmerge.lookahead_on)"
          ],
          "displayType": "const barmerge_lookahead"
        },
        {
          "name": "barmerge.lookahead_on",
          "kind": "Built-in Constant",
          "desc": "Merge strategy for the requested data position. Requested barset is merged with current barset in the order of sorting bars by their opening time. This merge strategy can lead to undesirable effect of getting data from \"future\" on calculation on history. This is unacceptable in backtesting strategies, but can be useful in indicators.",
          "type": "barmerge_lookahead",
          "seeAlso": [
            "[request.security](#fun_request.security)",
            "[barmerge.lookahead_off](#const_barmerge.lookahead_off)"
          ],
          "displayType": "const barmerge_lookahead"
        },
        {
          "name": "barmerge.gaps_off",
          "kind": "Built-in Constant",
          "desc": "Merge strategy for requested data. Data is merged continuously without gaps, all the gaps are filled with the previous nearest existing value.",
          "type": "barmerge_gaps",
          "seeAlso": [
            "[request.security](#fun_request.security)",
            "[barmerge.gaps_on](#const_barmerge.gaps_on)"
          ],
          "displayType": "const barmerge_gaps"
        },
        {
          "name": "barmerge.gaps_on",
          "kind": "Built-in Constant",
          "desc": "Merge strategy for requested data. Data is merged with possible gaps ([na](#var_na) values).",
          "type": "barmerge_gaps",
          "seeAlso": [
            "[request.security](#fun_request.security)",
            "[barmerge.gaps_off](#const_barmerge.gaps_off)"
          ],
          "displayType": "const barmerge_gaps"
        },
        {
          "name": "xloc.bar_index",
          "kind": "Built-in Constant",
          "desc": "A named constant that specifies the algorithm of interpretation of x-value in functions [line.new](#fun_line.new) and [label.new](#fun_label.new).  \nIf xloc = [xloc.bar_index](#var_xloc.bar_index), value of x is a bar index.",
          "type": "string",
          "seeAlso": [
            "[line.new](#fun_line.new)",
            "[label.new](#fun_label.new)",
            "[line.set_xloc](#fun_line.set_xloc)",
            "[label.set_xloc](#fun_label.set_xloc)",
            "[xloc.bar_time](#const_xloc.bar_time)"
          ],
          "displayType": "const string"
        },
        {
          "name": "xloc.bar_time",
          "kind": "Built-in Constant",
          "desc": "A named constant that specifies the algorithm of interpretation of x-value in functions [line.new](#fun_line.new) and [label.new](#fun_label.new).  \nIf xloc = [xloc.bar_time](#var_xloc.bar_time), value of x is a bar UNIX time.",
          "type": "string",
          "seeAlso": [
            "[line.new](#fun_line.new)",
            "[label.new](#fun_label.new)",
            "[line.set_xloc](#fun_line.set_xloc)",
            "[label.set_xloc](#fun_label.set_xloc)",
            "[xloc.bar_index](#const_xloc.bar_index)"
          ],
          "displayType": "const string"
        },
        {
          "name": "yloc.price",
          "kind": "Built-in Constant",
          "desc": "A named constant that specifies the algorithm of interpretation of y-value in function [label.new](#fun_label.new).",
          "type": "string",
          "seeAlso": [
            "[label.new](#fun_label.new)",
            "[label.set_yloc](#fun_label.set_yloc)",
            "[yloc.abovebar](#const_yloc.abovebar)",
            "[yloc.belowbar](#const_yloc.belowbar)"
          ],
          "displayType": "const string"
        },
        {
          "name": "yloc.abovebar",
          "kind": "Built-in Constant",
          "desc": "A named constant that specifies the algorithm of interpretation of y-value in function [label.new](#fun_label.new).",
          "type": "string",
          "seeAlso": [
            "[label.new](#fun_label.new)",
            "[label.set_yloc](#fun_label.set_yloc)",
            "[yloc.price](#const_yloc.price)",
            "[yloc.belowbar](#const_yloc.belowbar)"
          ],
          "displayType": "const string"
        },
        {
          "name": "yloc.belowbar",
          "kind": "Built-in Constant",
          "desc": "A named constant that specifies the algorithm of interpretation of y-value in function [label.new](#fun_label.new).",
          "type": "string",
          "seeAlso": [
            "[label.new](#fun_label.new)",
            "[label.set_yloc](#fun_label.set_yloc)",
            "[yloc.price](#const_yloc.price)",
            "[yloc.abovebar](#const_yloc.abovebar)"
          ],
          "displayType": "const string"
        },
        {
          "name": "extend.none",
          "kind": "Built-in Constant",
          "desc": "A named constant for [line.new](#fun_line.new) and [line.set_extend](#fun_line.set_extend) functions.",
          "type": "string",
          "seeAlso": [
            "[line.new](#fun_line.new)",
            "[line.set_extend](#fun_line.set_extend)",
            "[extend.left](#const_extend.left)",
            "[extend.right](#const_extend.right)",
            "[extend.both](#const_extend.both)"
          ],
          "displayType": "const string"
        },
        {
          "name": "extend.left",
          "kind": "Built-in Constant",
          "desc": "A named constant for [line.new](#fun_line.new) and [line.set_extend](#fun_line.set_extend) functions.",
          "type": "string",
          "seeAlso": [
            "[line.new](#fun_line.new)",
            "[line.set_extend](#fun_line.set_extend)",
            "[extend.none](#const_extend.none)",
            "[extend.right](#const_extend.right)",
            "[extend.both](#const_extend.both)"
          ],
          "displayType": "const string"
        },
        {
          "name": "extend.right",
          "kind": "Built-in Constant",
          "desc": "A named constant for [line.new](#fun_line.new) and [line.set_extend](#fun_line.set_extend) functions.",
          "type": "string",
          "seeAlso": [
            "[line.new](#fun_line.new)",
            "[line.set_extend](#fun_line.set_extend)",
            "[extend.none](#const_extend.none)",
            "[extend.left](#const_extend.left)",
            "[extend.both](#const_extend.both)"
          ],
          "displayType": "const string"
        },
        {
          "name": "extend.both",
          "kind": "Built-in Constant",
          "desc": "A named constant for [line.new](#fun_line.new) and [line.set_extend](#fun_line.set_extend) functions.",
          "type": "string",
          "seeAlso": [
            "[line.new](#fun_line.new)",
            "[line.set_extend](#fun_line.set_extend)",
            "[extend.none](#const_extend.none)",
            "[extend.left](#const_extend.left)",
            "[extend.right](#const_extend.right)"
          ],
          "displayType": "const string"
        },
        {
          "name": "label.style_none",
          "kind": "Built-in Constant",
          "desc": "Label style for [label.new](#fun_label.new) and [label.set_style](#fun_label.set_style) functions.",
          "type": "string",
          "seeAlso": [
            "[label.new](#fun_label.new)",
            "[label.set_style](#fun_label.set_style)",
            "[label.set_textalign](#fun_label.set_textalign)",
            "[label.style_xcross](#const_label.style_xcross)",
            "[label.style_cross](#const_label.style_cross)",
            "[label.style_triangleup](#const_label.style_triangleup)",
            "[label.style_triangledown](#const_label.style_triangledown)",
            "[label.style_flag](#const_label.style_flag)",
            "[label.style_circle](#const_label.style_circle)",
            "[label.style_arrowup](#const_label.style_arrowup)",
            "[label.style_arrowdown](#const_label.style_arrowdown)",
            "[label.style_label_up](#const_label.style_label_up)",
            "[label.style_label_down](#const_label.style_label_down)",
            "[label.style_label_left](#const_label.style_label_left)",
            "[label.style_label_right](#const_label.style_label_right)",
            "[label.style_label_center](#const_label.style_label_center)",
            "[label.style_square](#const_label.style_square)",
            "[label.style_diamond](#const_label.style_diamond)"
          ],
          "displayType": "const string"
        },
        {
          "name": "label.style_xcross",
          "kind": "Built-in Constant",
          "desc": "Label style for [label.new](#fun_label.new) and [label.set_style](#fun_label.set_style) functions.",
          "type": "string",
          "seeAlso": [
            "[label.new](#fun_label.new)",
            "[label.set_style](#fun_label.set_style)",
            "[label.set_textalign](#fun_label.set_textalign)",
            "[label.style_none](#const_label.style_none)",
            "[label.style_cross](#const_label.style_cross)",
            "[label.style_triangleup](#const_label.style_triangleup)",
            "[label.style_triangledown](#const_label.style_triangledown)",
            "[label.style_flag](#const_label.style_flag)",
            "[label.style_circle](#const_label.style_circle)",
            "[label.style_arrowup](#const_label.style_arrowup)",
            "[label.style_arrowdown](#const_label.style_arrowdown)",
            "[label.style_label_up](#const_label.style_label_up)",
            "[label.style_label_down](#const_label.style_label_down)",
            "[label.style_label_left](#const_label.style_label_left)",
            "[label.style_label_right](#const_label.style_label_right)",
            "[label.style_label_center](#const_label.style_label_center)",
            "[label.style_square](#const_label.style_square)",
            "[label.style_diamond](#const_label.style_diamond)"
          ],
          "displayType": "const string"
        },
        {
          "name": "label.style_cross",
          "kind": "Built-in Constant",
          "desc": "Label style for [label.new](#fun_label.new) and [label.set_style](#fun_label.set_style) functions.",
          "type": "string",
          "seeAlso": [
            "[label.new](#fun_label.new)",
            "[label.set_style](#fun_label.set_style)",
            "[label.set_textalign](#fun_label.set_textalign)",
            "[label.style_none](#const_label.style_none)",
            "[label.style_xcross](#const_label.style_xcross)",
            "[label.style_triangleup](#const_label.style_triangleup)",
            "[label.style_triangledown](#const_label.style_triangledown)",
            "[label.style_flag](#const_label.style_flag)",
            "[label.style_circle](#const_label.style_circle)",
            "[label.style_arrowup](#const_label.style_arrowup)",
            "[label.style_arrowdown](#const_label.style_arrowdown)",
            "[label.style_label_up](#const_label.style_label_up)",
            "[label.style_label_down](#const_label.style_label_down)",
            "[label.style_label_left](#const_label.style_label_left)",
            "[label.style_label_right](#const_label.style_label_right)",
            "[label.style_label_lower_left](#const_label.style_label_lower_left)",
            "[label.style_label_lower_right](#const_label.style_label_lower_right)",
            "[label.style_label_upper_left](#const_label.style_label_upper_left)",
            "[label.style_label_upper_right](#const_label.style_label_upper_right)",
            "[label.style_label_center](#const_label.style_label_center)",
            "[label.style_square](#const_label.style_square)",
            "[label.style_diamond](#const_label.style_diamond)"
          ],
          "displayType": "const string"
        },
        {
          "name": "label.style_triangleup",
          "kind": "Built-in Constant",
          "desc": "Label style for [label.new](#fun_label.new) and [label.set_style](#fun_label.set_style) functions.",
          "type": "string",
          "seeAlso": [
            "[label.new](#fun_label.new)",
            "[label.set_style](#fun_label.set_style)",
            "[label.set_textalign](#fun_label.set_textalign)",
            "[label.style_none](#const_label.style_none)",
            "[label.style_xcross](#const_label.style_xcross)",
            "[label.style_cross](#const_label.style_cross)",
            "[label.style_triangledown](#const_label.style_triangledown)",
            "[label.style_flag](#const_label.style_flag)",
            "[label.style_circle](#const_label.style_circle)",
            "[label.style_arrowup](#const_label.style_arrowup)",
            "[label.style_arrowdown](#const_label.style_arrowdown)",
            "[label.style_label_up](#const_label.style_label_up)",
            "[label.style_label_down](#const_label.style_label_down)",
            "[label.style_label_left](#const_label.style_label_left)",
            "[label.style_label_right](#const_label.style_label_right)",
            "[label.style_label_lower_left](#const_label.style_label_lower_left)",
            "[label.style_label_lower_right](#const_label.style_label_lower_right)",
            "[label.style_label_upper_left](#const_label.style_label_upper_left)",
            "[label.style_label_upper_right](#const_label.style_label_upper_right)",
            "[label.style_label_center](#const_label.style_label_center)",
            "[label.style_square](#const_label.style_square)",
            "[label.style_diamond](#const_label.style_diamond)"
          ],
          "displayType": "const string"
        },
        {
          "name": "label.style_triangledown",
          "kind": "Built-in Constant",
          "desc": "Label style for [label.new](#fun_label.new) and [label.set_style](#fun_label.set_style) functions.",
          "type": "string",
          "seeAlso": [
            "[label.new](#fun_label.new)",
            "[label.set_style](#fun_label.set_style)",
            "[label.set_textalign](#fun_label.set_textalign)",
            "[label.style_none](#const_label.style_none)",
            "[label.style_xcross](#const_label.style_xcross)",
            "[label.style_cross](#const_label.style_cross)",
            "[label.style_triangleup](#const_label.style_triangleup)",
            "[label.style_flag](#const_label.style_flag)",
            "[label.style_circle](#const_label.style_circle)",
            "[label.style_arrowup](#const_label.style_arrowup)",
            "[label.style_arrowdown](#const_label.style_arrowdown)",
            "[label.style_label_up](#const_label.style_label_up)",
            "[label.style_label_down](#const_label.style_label_down)",
            "[label.style_label_left](#const_label.style_label_left)",
            "[label.style_label_right](#const_label.style_label_right)",
            "[label.style_label_lower_left](#const_label.style_label_lower_left)",
            "[label.style_label_lower_right](#const_label.style_label_lower_right)",
            "[label.style_label_upper_left](#const_label.style_label_upper_left)",
            "[label.style_label_upper_right](#const_label.style_label_upper_right)",
            "[label.style_label_center](#const_label.style_label_center)",
            "[label.style_square](#const_label.style_square)",
            "[label.style_diamond](#const_label.style_diamond)"
          ],
          "displayType": "const string"
        },
        {
          "name": "label.style_flag",
          "kind": "Built-in Constant",
          "desc": "Label style for [label.new](#fun_label.new) and [label.set_style](#fun_label.set_style) functions.",
          "type": "string",
          "seeAlso": [
            "[label.new](#fun_label.new)",
            "[label.set_style](#fun_label.set_style)",
            "[label.set_textalign](#fun_label.set_textalign)",
            "[label.style_none](#const_label.style_none)",
            "[label.style_xcross](#const_label.style_xcross)",
            "[label.style_cross](#const_label.style_cross)",
            "[label.style_triangleup](#const_label.style_triangleup)",
            "[label.style_triangledown](#const_label.style_triangledown)",
            "[label.style_circle](#const_label.style_circle)",
            "[label.style_arrowup](#const_label.style_arrowup)",
            "[label.style_arrowdown](#const_label.style_arrowdown)",
            "[label.style_label_up](#const_label.style_label_up)",
            "[label.style_label_down](#const_label.style_label_down)",
            "[label.style_label_left](#const_label.style_label_left)",
            "[label.style_label_right](#const_label.style_label_right)",
            "[label.style_label_lower_left](#const_label.style_label_lower_left)",
            "[label.style_label_lower_right](#const_label.style_label_lower_right)",
            "[label.style_label_upper_left](#const_label.style_label_upper_left)",
            "[label.style_label_upper_right](#const_label.style_label_upper_right)",
            "[label.style_label_center](#const_label.style_label_center)",
            "[label.style_square](#const_label.style_square)",
            "[label.style_diamond](#const_label.style_diamond)"
          ],
          "displayType": "const string"
        },
        {
          "name": "label.style_circle",
          "kind": "Built-in Constant",
          "desc": "Label style for [label.new](#fun_label.new) and [label.set_style](#fun_label.set_style) functions.",
          "type": "string",
          "seeAlso": [
            "[label.new](#fun_label.new)",
            "[label.set_style](#fun_label.set_style)",
            "[label.set_textalign](#fun_label.set_textalign)",
            "[label.style_none](#const_label.style_none)",
            "[label.style_xcross](#const_label.style_xcross)",
            "[label.style_cross](#const_label.style_cross)",
            "[label.style_triangleup](#const_label.style_triangleup)",
            "[label.style_triangledown](#const_label.style_triangledown)",
            "[label.style_flag](#const_label.style_flag)",
            "[label.style_arrowup](#const_label.style_arrowup)",
            "[label.style_arrowdown](#const_label.style_arrowdown)",
            "[label.style_label_up](#const_label.style_label_up)",
            "[label.style_label_down](#const_label.style_label_down)",
            "[label.style_label_left](#const_label.style_label_left)",
            "[label.style_label_right](#const_label.style_label_right)",
            "[label.style_label_lower_left](#const_label.style_label_lower_left)",
            "[label.style_label_lower_right](#const_label.style_label_lower_right)",
            "[label.style_label_upper_left](#const_label.style_label_upper_left)",
            "[label.style_label_upper_right](#const_label.style_label_upper_right)",
            "[label.style_label_center](#const_label.style_label_center)",
            "[label.style_square](#const_label.style_square)",
            "[label.style_diamond](#const_label.style_diamond)"
          ],
          "displayType": "const string"
        },
        {
          "name": "label.style_arrowup",
          "kind": "Built-in Constant",
          "desc": "Label style for [label.new](#fun_label.new) and [label.set_style](#fun_label.set_style) functions.",
          "type": "string",
          "seeAlso": [
            "[label.new](#fun_label.new)",
            "[label.set_style](#fun_label.set_style)",
            "[label.set_textalign](#fun_label.set_textalign)",
            "[label.style_none](#const_label.style_none)",
            "[label.style_xcross](#const_label.style_xcross)",
            "[label.style_cross](#const_label.style_cross)",
            "[label.style_triangleup](#const_label.style_triangleup)",
            "[label.style_triangledown](#const_label.style_triangledown)",
            "[label.style_flag](#const_label.style_flag)",
            "[label.style_circle](#const_label.style_circle)",
            "[label.style_arrowdown](#const_label.style_arrowdown)",
            "[label.style_label_up](#const_label.style_label_up)",
            "[label.style_label_down](#const_label.style_label_down)",
            "[label.style_label_left](#const_label.style_label_left)",
            "[label.style_label_right](#const_label.style_label_right)",
            "[label.style_label_lower_left](#const_label.style_label_lower_left)",
            "[label.style_label_lower_right](#const_label.style_label_lower_right)",
            "[label.style_label_upper_left](#const_label.style_label_upper_left)",
            "[label.style_label_upper_right](#const_label.style_label_upper_right)",
            "[label.style_label_center](#const_label.style_label_center)",
            "[label.style_square](#const_label.style_square)",
            "[label.style_diamond](#const_label.style_diamond)"
          ],
          "displayType": "const string"
        },
        {
          "name": "label.style_arrowdown",
          "kind": "Built-in Constant",
          "desc": "Label style for [label.new](#fun_label.new) and [label.set_style](#fun_label.set_style) functions.",
          "type": "string",
          "seeAlso": [
            "[label.new](#fun_label.new)",
            "[label.set_style](#fun_label.set_style)",
            "[label.set_textalign](#fun_label.set_textalign)",
            "[label.style_none](#const_label.style_none)",
            "[label.style_xcross](#const_label.style_xcross)",
            "[label.style_cross](#const_label.style_cross)",
            "[label.style_triangleup](#const_label.style_triangleup)",
            "[label.style_triangledown](#const_label.style_triangledown)",
            "[label.style_flag](#const_label.style_flag)",
            "[label.style_circle](#const_label.style_circle)",
            "[label.style_arrowup](#const_label.style_arrowup)",
            "[label.style_label_up](#const_label.style_label_up)",
            "[label.style_label_down](#const_label.style_label_down)",
            "[label.style_label_left](#const_label.style_label_left)",
            "[label.style_label_right](#const_label.style_label_right)",
            "[label.style_label_lower_left](#const_label.style_label_lower_left)",
            "[label.style_label_lower_right](#const_label.style_label_lower_right)",
            "[label.style_label_upper_left](#const_label.style_label_upper_left)",
            "[label.style_label_upper_right](#const_label.style_label_upper_right)",
            "[label.style_label_center](#const_label.style_label_center)",
            "[label.style_square](#const_label.style_square)",
            "[label.style_diamond](#const_label.style_diamond)"
          ],
          "displayType": "const string"
        },
        {
          "name": "label.style_label_up",
          "kind": "Built-in Constant",
          "desc": "Label style for [label.new](#fun_label.new) and [label.set_style](#fun_label.set_style) functions.",
          "type": "string",
          "seeAlso": [
            "[label.new](#fun_label.new)",
            "[label.set_style](#fun_label.set_style)",
            "[label.set_textalign](#fun_label.set_textalign)",
            "[label.style_none](#const_label.style_none)",
            "[label.style_xcross](#const_label.style_xcross)",
            "[label.style_cross](#const_label.style_cross)",
            "[label.style_triangleup](#const_label.style_triangleup)",
            "[label.style_triangledown](#const_label.style_triangledown)",
            "[label.style_flag](#const_label.style_flag)",
            "[label.style_circle](#const_label.style_circle)",
            "[label.style_arrowup](#const_label.style_arrowup)",
            "[label.style_arrowdown](#const_label.style_arrowdown)",
            "[label.style_label_down](#const_label.style_label_down)",
            "[label.style_label_left](#const_label.style_label_left)",
            "[label.style_label_right](#const_label.style_label_right)",
            "[label.style_label_lower_left](#const_label.style_label_lower_left)",
            "[label.style_label_lower_right](#const_label.style_label_lower_right)",
            "[label.style_label_upper_left](#const_label.style_label_upper_left)",
            "[label.style_label_upper_right](#const_label.style_label_upper_right)",
            "[label.style_label_center](#const_label.style_label_center)",
            "[label.style_square](#const_label.style_square)",
            "[label.style_diamond](#const_label.style_diamond)"
          ],
          "displayType": "const string"
        },
        {
          "name": "label.style_label_down",
          "kind": "Built-in Constant",
          "desc": "Label style for [label.new](#fun_label.new) and [label.set_style](#fun_label.set_style) functions.",
          "type": "string",
          "seeAlso": [
            "[label.new](#fun_label.new)",
            "[label.set_style](#fun_label.set_style)",
            "[label.set_textalign](#fun_label.set_textalign)",
            "[label.style_none](#const_label.style_none)",
            "[label.style_xcross](#const_label.style_xcross)",
            "[label.style_cross](#const_label.style_cross)",
            "[label.style_triangleup](#const_label.style_triangleup)",
            "[label.style_triangledown](#const_label.style_triangledown)",
            "[label.style_flag](#const_label.style_flag)",
            "[label.style_circle](#const_label.style_circle)",
            "[label.style_arrowup](#const_label.style_arrowup)",
            "[label.style_arrowdown](#const_label.style_arrowdown)",
            "[label.style_label_up](#const_label.style_label_up)",
            "[label.style_label_left](#const_label.style_label_left)",
            "[label.style_label_right](#const_label.style_label_right)",
            "[label.style_label_lower_left](#const_label.style_label_lower_left)",
            "[label.style_label_lower_right](#const_label.style_label_lower_right)",
            "[label.style_label_upper_left](#const_label.style_label_upper_left)",
            "[label.style_label_upper_right](#const_label.style_label_upper_right)",
            "[label.style_label_center](#const_label.style_label_center)",
            "[label.style_square](#const_label.style_square)",
            "[label.style_diamond](#const_label.style_diamond)"
          ],
          "displayType": "const string"
        },
        {
          "name": "label.style_label_left",
          "kind": "Built-in Constant",
          "desc": "Label style for [label.new](#fun_label.new) and [label.set_style](#fun_label.set_style) functions.",
          "type": "string",
          "seeAlso": [
            "[label.new](#fun_label.new)",
            "[label.set_style](#fun_label.set_style)",
            "[label.set_textalign](#fun_label.set_textalign)",
            "[label.style_none](#const_label.style_none)",
            "[label.style_xcross](#const_label.style_xcross)",
            "[label.style_cross](#const_label.style_cross)",
            "[label.style_triangleup](#const_label.style_triangleup)",
            "[label.style_triangledown](#const_label.style_triangledown)",
            "[label.style_flag](#const_label.style_flag)",
            "[label.style_circle](#const_label.style_circle)",
            "[label.style_arrowup](#const_label.style_arrowup)",
            "[label.style_arrowdown](#const_label.style_arrowdown)",
            "[label.style_label_up](#const_label.style_label_up)",
            "[label.style_label_down](#const_label.style_label_down)",
            "[label.style_label_right](#const_label.style_label_right)",
            "[label.style_label_lower_left](#const_label.style_label_lower_left)",
            "[label.style_label_lower_right](#const_label.style_label_lower_right)",
            "[label.style_label_upper_left](#const_label.style_label_upper_left)",
            "[label.style_label_upper_right](#const_label.style_label_upper_right)",
            "[label.style_label_center](#const_label.style_label_center)",
            "[label.style_square](#const_label.style_square)",
            "[label.style_diamond](#const_label.style_diamond)"
          ],
          "displayType": "const string"
        },
        {
          "name": "label.style_label_right",
          "kind": "Built-in Constant",
          "desc": "Label style for [label.new](#fun_label.new) and [label.set_style](#fun_label.set_style) functions.",
          "type": "string",
          "seeAlso": [
            "[label.new](#fun_label.new)",
            "[label.set_style](#fun_label.set_style)",
            "[label.set_textalign](#fun_label.set_textalign)",
            "[label.style_none](#const_label.style_none)",
            "[label.style_xcross](#const_label.style_xcross)",
            "[label.style_cross](#const_label.style_cross)",
            "[label.style_triangleup](#const_label.style_triangleup)",
            "[label.style_triangledown](#const_label.style_triangledown)",
            "[label.style_flag](#const_label.style_flag)",
            "[label.style_circle](#const_label.style_circle)",
            "[label.style_arrowup](#const_label.style_arrowup)",
            "[label.style_arrowdown](#const_label.style_arrowdown)",
            "[label.style_label_up](#const_label.style_label_up)",
            "[label.style_label_down](#const_label.style_label_down)",
            "[label.style_label_left](#const_label.style_label_left)",
            "[label.style_label_lower_left](#const_label.style_label_lower_left)",
            "[label.style_label_lower_right](#const_label.style_label_lower_right)",
            "[label.style_label_upper_left](#const_label.style_label_upper_left)",
            "[label.style_label_upper_right](#const_label.style_label_upper_right)",
            "[label.style_label_center](#const_label.style_label_center)",
            "[label.style_square](#const_label.style_square)",
            "[label.style_diamond](#const_label.style_diamond)"
          ],
          "displayType": "const string"
        },
        {
          "name": "label.style_label_lower_left",
          "kind": "Built-in Constant",
          "desc": "Label style for [label.new](#fun_label.new) and [label.set_style](#fun_label.set_style) functions.",
          "type": "string",
          "seeAlso": [
            "[label.new](#fun_label.new)",
            "[label.set_style](#fun_label.set_style)",
            "[label.set_textalign](#fun_label.set_textalign)",
            "[label.style_none](#const_label.style_none)",
            "[label.style_xcross](#const_label.style_xcross)",
            "[label.style_cross](#const_label.style_cross)",
            "[label.style_triangleup](#const_label.style_triangleup)",
            "[label.style_triangledown](#const_label.style_triangledown)",
            "[label.style_flag](#const_label.style_flag)",
            "[label.style_circle](#const_label.style_circle)",
            "[label.style_arrowup](#const_label.style_arrowup)",
            "[label.style_arrowdown](#const_label.style_arrowdown)",
            "[label.style_label_up](#const_label.style_label_up)",
            "[label.style_label_down](#const_label.style_label_down)",
            "[label.style_label_left](#const_label.style_label_left)",
            "[label.style_label_right](#const_label.style_label_right)",
            "[label.style_label_lower_right](#const_label.style_label_lower_right)",
            "[label.style_label_upper_left](#const_label.style_label_upper_left)",
            "[label.style_label_upper_right](#const_label.style_label_upper_right)",
            "[label.style_label_center](#const_label.style_label_center)",
            "[label.style_square](#const_label.style_square)",
            "[label.style_diamond](#const_label.style_diamond)"
          ],
          "displayType": "const string"
        },
        {
          "name": "label.style_label_lower_right",
          "kind": "Built-in Constant",
          "desc": "Label style for [label.new](#fun_label.new) and [label.set_style](#fun_label.set_style) functions.",
          "type": "string",
          "seeAlso": [
            "[label.new](#fun_label.new)",
            "[label.set_style](#fun_label.set_style)",
            "[label.set_textalign](#fun_label.set_textalign)",
            "[label.style_none](#const_label.style_none)",
            "[label.style_xcross](#const_label.style_xcross)",
            "[label.style_cross](#const_label.style_cross)",
            "[label.style_triangleup](#const_label.style_triangleup)",
            "[label.style_triangledown](#const_label.style_triangledown)",
            "[label.style_flag](#const_label.style_flag)",
            "[label.style_circle](#const_label.style_circle)",
            "[label.style_arrowup](#const_label.style_arrowup)",
            "[label.style_arrowdown](#const_label.style_arrowdown)",
            "[label.style_label_up](#const_label.style_label_up)",
            "[label.style_label_down](#const_label.style_label_down)",
            "[label.style_label_left](#const_label.style_label_left)",
            "[label.style_label_right](#const_label.style_label_right)",
            "[label.style_label_lower_left](#const_label.style_label_lower_left)",
            "[label.style_label_upper_left](#const_label.style_label_upper_left)",
            "[label.style_label_upper_right](#const_label.style_label_upper_right)",
            "[label.style_label_center](#const_label.style_label_center)",
            "[label.style_square](#const_label.style_square)",
            "[label.style_diamond](#const_label.style_diamond)"
          ],
          "displayType": "const string"
        },
        {
          "name": "label.style_label_upper_left",
          "kind": "Built-in Constant",
          "desc": "Label style for [label.new](#fun_label.new) and [label.set_style](#fun_label.set_style) functions.",
          "type": "string",
          "seeAlso": [
            "[label.new](#fun_label.new)",
            "[label.set_style](#fun_label.set_style)",
            "[label.set_textalign](#fun_label.set_textalign)",
            "[label.style_none](#const_label.style_none)",
            "[label.style_xcross](#const_label.style_xcross)",
            "[label.style_cross](#const_label.style_cross)",
            "[label.style_triangleup](#const_label.style_triangleup)",
            "[label.style_triangledown](#const_label.style_triangledown)",
            "[label.style_flag](#const_label.style_flag)",
            "[label.style_circle](#const_label.style_circle)",
            "[label.style_arrowup](#const_label.style_arrowup)",
            "[label.style_arrowdown](#const_label.style_arrowdown)",
            "[label.style_label_up](#const_label.style_label_up)",
            "[label.style_label_down](#const_label.style_label_down)",
            "[label.style_label_left](#const_label.style_label_left)",
            "[label.style_label_right](#const_label.style_label_right)",
            "[label.style_label_lower_left](#const_label.style_label_lower_left)",
            "[label.style_label_lower_right](#const_label.style_label_lower_right)",
            "[label.style_label_upper_right](#const_label.style_label_upper_right)",
            "[label.style_label_center](#const_label.style_label_center)",
            "[label.style_square](#const_label.style_square)",
            "[label.style_diamond](#const_label.style_diamond)"
          ],
          "displayType": "const string"
        },
        {
          "name": "label.style_label_upper_right",
          "kind": "Built-in Constant",
          "desc": "Label style for [label.new](#fun_label.new) and [label.set_style](#fun_label.set_style) functions.",
          "type": "string",
          "seeAlso": [
            "[label.new](#fun_label.new)",
            "[label.set_style](#fun_label.set_style)",
            "[label.set_textalign](#fun_label.set_textalign)",
            "[label.style_none](#const_label.style_none)",
            "[label.style_xcross](#const_label.style_xcross)",
            "[label.style_cross](#const_label.style_cross)",
            "[label.style_triangleup](#const_label.style_triangleup)",
            "[label.style_triangledown](#const_label.style_triangledown)",
            "[label.style_flag](#const_label.style_flag)",
            "[label.style_circle](#const_label.style_circle)",
            "[label.style_arrowup](#const_label.style_arrowup)",
            "[label.style_arrowdown](#const_label.style_arrowdown)",
            "[label.style_label_up](#const_label.style_label_up)",
            "[label.style_label_down](#const_label.style_label_down)",
            "[label.style_label_left](#const_label.style_label_left)",
            "[label.style_label_right](#const_label.style_label_right)",
            "[label.style_label_lower_left](#const_label.style_label_lower_left)",
            "[label.style_label_lower_right](#const_label.style_label_lower_right)",
            "[label.style_label_upper_left](#const_label.style_label_upper_left)",
            "[label.style_label_center](#const_label.style_label_center)",
            "[label.style_square](#const_label.style_square)",
            "[label.style_diamond](#const_label.style_diamond)"
          ],
          "displayType": "const string"
        },
        {
          "name": "label.style_label_center",
          "kind": "Built-in Constant",
          "desc": "Label style for [label.new](#fun_label.new) and [label.set_style](#fun_label.set_style) functions.",
          "type": "string",
          "seeAlso": [
            "[label.new](#fun_label.new)",
            "[label.set_style](#fun_label.set_style)",
            "[label.set_textalign](#fun_label.set_textalign)",
            "[label.style_none](#const_label.style_none)",
            "[label.style_xcross](#const_label.style_xcross)",
            "[label.style_cross](#const_label.style_cross)",
            "[label.style_triangleup](#const_label.style_triangleup)",
            "[label.style_triangledown](#const_label.style_triangledown)",
            "[label.style_flag](#const_label.style_flag)",
            "[label.style_circle](#const_label.style_circle)",
            "[label.style_arrowup](#const_label.style_arrowup)",
            "[label.style_arrowdown](#const_label.style_arrowdown)",
            "[label.style_label_up](#const_label.style_label_up)",
            "[label.style_label_down](#const_label.style_label_down)",
            "[label.style_label_left](#const_label.style_label_left)",
            "[label.style_label_right](#const_label.style_label_right)",
            "[label.style_label_lower_left](#const_label.style_label_lower_left)",
            "[label.style_label_lower_right](#const_label.style_label_lower_right)",
            "[label.style_label_upper_left](#const_label.style_label_upper_left)",
            "[label.style_label_upper_right](#const_label.style_label_upper_right)",
            "[label.style_square](#const_label.style_square)",
            "[label.style_diamond](#const_label.style_diamond)"
          ],
          "displayType": "const string"
        },
        {
          "name": "label.style_square",
          "kind": "Built-in Constant",
          "desc": "Label style for [label.new](#fun_label.new) and [label.set_style](#fun_label.set_style) functions.",
          "type": "string",
          "seeAlso": [
            "[label.new](#fun_label.new)",
            "[label.set_style](#fun_label.set_style)",
            "[label.set_textalign](#fun_label.set_textalign)",
            "[label.style_none](#const_label.style_none)",
            "[label.style_xcross](#const_label.style_xcross)",
            "[label.style_cross](#const_label.style_cross)",
            "[label.style_triangleup](#const_label.style_triangleup)",
            "[label.style_triangledown](#const_label.style_triangledown)",
            "[label.style_flag](#const_label.style_flag)",
            "[label.style_circle](#const_label.style_circle)",
            "[label.style_arrowup](#const_label.style_arrowup)",
            "[label.style_arrowdown](#const_label.style_arrowdown)",
            "[label.style_label_up](#const_label.style_label_up)",
            "[label.style_label_down](#const_label.style_label_down)",
            "[label.style_label_left](#const_label.style_label_left)",
            "[label.style_label_right](#const_label.style_label_right)",
            "[label.style_label_lower_left](#const_label.style_label_lower_left)",
            "[label.style_label_lower_right](#const_label.style_label_lower_right)",
            "[label.style_label_upper_left](#const_label.style_label_upper_left)",
            "[label.style_label_upper_right](#const_label.style_label_upper_right)",
            "[label.style_label_center](#const_label.style_label_center)",
            "[label.style_diamond](#const_label.style_diamond)"
          ],
          "displayType": "const string"
        },
        {
          "name": "label.style_diamond",
          "kind": "Built-in Constant",
          "desc": "Label style for [label.new](#fun_label.new) and [label.set_style](#fun_label.set_style) functions.",
          "type": "string",
          "seeAlso": [
            "[label.new](#fun_label.new)",
            "[label.set_style](#fun_label.set_style)",
            "[label.set_textalign](#fun_label.set_textalign)",
            "[label.style_none](#const_label.style_none)",
            "[label.style_xcross](#const_label.style_xcross)",
            "[label.style_cross](#const_label.style_cross)",
            "[label.style_triangleup](#const_label.style_triangleup)",
            "[label.style_triangledown](#const_label.style_triangledown)",
            "[label.style_flag](#const_label.style_flag)",
            "[label.style_circle](#const_label.style_circle)",
            "[label.style_arrowup](#const_label.style_arrowup)",
            "[label.style_arrowdown](#const_label.style_arrowdown)",
            "[label.style_label_up](#const_label.style_label_up)",
            "[label.style_label_down](#const_label.style_label_down)",
            "[label.style_label_left](#const_label.style_label_left)",
            "[label.style_label_right](#const_label.style_label_right)",
            "[label.style_label_lower_left](#const_label.style_label_lower_left)",
            "[label.style_label_lower_right](#const_label.style_label_lower_right)",
            "[label.style_label_upper_left](#const_label.style_label_upper_left)",
            "[label.style_label_upper_right](#const_label.style_label_upper_right)",
            "[label.style_label_center](#const_label.style_label_center)",
            "[label.style_square](#const_label.style_square)"
          ],
          "displayType": "const string"
        },
        {
          "name": "label.style_text_outline",
          "kind": "Built-in Constant",
          "desc": "Label style for [label.new](#fun_label.new) and [label.set_style](#fun_label.set_style) functions.",
          "type": "string",
          "seeAlso": [
            "[label.new](#fun_label.new)",
            "[label.set_style](#fun_label.set_style)",
            "[label.set_textalign](#fun_label.set_textalign)",
            "[label.style_none](#const_label.style_none)",
            "[label.style_xcross](#const_label.style_xcross)",
            "[label.style_cross](#const_label.style_cross)",
            "[label.style_triangleup](#const_label.style_triangleup)",
            "[label.style_triangledown](#const_label.style_triangledown)",
            "[label.style_flag](#const_label.style_flag)",
            "[label.style_circle](#const_label.style_circle)",
            "[label.style_arrowup](#const_label.style_arrowup)",
            "[label.style_arrowdown](#const_label.style_arrowdown)",
            "[label.style_label_up](#const_label.style_label_up)",
            "[label.style_label_down](#const_label.style_label_down)",
            "[label.style_label_left](#const_label.style_label_left)",
            "[label.style_label_right](#const_label.style_label_right)",
            "[label.style_label_lower_left](#const_label.style_label_lower_left)",
            "[label.style_label_lower_right](#const_label.style_label_lower_right)",
            "[label.style_label_upper_left](#const_label.style_label_upper_left)",
            "[label.style_label_upper_right](#const_label.style_label_upper_right)",
            "[label.style_label_center](#const_label.style_label_center)",
            "[label.style_square](#const_label.style_square)",
            "[label.style_diamond](#const_label.style_diamond)"
          ],
          "displayType": "const string"
        },
        {
          "name": "display.none",
          "kind": "Built-in Constant",
          "desc": "A named constant for use with the `display` parameter of `plot*()` and `input*()` functions. `plot*()` functions using this will not display their plotted values anywhere.  \nHowever, alert template messages and [fill](#fun_fill) functions can still use the values, and they will appear in exported chart data. `input*()` functions using this constant will only display their values within the script\\`s settings.",
          "type": "plot_simple_display",
          "seeAlso": [
            "[plot](#fun_plot)",
            "[plotshape](#fun_plotshape)",
            "[plotchar](#fun_plotchar)",
            "[plotarrow](#fun_plotarrow)",
            "[plotbar](#fun_plotbar)",
            "[plotcandle](#fun_plotcandle)"
          ],
          "displayType": "const plot_simple_display"
        },
        {
          "name": "display.pane",
          "kind": "Built-in Constant",
          "desc": "A named constant for use with the `display` parameter of `plot*()` functions. Displays plotted values in the chart pane used by the script.",
          "type": "plot_display",
          "seeAlso": [
            "[plot](#fun_plot)",
            "[plotshape](#fun_plotshape)",
            "[plotchar](#fun_plotchar)",
            "[plotarrow](#fun_plotarrow)",
            "[plotbar](#fun_plotbar)",
            "[plotcandle](#fun_plotcandle)"
          ],
          "displayType": "const plot_display"
        },
        {
          "name": "display.data_window",
          "kind": "Built-in Constant",
          "desc": "A named constant for use with the `display` parameter of `plot*()` and `input*()` functions.  \nDisplays plotted or input values in the Data Window, a menu accessible from the chart\\`s right sidebar.",
          "type": "plot_display",
          "seeAlso": [
            "[plot](#fun_plot)",
            "[plotshape](#fun_plotshape)",
            "[plotchar](#fun_plotchar)",
            "[plotarrow](#fun_plotarrow)",
            "[plotbar](#fun_plotbar)",
            "[plotcandle](#fun_plotcandle)"
          ],
          "displayType": "const plot_display"
        },
        {
          "name": "display.price_scale",
          "kind": "Built-in Constant",
          "desc": "A named constant for use with the `display` parameter of `plot*()` functions. Displays the plot’s label and value on the price scale if the chart\\`s settings allow it.",
          "type": "plot_display",
          "seeAlso": [
            "[plot](#fun_plot)",
            "[plotshape](#fun_plotshape)",
            "[plotchar](#fun_plotchar)",
            "[plotarrow](#fun_plotarrow)",
            "[plotbar](#fun_plotbar)",
            "[plotcandle](#fun_plotcandle)"
          ],
          "displayType": "const plot_display"
        },
        {
          "name": "display.status_line",
          "kind": "Built-in Constant",
          "desc": "A named constant for use with the `display` parameter of `plot*()` and `input*()` functions.  \nDisplays plotted or input values in the status line next to the script\\`s name on the chart if the chart\\`s settings allow it.",
          "type": "plot_display",
          "seeAlso": [
            "[plot](#fun_plot)",
            "[plotshape](#fun_plotshape)",
            "[plotchar](#fun_plotchar)",
            "[plotarrow](#fun_plotarrow)",
            "[plotbar](#fun_plotbar)",
            "[plotcandle](#fun_plotcandle)"
          ],
          "displayType": "const plot_display"
        },
        {
          "name": "display.all",
          "kind": "Built-in Constant",
          "desc": "A named constant for use with the `display` parameter of `plot*()` and `input*()` functions.  \nDisplays plotted or input values in all possible locations.",
          "type": "plot_simple_display",
          "seeAlso": [
            "[plot](#fun_plot)",
            "[plotshape](#fun_plotshape)",
            "[plotchar](#fun_plotchar)",
            "[plotarrow](#fun_plotarrow)",
            "[plotbar](#fun_plotbar)",
            "[plotcandle](#fun_plotcandle)"
          ],
          "displayType": "const plot_simple_display"
        },
        {
          "name": "line.style_solid",
          "kind": "Built-in Constant",
          "desc": "Line style for [line.new](#fun_line.new) and [line.set_style](#fun_line.set_style) functions.",
          "type": "string",
          "seeAlso": [
            "[line.new](#fun_line.new)",
            "[line.set_style](#fun_line.set_style)",
            "[line.style_dotted](#const_line.style_dotted)",
            "[line.style_dashed](#const_line.style_dashed)",
            "[line.style_arrow_left](#const_line.style_arrow_left)",
            "[line.style_arrow_right](#const_line.style_arrow_right)",
            "[line.style_arrow_both](#const_line.style_arrow_both)"
          ],
          "displayType": "const string"
        },
        {
          "name": "line.style_dotted",
          "kind": "Built-in Constant",
          "desc": "Line style for [line.new](#fun_line.new) and [line.set_style](#fun_line.set_style) functions.",
          "type": "string",
          "seeAlso": [
            "[line.new](#fun_line.new)",
            "[line.set_style](#fun_line.set_style)",
            "[line.style_solid](#const_line.style_solid)",
            "[line.style_dashed](#const_line.style_dashed)",
            "[line.style_arrow_left](#const_line.style_arrow_left)",
            "[line.style_arrow_right](#const_line.style_arrow_right)",
            "[line.style_arrow_both](#const_line.style_arrow_both)"
          ],
          "displayType": "const string"
        },
        {
          "name": "line.style_dashed",
          "kind": "Built-in Constant",
          "desc": "Line style for [line.new](#fun_line.new) and [line.set_style](#fun_line.set_style) functions.",
          "type": "string",
          "seeAlso": [
            "[line.new](#fun_line.new)",
            "[line.set_style](#fun_line.set_style)",
            "[line.style_solid](#const_line.style_solid)",
            "[line.style_dotted](#const_line.style_dotted)",
            "[line.style_arrow_left](#const_line.style_arrow_left)",
            "[line.style_arrow_right](#const_line.style_arrow_right)",
            "[line.style_arrow_both](#const_line.style_arrow_both)"
          ],
          "displayType": "const string"
        },
        {
          "name": "line.style_arrow_left",
          "kind": "Built-in Constant",
          "desc": "Line style for [line.new](#fun_line.new) and [line.set_style](#fun_line.set_style) functions.  \nSolid line with arrow on the first point.",
          "type": "string",
          "seeAlso": [
            "[line.new](#fun_line.new)",
            "[line.set_style](#fun_line.set_style)",
            "[line.style_solid](#const_line.style_solid)",
            "[line.style_dotted](#const_line.style_dotted)",
            "[line.style_dashed](#const_line.style_dashed)",
            "[line.style_arrow_right](#const_line.style_arrow_right)",
            "[line.style_arrow_both](#const_line.style_arrow_both)"
          ],
          "displayType": "const string"
        },
        {
          "name": "line.style_arrow_right",
          "kind": "Built-in Constant",
          "desc": "Line style for [line.new](#fun_line.new) and [line.set_style](#fun_line.set_style) functions.  \nSolid line with arrow on the second point.",
          "type": "string",
          "seeAlso": [
            "[line.new](#fun_line.new)",
            "[line.set_style](#fun_line.set_style)",
            "[line.style_solid](#const_line.style_solid)",
            "[line.style_dotted](#const_line.style_dotted)",
            "[line.style_dashed](#const_line.style_dashed)",
            "[line.style_arrow_left](#const_line.style_arrow_left)",
            "[line.style_arrow_both](#const_line.style_arrow_both)"
          ],
          "displayType": "const string"
        },
        {
          "name": "line.style_arrow_both",
          "kind": "Built-in Constant",
          "desc": "Line style for [line.new](#fun_line.new) and [line.set_style](#fun_line.set_style) functions.  \nSolid line with arrows on both points.",
          "type": "string",
          "seeAlso": [
            "[line.new](#fun_line.new)",
            "[line.set_style](#fun_line.set_style)",
            "[line.style_solid](#const_line.style_solid)",
            "[line.style_dotted](#const_line.style_dotted)",
            "[line.style_dashed](#const_line.style_dashed)",
            "[line.style_arrow_left](#const_line.style_arrow_left)",
            "[line.style_arrow_right](#const_line.style_arrow_right)"
          ],
          "displayType": "const string"
        },
        {
          "name": "text.align_center",
          "kind": "Built-in Constant",
          "desc": "Text alignment for [box.new](#fun_box.new), [box.set_text_halign](#fun_box.set_text_halign), [box.set_text_valign](#fun_box.set_text_valign), [label.new](#fun_label.new) and [label.set_textalign](#fun_label.set_textalign) functions.",
          "type": "string",
          "seeAlso": [
            "[label.new](#fun_label.new)",
            "[label.set_style](#fun_label.set_style)",
            "[text.align_left](#const_text.align_left)",
            "[text.align_right](#const_text.align_right)"
          ],
          "displayType": "const string"
        },
        {
          "name": "text.align_left",
          "kind": "Built-in Constant",
          "desc": "Horizontal text alignment for [box.new](#fun_box.new), [box.set_text_halign](#fun_box.set_text_halign), [label.new](#fun_label.new) and [label.set_textalign](#fun_label.set_textalign) functions.",
          "type": "string",
          "seeAlso": [
            "[label.new](#fun_label.new)",
            "[label.set_style](#fun_label.set_style)",
            "[text.align_center](#const_text.align_center)",
            "[text.align_right](#const_text.align_right)"
          ],
          "displayType": "const string"
        },
        {
          "name": "text.align_right",
          "kind": "Built-in Constant",
          "desc": "Horizontal text alignment for [box.new](#fun_box.new), [box.set_text_halign](#fun_box.set_text_halign), [label.new](#fun_label.new) and [label.set_textalign](#fun_label.set_textalign) functions.",
          "type": "string",
          "seeAlso": [
            "[label.new](#fun_label.new)",
            "[label.set_style](#fun_label.set_style)",
            "[text.align_center](#const_text.align_center)",
            "[text.align_left](#const_text.align_left)"
          ],
          "displayType": "const string"
        },
        {
          "name": "text.align_top",
          "kind": "Built-in Constant",
          "desc": "Vertical text alignment for [box.new](#fun_box.new), [box.set_text_valign](#fun_box.set_text_valign), [table.cell](#fun_table.cell) and [table.cell_set_text_valign](#fun_table.cell_set_text_valign) functions.",
          "type": "string",
          "seeAlso": [
            "[table.cell](#fun_table.cell)",
            "[table.cell_set_text_valign](#fun_table.cell_set_text_valign)",
            "[text.align_center](#const_text.align_center)",
            "[text.align_left](#const_text.align_left)",
            "[text.align_right](#const_text.align_right)"
          ],
          "displayType": "const string"
        },
        {
          "name": "text.align_bottom",
          "kind": "Built-in Constant",
          "desc": "Vertical text alignment for [box.new](#fun_box.new), [box.set_text_valign](#fun_box.set_text_valign), [table.cell](#fun_table.cell) and [table.cell_set_text_valign](#fun_table.cell_set_text_valign) functions.",
          "type": "string",
          "seeAlso": [
            "[table.cell](#fun_table.cell)",
            "[table.cell_set_text_valign](#fun_table.cell_set_text_valign)",
            "[text.align_center](#const_text.align_center)",
            "[text.align_left](#const_text.align_left)",
            "[text.align_right](#const_text.align_right)"
          ],
          "displayType": "const string"
        },
        {
          "name": "font.family_default",
          "kind": "Built-in Constant",
          "desc": "Default text font for [box.new](#fun_box.new), [box.set_text_font_family](#fun_box.set_text_font_family), [label.new](#fun_label.new), [label.set_text_font_family](#fun_label.set_text_font_family), [table.cell](#fun_table.cell) and [table.cell_set_text_font_family](#fun_table.cell_set_text_font_family) functions.",
          "type": "string",
          "seeAlso": [
            "[box.new](#fun_box.new)",
            "[box.set_text_font_family](#fun_box.set_text_font_family)",
            "[label.new](#fun_label.new)",
            "[label.set_text_font_family](#fun_label.set_text_font_family)",
            "[table.cell](#fun_table.cell)",
            "[table.cell_set_text_font_family](#fun_table.cell_set_text_font_family)",
            "[font.family_monospace](#const_font.family_monospace)"
          ],
          "displayType": "const string"
        },
        {
          "name": "font.family_monospace",
          "kind": "Built-in Constant",
          "desc": "Monospace text font for [box.new](#fun_box.new), [box.set_text_font_family](#fun_box.set_text_font_family), [label.new](#fun_label.new), [label.set_text_font_family](#fun_label.set_text_font_family), [table.cell](#fun_table.cell) and [table.cell_set_text_font_family](#fun_table.cell_set_text_font_family) functions.",
          "type": "string",
          "seeAlso": [
            "[box.new](#fun_box.new)",
            "[box.set_text_font_family](#fun_box.set_text_font_family)",
            "[label.new](#fun_label.new)",
            "[label.set_text_font_family](#fun_label.set_text_font_family)",
            "[table.cell](#fun_table.cell)",
            "[table.cell_set_text_font_family](#fun_table.cell_set_text_font_family)",
            "[font.family_default](#const_font.family_default)"
          ],
          "displayType": "const string"
        },
        {
          "name": "text.wrap_auto",
          "kind": "Built-in Constant",
          "desc": "Automatic wrapping mode for [box.new](#fun_box.new) and [box.set_text_wrap](#fun_box.set_text_wrap) functions.",
          "type": "string",
          "seeAlso": [
            "[box.new](#fun_box.new)",
            "[box.set_text](#fun_box.set_text)",
            "[box.set_text_wrap](#fun_box.set_text_wrap)"
          ],
          "displayType": "const string"
        },
        {
          "name": "text.wrap_none",
          "kind": "Built-in Constant",
          "desc": "Disabled wrapping mode for [box.new](#fun_box.new) and [box.set_text_wrap](#fun_box.set_text_wrap) functions.",
          "type": "string",
          "seeAlso": [
            "[box.new](#fun_box.new)",
            "[box.set_text](#fun_box.set_text)",
            "[box.set_text_wrap](#fun_box.set_text_wrap)"
          ],
          "displayType": "const string"
        },
        {
          "name": "order.ascending",
          "kind": "Built-in Constant",
          "desc": "Determines the sort order of the array from the smallest to the largest value.",
          "type": "sort_order",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.sort](#fun_array.sort)."
          ],
          "displayType": "const sort_order"
        },
        {
          "name": "order.descending",
          "kind": "Built-in Constant",
          "desc": "Determines the sort order of the array from the largest to the smallest value.",
          "type": "sort_order",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.sort](#fun_array.sort)."
          ],
          "displayType": "const sort_order"
        },
        {
          "name": "alert.freq_all",
          "kind": "Built-in Constant",
          "desc": "A named constant for use with the `freq` parameter of the alert() function.\nAll function calls trigger the alert.",
          "type": "string",
          "seeAlso": [
            "[alert](#fun_alert)."
          ],
          "displayType": "const string"
        },
        {
          "name": "alert.freq_once_per_bar",
          "kind": "Built-in Constant",
          "desc": "A named constant for use with the `freq` parameter of the alert() function.\nThe first function call during the bar triggers the alert.",
          "type": "string",
          "seeAlso": [
            "[alert](#fun_alert)."
          ],
          "displayType": "const string"
        },
        {
          "name": "alert.freq_once_per_bar_close",
          "kind": "Built-in Constant",
          "desc": "A named constant for use with the `freq` parameter of the alert() function.\nThe function call triggers the alert only when it occurs during the last script iteration of the real-time bar, when it closes.",
          "type": "string",
          "seeAlso": [
            "[alert](#fun_alert)."
          ],
          "displayType": "const string"
        },
        {
          "name": "earnings.actual",
          "kind": "Built-in Constant",
          "desc": "A named constant for the [request.earnings](#fun_request.earnings) function.  \nIs used to request the earnings value as it was reported.",
          "type": "string",
          "returns": "float",
          "seeAlso": [
            "[request.earnings](#fun_request.earnings)."
          ],
          "displayType": "const string"
        },
        {
          "name": "earnings.estimate",
          "kind": "Built-in Constant",
          "desc": "A named constant for the [request.earnings](#fun_request.earnings) function.  \nIs used to request the estimated earnings value.",
          "type": "string",
          "returns": "float",
          "seeAlso": [
            "[request.earnings](#fun_request.earnings)."
          ],
          "displayType": "const string"
        },
        {
          "name": "earnings.standardized",
          "kind": "Built-in Constant",
          "desc": "A named constant for the [request.earnings](#fun_request.earnings) function.  \nIs used to request the standardized earnings value.",
          "type": "string",
          "returns": "float",
          "seeAlso": [
            "[request.earnings](#fun_request.earnings)."
          ],
          "displayType": "const string"
        },
        {
          "name": "dividends.future_amount",
          "type": "series float",
          "desc": "Returns the payment amount of the upcoming dividend in the currency of the current instrument, or [na](#var_na) if this data isn't available.",
          "kind": "Built-in Constant",
          "reamrks": "This value is only fetched once during the script's initial calculation. The variable will return the same value until the script is recalculated, even after the expected Payment date of the next dividend.",
          "returns": "float"
        },
        {
          "name": "dividends.future_ex_date",
          "type": "series int",
          "desc": "Returns the Ex-dividend date (Ex-date) of the current instrument's next dividend payment, or [na](#var_na) if this data isn't available. Ex-dividend date signifies when investors are no longer entitled to a payout from the most recent dividend. Only those who purchased shares before this day are entitled to the dividend payment.",
          "kind": "Built-in Constant",
          "returns": "int",
          "reamrks": "This value is only fetched once during the script's initial calculation. The variable will return the same value until the script is recalculated, even after the expected Payment date of the next dividend."
        },
        {
          "name": "dividends.future_pay_date",
          "type": "series int",
          "desc": "Returns the Payment date (Pay date) of the current instrument's next dividend payment, or [na](#var_na) if this data isn't available. Payment date signifies the day when eligible investors will receive the dividend payment.",
          "kind": "Built-in Constant",
          "returns": "int",
          "reamrks": "This value is only fetched once during the script's initial calculation. The variable will return the same value until the script is recalculated, even after the expected Payment date of the next dividend."
        },
        {
          "name": "dividends.net",
          "kind": "Built-in Constant",
          "desc": "A named constant for the [request.dividends](#fun_request.dividends) function.  \nIs used to request the dividends return on a stock after deductions.",
          "type": "string",
          "returns": "float",
          "seeAlso": [
            "[request.dividends](#fun_request.dividends)."
          ],
          "displayType": "const string"
        },
        {
          "name": "dividends.gross",
          "kind": "Built-in Constant",
          "desc": "A named constant for the [request.dividends](#fun_request.dividends) function.  \nIs used to request the dividends return on a stock before deductions.",
          "type": "string",
          "returns": "float",
          "seeAlso": [
            "[request.dividends](#fun_request.dividends)."
          ],
          "displayType": "const string"
        },
        {
          "name": "splits.denominator",
          "kind": "Built-in Constant",
          "desc": "A named constant for the [request.splits](#fun_request.splits) function.  \nIs used to request the denominator (the number below the line in a fraction) of a splits.",
          "type": "string",
          "returns": "int|float",
          "seeAlso": [
            "[request.splits](#fun_request.splits)."
          ],
          "displayType": "const string"
        },
        {
          "name": "splits.numerator",
          "kind": "Built-in Constant",
          "desc": "A named constant for the [request.splits](#fun_request.splits) function.  \nIs used to request the numerator (the number above the line in a fraction) of a splits.",
          "type": "string",
          "returns": "int|float",
          "seeAlso": [
            "[request.splits](#fun_request.splits)."
          ],
          "displayType": "const string"
        },
        {
          "name": "color.black",
          "kind": "Color Constant",
          "desc": "Is a named constant for #363A45 color.  \n***  \n### **Built-in Colors**  \nblack, silver, gray, white, maroon, red, purple, fuchsia, green,  \nlime, olive, yellow, navy, blue, teal, orange, aqua",
          "type": "color",
          "color": "#363A45",
          "seeAlso": [
            "[Built-in Colors](#var_color.aqua)"
          ],
          "displayType": "const color"
        },
        {
          "name": "color.silver",
          "kind": "Color Constant",
          "desc": "Is a named constant for #B2B5BE color.  \n***  \n### **Built-in Colors**  \nblack, silver, gray, white, maroon, red, purple, fuchsia, green,  \nlime, olive, yellow, navy, blue, teal, orange, aqua",
          "type": "color",
          "color": "#B2B5BE",
          "seeAlso": [
            "[Built-in Colors](#var_color.aqua)"
          ],
          "displayType": "const color"
        },
        {
          "name": "color.gray",
          "kind": "Color Constant",
          "desc": "Is a named constant for #787B86 color.  \n***  \n### **Built-in Colors**  \nblack, silver, gray, white, maroon, red, purple, fuchsia, green,  \nlime, olive, yellow, navy, blue, teal, orange, aqua",
          "type": "color",
          "color": "#787B86",
          "seeAlso": [
            "[Built-in Colors](#var_color.aqua)"
          ],
          "displayType": "const color"
        },
        {
          "name": "color.white",
          "kind": "Color Constant",
          "desc": "Is a named constant for #FFFFFF color.  \n***  \n### **Built-in Colors**  \nblack, silver, gray, white, maroon, red, purple, fuchsia, green,  \nlime, olive, yellow, navy, blue, teal, orange, aqua",
          "type": "color",
          "color": "#FFFFFF",
          "seeAlso": [
            "[Built-in Colors](#var_color.aqua)"
          ],
          "displayType": "const color"
        },
        {
          "name": "color.maroon",
          "kind": "Color Constant",
          "desc": "Is a named constant for #880E4F color.  \n***  \n### **Built-in Colors**  \nblack, silver, gray, white, maroon, red, purple, fuchsia, green,  \nlime, olive, yellow, navy, blue, teal, orange, aqua",
          "type": "color",
          "color": "#880E4F",
          "seeAlso": [
            "[Built-in Colors](#var_color.aqua)"
          ],
          "displayType": "const color"
        },
        {
          "name": "color.red",
          "kind": "Color Constant",
          "desc": "Is a named constant for #FF5252 color.  \n***  \n### **Built-in Colors**  \nblack, silver, gray, white, maroon, red, purple, fuchsia, green,  \nlime, olive, yellow, navy, blue, teal, orange, aqua",
          "type": "color",
          "color": "#FF5252",
          "seeAlso": [
            "[Built-in Colors](#var_color.aqua)"
          ],
          "displayType": "const color"
        },
        {
          "name": "color.purple",
          "kind": "Color Constant",
          "desc": "Is a named constant for #9C27B0 color.  \n***  \n### **Built-in Colors**  \nblack, silver, gray, white, maroon, red, purple, fuchsia, green,  \nlime, olive, yellow, navy, blue, teal, orange, aqua",
          "type": "color",
          "color": "#9C27B0",
          "seeAlso": [
            "[Built-in Colors](#var_color.aqua)"
          ],
          "displayType": "const color"
        },
        {
          "name": "color.fuchsia",
          "kind": "Color Constant",
          "desc": "Is a named constant for #E040FB color.  \n***  \n### **Built-in Colors**  \nblack, silver, gray, white, maroon, red, purple, fuchsia, green,  \nlime, olive, yellow, navy, blue, teal, orange, aqua",
          "type": "color",
          "color": "#E040FB",
          "seeAlso": [
            "[Built-in Colors](#var_color.aqua)"
          ],
          "displayType": "const color"
        },
        {
          "name": "color.green",
          "kind": "Color Constant",
          "desc": "Is a named constant for #4CAF50 color.  \n***  \n### **Built-in Colors**  \nblack, silver, gray, white, maroon, red, purple, fuchsia, green,  \nlime, olive, yellow, navy, blue, teal, orange, aqua",
          "type": "color",
          "color": "#4CAF50",
          "seeAlso": [
            "[Built-in Colors](#var_color.aqua)"
          ],
          "displayType": "const color"
        },
        {
          "name": "color.lime",
          "kind": "Color Constant",
          "desc": "Is a named constant for #00E676 color.  \n***  \n### **Built-in Colors**  \nblack, silver, gray, white, maroon, red, purple, fuchsia, green,  \nlime, olive, yellow, navy, blue, teal, orange, aqua",
          "type": "color",
          "color": "#00E676",
          "seeAlso": [
            "[Built-in Colors](#var_color.aqua)"
          ],
          "displayType": "const color"
        },
        {
          "name": "color.olive",
          "kind": "Color Constant",
          "desc": "Is a named constant for #808000 color.  \n***  \n### **Built-in Colors**  \nblack, silver, gray, white, maroon, red, purple, fuchsia, green,  \nlime, olive, yellow, navy, blue, teal, orange, aqua",
          "type": "color",
          "color": "#808000",
          "seeAlso": [
            "[Built-in Colors](#var_color.aqua)"
          ],
          "displayType": "const color"
        },
        {
          "name": "color.yellow",
          "kind": "Color Constant",
          "desc": "Is a named constant for #FFEB3B color.  \n***  \n### **Built-in Colors**  \nblack, silver, gray, white, maroon, red, purple, fuchsia, green,  \nlime, olive, yellow, navy, blue, teal, orange, aqua",
          "type": "color",
          "color": "#FFEB3B",
          "seeAlso": [
            "[Built-in Colors](#var_color.aqua)"
          ],
          "displayType": "const color"
        },
        {
          "name": "color.navy",
          "kind": "Color Constant",
          "desc": "Is a named constant for #311B92 color.  \n***  \n### **Built-in Colors**  \nblack, silver, gray, white, maroon, red, purple, fuchsia, green,  \nlime, olive, yellow, navy, blue, teal, orange, aqua",
          "type": "color",
          "color": "#311B92",
          "seeAlso": [
            "[Built-in Colors](#var_color.aqua)"
          ],
          "displayType": "const color"
        },
        {
          "name": "color.blue",
          "kind": "Color Constant",
          "desc": "Is a named constant for #2962ff color.  \n***  \n### **Built-in Colors**  \nblack, silver, gray, white, maroon, red, purple, fuchsia, green,  \nlime, olive, yellow, navy, blue, teal, orange, aqua",
          "type": "color",
          "color": "#2962ff",
          "seeAlso": [
            "[Built-in Colors](#var_color.aqua)"
          ],
          "displayType": "const color"
        },
        {
          "name": "color.teal",
          "kind": "Color Constant",
          "desc": "Is a named constant for #00897B color.  \n***  \n### **Built-in Colors**  \nblack, silver, gray, white, maroon, red, purple, fuchsia, green,  \nlime, olive, yellow, navy, blue, teal, orange, aqua",
          "type": "color",
          "color": "#00897B",
          "seeAlso": [
            "[Built-in Colors](#var_color.aqua)"
          ],
          "displayType": "const color"
        },
        {
          "name": "color.orange",
          "kind": "Color Constant",
          "desc": "Is a named constant for #FF9800 color.  \n***  \n### **Built-in Colors**  \nblack, silver, gray, white, maroon, red, purple, fuchsia, green,  \nlime, olive, yellow, navy, blue, teal, orange, aqua",
          "type": "color",
          "color": "#FF9800",
          "seeAlso": [
            "[Built-in Colors](#var_color.aqua)"
          ],
          "displayType": "const color"
        },
        {
          "name": "color.aqua",
          "kind": "Color Constant",
          "desc": "Is a named constant for #00BCD4 color.  \n***  \n### **Built-in Colors**  \nblack, silver, gray, white, maroon, red, purple, fuchsia, green,  \nlime, olive, yellow, navy, blue, teal, orange, aqua",
          "type": "color",
          "color": "#00BCD4",
          "seeAlso": [
            "[Built-in Colors](#var_color.teal)"
          ],
          "displayType": "const color"
        }
      ],
      "title": "Built-in Constant"
    }
  ],
  "functions": [
    {
      "docs": [
        {
          "name": "na",
          "kind": "Built-in Function",
          "desc": "Tests if `x` is [na](#var_na).",
          "args": [
            {
              "name": "x",
              "desc": "Value to be tested.",
              "default": null,
              "required": true,
              "displayType": "series any",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float",
                "series bool",
                "simple bool",
                "input bool",
                "const bool",
                "series color",
                "simple color",
                "input color",
                "const color",
                "series string",
                "simple string",
                "input string",
                "const string",
                "series label",
                "series line",
                "series box",
                "series table",
                "series linefill",
                "matrix",
                "array"
              ],
              "possibleValues": [
                "close",
                "open",
                "high",
                "low",
                "volume"
              ]
            }
          ],
          "syntax": "na(x) → series bool",
          "returns": "Returns [true](#op_true) if `x` is [na](#var_na), [false](#op_false) otherwise.",
          "seeAlso": [
            "[na](#var_na)",
            "[fixnan](#fun_fixnan)",
            "[nz](#fun_nz)"
          ],
          "examples": "//@version=5\nindicator(\"na\")\n// Use the `na()` function to test for `na`.\nplot(na(close[1]) ? close : close[1])\n// ALTERNATIVE\n// `nz()` also tests `close[1]` for `na`. It returns `close[1]` if it is not `na`, and `close` if it is.\nplot(nz(close[1], close))",
          "returnedType": "bool",
          "returnedTypes": [
            "simple bool",
            "input bool",
            "const bool",
            "series bool"
          ]
        },
        {
          "name": "ta.tr",
          "kind": "Built-in Function",
          "args": [
            {
              "name": "handle_na",
              "desc": "How NaN values are handled. if true, and previous day\\`s close is NaN then tr would be calculated as current day high-low.  \nOtherwise (if false) tr would return NaN in such cases.  \nAlso note, that [ta.atr](#fun_ta.atr) uses ta.tr(true).",
              "default": null,
              "required": true,
              "displayType": "simple bool",
              "allowedTypeIDs": [
                "simple bool",
                "input bool",
                "const bool"
              ],
              "possibleValues": [
                "true",
                "false"
              ]
            }
          ],
          "syntax": "ta.tr(handle_na) → series float",
          "remarks": "ta.tr(false) is exactly the same as [ta.tr](#var_ta.tr).",
          "returns": "True range. It is math.max(high - low, math.abs(high - close[1]), math.abs(low - close[1])).",
          "seeAlso": [
            "[ta.tr](#var_ta.tr)",
            "[ta.atr](#fun_ta.atr)"
          ],
          "returnedType": "float",
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "name": "ta.vwap",
          "kind": "Built-in Function",
          "desc": "Volume weighted average price.",
          "args": [
            {
              "name": "source",
              "desc": "Source used for the VWAP calculation.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "open",
                "high",
                "low",
                "close",
                "volume"
              ]
            },
            {
              "name": "anchor",
              "desc": "The condition that triggers the reset of VWAP calculations. When [true](#op_true), calculations reset; when [false](#op_false), calculations proceed using the values accumulated since the previous reset.  \nOptional. The default is equivalent to passing [timeframe.change](#fun_timeframe.change) with \"1D\" as its argument.",
              "default": "1D",
              "required": true,
              "displayType": "series bool",
              "allowedTypeIDs": [
                "series bool",
                "simple bool",
                "input bool",
                "const bool"
              ],
              "possibleValues": [
                "timeframe.isdaily",
                "timeframe.isweekly",
                "timeframe.ismonthly",
                "timeframe.change('1D')",
                "timeframe.change('1W')"
              ]
            },
            {
              "name": "stdev_mult",
              "desc": "If specified, the function will calculate the standard deviation bands based on the main VWAP series and return a [vwap, upper_band, lower_band] tuple.  \nThe `upper_band`/`lower_band` values are calculated using the VWAP to which the standard deviation multiplied by this argument is added/subtracted.  \nOptional. The default is [na](#var_na), in which case the function returns a single value, not a tuple.",
              "default": "na",
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "1.0",
                "2.0",
                "3.0"
              ]
            }
          ],
          "syntax": "ta.vwap(source, anchor) → series float\nta.vwap(source, anchor, stdev_mult) → [series float, series float, series float]",
          "remarks": "Calculations only begin the first time the anchor condition becomes [true](#op_true).  \nUntil then, the function returns [na](#var_na).",
          "returns": "A VWAP series, or a tuple [vwap, upper_band, lower_band] if `stdev_mult` is specified.",
          "seeAlso": [
            "[ta.vwap](#var_ta.vwap) (variable)"
          ],
          "returnedType": [
            "float",
            "[float, float, float]"
          ],
          "detailedDesc": [
            {
              "desc": "",
              "examples": "//@version=5\nindicator(\"Simple VWAP\")\nvwap = ta.vwap(open)\nplot(vwap)"
            },
            {
              "desc": "",
              "examples": "//@version=5\nindicator(\"Advanced VWAP\")\nvwapAnchorInput = input.string(\"Daily\", \"Anchor\", options = [\"Daily\", \"Weekly\", \"Monthly\"])\nstdevMultiplierInput = input.float(1.0, \"Standard Deviation Multiplier\")\nanchorTimeframe = switch vwapAnchorInput\n\t\"Daily\"   => \"1D\"\n\t\"Weekly\"  => \"1W\"\n\t\"Monthly\" => \"1M\"\nanchor = timeframe.change(anchorTimeframe)\n[vwap, upper, lower] = ta.vwap(open, anchor, stdevMultiplierInput)\nplot(vwap)\nplot(upper, color = color.green)\nplot(lower, color = color.green)"
            }
          ],
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float",
            "[series float, series float, series float]"
          ]
        },
        {
          "name": "syminfo.prefix",
          "kind": "Built-in Function",
          "desc": "Returns exchange prefix of the `symbol`, e.g. \"NASDAQ\".",
          "args": [
            {
              "name": "symbol",
              "desc": "Symbol. Note that the symbol should be passed with a prefix. For example: \"NASDAQ:AAPL\" instead of \"AAPL\".",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "syminfo.prefix(symbol) → series string",
          "remarks": "The result of the function is used in the [ticker.new](#fun_ticker.new)/[ticker.modify](#fun_ticker.modify) and [request.security](#fun_request.security).",
          "returns": "Returns exchange prefix of the `symbol`, e.g. \"NASDAQ\".",
          "seeAlso": [
            "[syminfo.tickerid](#var_syminfo.tickerid)",
            "[syminfo.ticker](#var_syminfo.ticker)",
            "[syminfo.prefix](#var_syminfo.prefix)",
            "[syminfo.ticker](#fun_syminfo.ticker)",
            "[ticker.new](#fun_ticker.new)"
          ],
          "examples": "//@version=5\nindicator(\"syminfo.prefix fun\", overlay=true)\ni_sym = input.symbol(\"NASDAQ:AAPL\")\npref = syminfo.prefix(i_sym)\ntick = syminfo.ticker(i_sym)\nt = ticker.new(pref, tick, session.extended)\ns = request.security(t, \"1D\", close)\nplot(s)",
          "returnedType": "string",
          "returnedTypes": [
            "simple string",
            "input string",
            "const string",
            "series string"
          ]
        },
        {
          "name": "syminfo.ticker",
          "kind": "Built-in Function",
          "desc": "Returns `symbol` name without exchange prefix, e.g. \"AAPL\".",
          "args": [
            {
              "name": "symbol",
              "desc": "Symbol. Note that the symbol should be passed with a prefix. For example: \"NASDAQ:AAPL\" instead of \"AAPL\".",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "syminfo.ticker(symbol) → series string",
          "remarks": "The result of the function is used in the [ticker.new](#fun_ticker.new)/[ticker.modify](#fun_ticker.modify) and [request.security](#fun_request.security).",
          "returns": "Returns `symbol` name without exchange prefix, e.g. \"AAPL\".",
          "seeAlso": [
            "[syminfo.tickerid](#var_syminfo.tickerid)",
            "[syminfo.ticker](#var_syminfo.ticker)",
            "[syminfo.prefix](#var_syminfo.prefix)",
            "[syminfo.prefix](#fun_syminfo.prefix)",
            "[ticker.new](#fun_ticker.new)"
          ],
          "examples": "//@version=5\nindicator(\"syminfo.ticker fun\", overlay=true) \ni_sym = input.symbol(\"NASDAQ:AAPL\")\npref = syminfo.prefix(i_sym)\ntick = syminfo.ticker(i_sym)\nt = ticker.new(pref, tick, session.extended)\ns = request.security(t, \"1D\", close)\nplot(s)",
          "returnedType": "string",
          "returnedTypes": [
            "simple string",
            "input string",
            "const string",
            "series string"
          ]
        },
        {
          "name": "time",
          "kind": "Built-in Function",
          "desc": "The time function returns the UNIX time of the current bar for the specified timeframe and session or NaN if the time point is out of session.",
          "args": [
            {
              "name": "timeframe",
              "desc": "Timeframe. An empty string is interpreted as the current timeframe of the chart.",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "isString": true,
              "possibleValues": [
                "\"\"",
                "1",
                "5",
                "15",
                "60",
                "D"
              ]
            },
            {
              "name": "session",
              "desc": "Session specification. Optional argument, session of the symbol is used by default.  \nAn empty string is interpreted as the session of the symbol.",
              "default": "\"\"",
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "timezone",
              "desc": "Timezone of the `session` argument. Can only be used when a `session` is specified.  \nOptional. The default is [syminfo.timezone](#var_syminfo.timezone).  \nCan be specified in GMT notation (e.g. \"GMT-5\") or as an [IANA time zone database name](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones) (e.g. \"America/New_York\").",
              "default": "syminfo.timezone",
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "isString": true,
              "possibleValues": [
                "GMT",
                "America/New_York",
                "UTC",
                "Europe/London"
              ]
            }
          ],
          "syntax": "time(timeframe, session, timezone) → series int",
          "remarks": "UNIX time is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970.",
          "returns": "UNIX time.",
          "seeAlso": [
            "[time](#var_time) (variable)"
          ],
          "returnedType": "int",
          "detailedDesc": [
            {
              "desc": "",
              "examples": "//@version=5\nindicator(\"Time\", overlay=true)\n// Try this on chart AAPL, 1\ntimeinrange(res, sess) → not na(time(res, sess, \"America/New_York\")) ? 1 : 0\nplot(timeinrange(\"1\", \"1300-1400\"), color=color.red)\n\n// This plots 1.0 at every start of 10 minute bar on a 1 minute chart:\nnewbar(res) → ta.change(time(res)) == 0 ? 0 : 1\nplot(newbar(\"10\"))"
            },
            {
              "desc": [
                "While setting up a session you can specify not just the hours and minutes but also the days of the week that will be included in that session.",
                "If the days aren't specified, the session is considered to have been set from Sunday (1) to Saturday (7), i.e. \"1100-2000\" is the same as \"1100-1200:1234567\".",
                "",
                "You can change that by specifying the days. For example, on a symbol that is traded seven days a week with the 24-hour trading session the following script will not color Saturdays and Sundays:"
              ],
              "examples": "//@version=5\nindicator(\"Time\", overlay=true)\nt1 = time(timeframe.period, \"0000-0000:23456\")\nbgcolor(t1 ? color.new(color.blue, 90) : na)"
            },
            {
              "desc": "One `session` argument can include several different sessions, separated by commas.  \nFor example, the following script will highlight the bars from 10:00 to 11:00 and from 14:00 to 15:00 (workdays only):",
              "examples": "//@version=5\nindicator(\"Time\", overlay=true)\nt1 = time(timeframe.period, \"1000-1100, 1400-1500:23456\")\nbgcolor(t1 ? color.new(color.blue, 90) : na)"
            }
          ],
          "returnedTypes": [
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "time_close",
          "desc": "Returns the UNIX time of the current bar\\`s close for the specified timeframe and session, or [na](#var_na) if the time point is outside the session.  \nOn non-standard price-based chart types (Renko, Line break, Kagi, Point & Figure, and Range), this function returns [na](#var_na) on the chart\\`s realtime bars.",
          "args": [
            {
              "name": "timeframe",
              "desc": "Resolution. An empty string is interpreted as the current resolution of the chart.",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "isString": true,
              "possibleValues": [
                "\"\"",
                "1",
                "5",
                "15",
                "60",
                "D"
              ]
            },
            {
              "name": "session",
              "desc": "Session specification. Optional argument, session of the symbol is used by default.  \nAn empty string is interpreted as the session of the symbol.",
              "default": "\"\"",
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "timezone",
              "desc": "Timezone of the `session` argument. Can only be used when a `session` is specified.  \nOptional. The default is [syminfo.timezone](#var_syminfo.timezone).  \nCan be specified in GMT notation (e.g. \"GMT-5\") or as an [IANA time zone database name](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones) (e.g. \"America/New_York\").",
              "default": "syminfo.timezone",
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "isString": true,
              "possibleValues": [
                "GMT",
                "America/New_York",
                "UTC",
                "Europe/London",
                "Asia/Tokyo"
              ]
            }
          ],
          "syntax": "time_close(timeframe, session, timezone) → series int",
          "remarks": "UNIX time is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970.",
          "returns": "UNIX time.",
          "seeAlso": [
            "[time_close](#var_time_close) (variable)"
          ],
          "returnedType": "int",
          "detailedDesc": [
            {
              "desc": "",
              "examples": "//@version=5\nindicator(\"Time\", overlay=true)\nt1 = time_close(timeframe.period, \"1200-1300\", \"America/New_York\")\nbgcolor(t1 ? color.new(color.blue, 90) : na)"
            }
          ],
          "returnedTypes": [
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "year",
          "args": [
            {
              "name": "time",
              "desc": "UNIX time in milliseconds.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "timezone",
              "desc": "Allows adjusting the returned value to a time zone specified in either UTC/GMT notation (e.g., \"UTC-5\", \"GMT+0530\") or as an IANA time zone database name (e.g., \"America/New_York\").  \nOptional. The default is [syminfo.timezone](#var_syminfo.timezone).",
              "default": "syminfo.timezone",
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "isString": true,
              "possibleValues": [
                "UTC",
                "GMT",
                "America/New_York",
                "Europe/London",
                "Asia/Tokyo"
              ]
            }
          ],
          "syntax": "year(time, timezone) → series int",
          "remarks": "UNIX time is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970.\nNote that this function returns the year based on the time of the bar\\`s open.  \nFor overnight sessions (e.g.  \nEURUSD, where Monday session starts on Sunday, 17:00 UTC-4) this value can be lower by 1 than the year of the trading day.",
          "returns": "Year (in exchange timezone) for provided UNIX time.",
          "seeAlso": [
            "[year](#var_year)",
            "[time](#fun_time)",
            "[month](#fun_month)",
            "[dayofmonth](#fun_dayofmonth)",
            "[dayofweek](#fun_dayofweek)",
            "[hour](#fun_hour)",
            "[minute](#fun_minute)",
            "[second](#fun_second)"
          ],
          "returnedType": "int",
          "returnedTypes": [
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "month",
          "args": [
            {
              "name": "time",
              "desc": "UNIX time in milliseconds.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "time",
                "time_close",
                "last_bar_index",
                "last_bar_time"
              ]
            },
            {
              "name": "timezone",
              "desc": "Allows adjusting the returned value to a time zone specified in either UTC/GMT notation (e.g., \"UTC-5\", \"GMT+0530\") or as an IANA time zone database name (e.g., \"America/New_York\").  \nOptional. The default is [syminfo.timezone](#var_syminfo.timezone).",
              "default": "syminfo.timezone",
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "isString": true,
              "possibleValues": [
                "UTC",
                "GMT",
                "America/New_York",
                "Europe/London",
                "Asia/Tokyo"
              ]
            }
          ],
          "syntax": "month(time, timezone) → series int",
          "remarks": "UNIX time is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970.\nNote that this function returns the month based on the time of the bar\\`s open.  \nFor overnight sessions (e.g.  \nEURUSD, where Monday session starts on Sunday, 17:00 UTC-4) this value can be lower by 1 than the month of the trading day.",
          "returns": "Month (in exchange timezone) for provided UNIX time.",
          "seeAlso": [
            "[month](#var_month)",
            "[time](#fun_time)",
            "[year](#fun_year)",
            "[dayofmonth](#fun_dayofmonth)",
            "[dayofweek](#fun_dayofweek)",
            "[hour](#fun_hour)",
            "[minute](#fun_minute)",
            "[second](#fun_second)"
          ],
          "returnedType": "int",
          "returnedTypes": [
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "weekofyear",
          "args": [
            {
              "name": "time",
              "desc": "UNIX time in milliseconds.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "time",
                "time_close"
              ]
            },
            {
              "name": "timezone",
              "desc": "Allows adjusting the returned value to a time zone specified in either UTC/GMT notation (e.g., \"UTC-5\", \"GMT+0530\") or as an IANA time zone database name (e.g., \"America/New_York\").  \nOptional. The default is [syminfo.timezone](#var_syminfo.timezone).",
              "default": "syminfo.timezone",
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "isString": true,
              "possibleValues": [
                "UTC",
                "GMT",
                "America/New_York",
                "Europe/London",
                "Asia/Tokyo"
              ]
            }
          ],
          "syntax": "weekofyear(time, timezone) → series int",
          "remarks": "UNIX time is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970.\nNote that this function returns the week based on the time of the bar\\`s open.  \nFor overnight sessions (e.g.  \nEURUSD, where Monday session starts on Sunday, 17:00) this value can be lower by 1 than the week of the trading day.",
          "returns": "Week of year (in exchange timezone) for provided UNIX time.",
          "seeAlso": [
            "[weekofyear](#var_weekofyear)",
            "[time](#fun_time)",
            "[year](#fun_year)",
            "[month](#fun_month)",
            "[dayofmonth](#fun_dayofmonth)",
            "[dayofweek](#fun_dayofweek)",
            "[hour](#fun_hour)",
            "[minute](#fun_minute)",
            "[second](#fun_second)"
          ],
          "returnedType": "int",
          "returnedTypes": [
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "dayofmonth",
          "args": [
            {
              "name": "time",
              "desc": "UNIX time in milliseconds.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "time"
              ]
            },
            {
              "name": "timezone",
              "desc": "Allows adjusting the returned value to a time zone specified in either UTC/GMT notation (e.g., \"UTC-5\", \"GMT+0530\") or as an IANA time zone database name (e.g., \"America/New_York\").  \nOptional. The default is [syminfo.timezone](#var_syminfo.timezone).",
              "default": "syminfo.timezone",
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "isString": true,
              "possibleValues": [
                "UTC",
                "GMT",
                "America/New_York",
                "Europe/London",
                "Asia/Tokyo"
              ]
            }
          ],
          "syntax": "dayofmonth(time, timezone) → series int",
          "remarks": "UNIX time is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970.\nNote that this function returns the day based on the time of the bar\\`s open.  \nFor overnight sessions (e.g.  \nEURUSD, where Monday session starts on Sunday, 17:00 UTC-4) this value can be lower by 1 than the day of the trading day.",
          "returns": "Day of month (in exchange timezone) for provided UNIX time.",
          "seeAlso": [
            "[dayofmonth](#var_dayofmonth)",
            "[time](#fun_time)",
            "[year](#fun_year)",
            "[month](#fun_month)",
            "[dayofweek](#fun_dayofweek)",
            "[hour](#fun_hour)",
            "[minute](#fun_minute)",
            "[second](#fun_second)"
          ],
          "returnedType": "int",
          "returnedTypes": [
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "dayofweek",
          "args": [
            {
              "name": "time",
              "desc": "UNIX time in milliseconds.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "time",
                "time_close"
              ]
            },
            {
              "name": "timezone",
              "desc": "Allows adjusting the returned value to a time zone specified in either UTC/GMT notation (e.g., \"UTC-5\", \"GMT+0530\") or as an IANA time zone database name (e.g., \"America/New_York\").  \nOptional. The default is [syminfo.timezone](#var_syminfo.timezone).",
              "default": "syminfo.timezone",
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "isString": true,
              "possibleValues": [
                "UTC",
                "GMT",
                "America/New_York",
                "Europe/London",
                "Asia/Tokyo"
              ]
            }
          ],
          "syntax": "dayofweek(time, timezone) → series int",
          "remarks": "Note that this function returns the day based on the time of the bar\\`s open. For overnight sessions (e.g.  \nEURUSD, where Monday session starts on Sunday, 17:00) this value can be lower by 1 than the day of the trading day.\nUNIX time is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970.",
          "returns": "Day of week (in exchange timezone) for provided UNIX time.",
          "seeAlso": [
            "[dayofweek](#var_dayofweek)",
            "[time](#fun_time)",
            "[year](#fun_year)",
            "[month](#fun_month)",
            "[dayofmonth](#fun_dayofmonth)",
            "[hour](#fun_hour)",
            "[minute](#fun_minute)",
            "[second](#fun_second)"
          ],
          "returnedType": "int",
          "returnedTypes": [
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "hour",
          "args": [
            {
              "name": "time",
              "desc": "UNIX time in milliseconds.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "timezone",
              "desc": "Allows adjusting the returned value to a time zone specified in either UTC/GMT notation (e.g., \"UTC-5\", \"GMT+0530\") or as an IANA time zone database name (e.g., \"America/New_York\").  \nOptional. The default is [syminfo.timezone](#var_syminfo.timezone).",
              "default": "syminfo.timezone",
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "isString": true,
              "possibleValues": [
                "UTC",
                "GMT",
                "America/New_York",
                "Europe/London",
                "Asia/Tokyo"
              ]
            }
          ],
          "syntax": "hour(time, timezone) → series int",
          "remarks": "UNIX time is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970.",
          "returns": "Hour (in exchange timezone) for provided UNIX time.",
          "seeAlso": [
            "[hour](#var_hour)",
            "[time](#fun_time)",
            "[year](#fun_year)",
            "[month](#fun_month)",
            "[dayofmonth](#fun_dayofmonth)",
            "[dayofweek](#fun_dayofweek)",
            "[minute](#fun_minute)",
            "[second](#fun_second)"
          ],
          "returnedType": "int",
          "returnedTypes": [
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "minute",
          "args": [
            {
              "name": "time",
              "desc": "UNIX time in milliseconds.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "timezone",
              "desc": "Allows adjusting the returned value to a time zone specified in either UTC/GMT notation (e.g., \"UTC-5\", \"GMT+0530\") or as an IANA time zone database name (e.g., \"America/New_York\").  \nOptional. The default is [syminfo.timezone](#var_syminfo.timezone).",
              "default": "syminfo.timezone",
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "isString": true,
              "possibleValues": [
                "UTC",
                "GMT",
                "America/New_York",
                "Europe/London",
                "Asia/Tokyo"
              ]
            }
          ],
          "syntax": "minute(time, timezone) → series int",
          "remarks": "UNIX time is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970.",
          "returns": "Minute (in exchange timezone) for provided UNIX time.",
          "seeAlso": [
            "[minute](#var_minute)",
            "[time](#fun_time)",
            "[year](#fun_year)",
            "[month](#fun_month)",
            "[dayofmonth](#fun_dayofmonth)",
            "[dayofweek](#fun_dayofweek)",
            "[hour](#fun_hour)",
            "[second](#fun_second)"
          ],
          "returnedType": "int",
          "returnedTypes": [
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "second",
          "args": [
            {
              "name": "time",
              "desc": "UNIX time in milliseconds.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "timezone",
              "desc": "Allows adjusting the returned value to a time zone specified in either UTC/GMT notation (e.g., \"UTC-5\", \"GMT+0530\") or as an IANA time zone database name (e.g., \"America/New_York\").  \nOptional. The default is [syminfo.timezone](#var_syminfo.timezone).",
              "default": "syminfo.timezone",
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "isString": true,
              "possibleValues": [
                "UTC",
                "GMT",
                "America/New_York",
                "Asia/Tokyo",
                "Europe/London"
              ]
            }
          ],
          "syntax": "second(time, timezone) → series int",
          "remarks": "UNIX time is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970.",
          "returns": "Second (in exchange timezone) for provided UNIX time.",
          "seeAlso": [
            "[second](#var_second)",
            "[time](#fun_time)",
            "[year](#fun_year)",
            "[month](#fun_month)",
            "[dayofmonth](#fun_dayofmonth)",
            "[dayofweek](#fun_dayofweek)",
            "[hour](#fun_hour)",
            "[minute](#fun_minute)"
          ],
          "returnedType": "int",
          "returnedTypes": [
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "float",
          "desc": "Casts na to float",
          "args": [
            {
              "name": "x",
              "desc": "'na' to cast to float.",
              "default": null,
              "required": true,
              "displayType": "series float",
              "allowedTypeIDs": [
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "na"
              ]
            }
          ],
          "syntax": "float(x) → series float",
          "returns": "The value of the argument after casting to float.",
          "seeAlso": [
            "[int](#fun_int)",
            "[bool](#fun_bool)",
            "[color](#fun_color)",
            "[string](#fun_string)",
            "[line](#fun_line)",
            "[label](#fun_label)"
          ],
          "returnedType": "float",
          "returnedTypes": [
            "const float",
            "input float",
            "simple float",
            "series float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "int",
          "desc": "Casts na or truncates float value to int.",
          "args": [
            {
              "name": "x",
              "desc": "'na' to cast to int.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "int(x) → series int",
          "returns": "The value of the argument after casting to int.",
          "seeAlso": [
            "[float](#fun_float)",
            "[bool](#fun_bool)",
            "[color](#fun_color)",
            "[string](#fun_string)",
            "[line](#fun_line)",
            "[label](#fun_label)"
          ],
          "returnedType": "int",
          "returnedTypes": [
            "simple int",
            "input int",
            "const int",
            "series int"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "bool",
          "desc": "Casts na to bool.",
          "args": [
            {
              "name": "x",
              "desc": "'na' to cast to color.",
              "default": null,
              "required": true,
              "displayType": "series color",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "bool(x) → series bool",
          "returns": "The value of the argument after casting to bool.",
          "seeAlso": [
            "[float](#fun_float)",
            "[int](#fun_int)",
            "[color](#fun_color)",
            "[string](#fun_string)",
            "[line](#fun_line)",
            "[label](#fun_label)"
          ],
          "returnedType": "bool",
          "returnedTypes": [
            "const bool",
            "input bool",
            "simple bool",
            "series bool"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "color",
          "desc": "Casts na to color",
          "args": [
            {
              "name": "x",
              "desc": "'na' to cast to color.",
              "default": null,
              "required": true,
              "displayType": "series color",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "color(x) → series color",
          "returns": "The value of the argument after casting to color.",
          "seeAlso": [
            "[float](#fun_float)",
            "[int](#fun_int)",
            "[bool](#fun_bool)",
            "[string](#fun_string)",
            "[line](#fun_line)",
            "[label](#fun_label)"
          ],
          "returnedType": "color",
          "returnedTypes": [
            "const color",
            "input color",
            "simple color",
            "series color"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "string",
          "desc": "Casts na to string.",
          "args": [
            {
              "name": "x",
              "desc": "'na' to cast to string.",
              "default": null,
              "required": true,
              "displayType": "series color",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "string(x) → series string",
          "returns": "The value of the argument after casting to string.",
          "seeAlso": [
            "[float](#fun_float)",
            "[int](#fun_int)",
            "[bool](#fun_bool)",
            "[color](#fun_color)",
            "[line](#fun_line)",
            "[label](#fun_label)"
          ],
          "returnedType": "string",
          "returnedTypes": [
            "const string",
            "input string",
            "simple string",
            "series string"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "line",
          "desc": "Casts na to line.",
          "args": [
            {
              "name": "x",
              "desc": "'na' to cast to line..",
              "default": null,
              "required": true,
              "displayType": "series line",
              "allowedTypeIDs": [
                "series line"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "line(x) → series line",
          "returns": "The value of the argument after casting to line.",
          "seeAlso": [
            "[float](#fun_float)",
            "[int](#fun_int)",
            "[bool](#fun_bool)",
            "[color](#fun_color)",
            "[string](#fun_string)",
            "[label](#fun_label)"
          ],
          "returnedType": "line",
          "returnedTypes": [
            "series line"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "label",
          "desc": "Casts na to label.",
          "args": [
            {
              "name": "x",
              "desc": "'na' to cast to label..",
              "default": null,
              "required": true,
              "displayType": "series label",
              "allowedTypeIDs": [
                "series label"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "label(x) → series label",
          "returns": "The value of the argument after casting to label.",
          "seeAlso": [
            "[float](#fun_float)",
            "[int](#fun_int)",
            "[bool](#fun_bool)",
            "[color](#fun_color)",
            "[string](#fun_string)",
            "[line](#fun_line)"
          ],
          "returnedType": "label",
          "returnedTypes": [
            "series label"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "table",
          "desc": "Casts na to table.",
          "args": [
            {
              "name": "x",
              "desc": "'na' to cast to table.",
              "default": null,
              "required": true,
              "displayType": "series table",
              "allowedTypeIDs": [
                "series table"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "table(x) → series table",
          "returns": "The value of the argument after casting to table.",
          "seeAlso": [
            "[float](#fun_float)",
            "[int](#fun_int)",
            "[bool](#fun_bool)",
            "[color](#fun_color)",
            "[string](#fun_string)",
            "[line](#fun_line)",
            "[label](#fun_label)"
          ],
          "returnedType": "table",
          "returnedTypes": [
            "series table"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "box",
          "desc": "Casts na to box.",
          "args": [
            {
              "name": "x",
              "desc": "'na' to cast to box.",
              "default": null,
              "required": true,
              "displayType": "series box",
              "allowedTypeIDs": [
                "series box"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "box(x) → series box",
          "returns": "The value of the argument after casting to box.",
          "seeAlso": [
            "[float](#fun_float)",
            "[int](#fun_int)",
            "[bool](#fun_bool)",
            "[color](#fun_color)",
            "[string](#fun_string)",
            "[line](#fun_line)",
            "[label](#fun_label)"
          ],
          "returnedType": "box",
          "returnedTypes": [
            "series box"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "linefill",
          "desc": "Casts na to linefill.",
          "args": [
            {
              "name": "x",
              "desc": "'na' to cast to linefill.",
              "default": null,
              "required": true,
              "displayType": "series linefill",
              "allowedTypeIDs": [
                "series linefill"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "linefill(x) → series linefill",
          "returns": "The value of the argument after casting to linefill.",
          "seeAlso": [
            "[float](#fun_float)",
            "[int](#fun_int)",
            "[bool](#fun_bool)",
            "[color](#fun_color)",
            "[string](#fun_string)",
            "[line](#fun_line)",
            "[label](#fun_label)"
          ],
          "returnedType": "linefill",
          "returnedTypes": [
            "series linefill"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "indicator",
          "desc": "This declaration statement designates the script as an indicator and sets a number of indicator-related properties.",
          "args": [
            {
              "name": "title",
              "desc": "The title of the script. It is displayed on the chart when no `shorttitle` argument is used, and becomes the publication\\`s default title when publishing the script.",
              "default": null,
              "required": true,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "shorttitle",
              "desc": "The script\\`s display name on charts. If specified, it will replace the `title` argument in most chart-related windows.  \nOptional. The default is the argument used for `title`.",
              "default": null,
              "required": false,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "overlay",
              "desc": "If [true](#op_true), the indicator will be displayed over the chart.  \nIf [false](#op_false), it will be added in a separate pane.  \nOptional. The default is [false](#op_false).",
              "default": "false",
              "required": false,
              "displayType": "const bool",
              "allowedTypeIDs": [
                "const bool"
              ],
              "possibleValues": [
                "true",
                "false"
              ]
            },
            {
              "name": "format",
              "desc": "Specifies the formatting of the script\\`s displayed values.  \nPossible values: [format.inherit](#var_format.inherit), [format.price](#var_format.price), [format.volume](#var_format.volume), [format.percent](#var_format.percent).  \nOptional. The default is [format.inherit](#var_format.inherit).",
              "default": "format.inherit",
              "required": false,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": [
                "format.inherit",
                "format.price",
                "format.volume",
                "format.percent"
              ]
            },
            {
              "name": "precision",
              "desc": "Specifies the number of digits after the floating point of the script\\`s displayed values.  \nMust be a non-negative integer no greater than 16.  \nIf `format` is set to [format.inherit](#var_format.inherit) and `precision` is specified, the format will instead be set to [format.price](#var_format.price).  \nOptional. The default is inherited from the precision of the chart\\`s symbol.",
              "default": "syminfo.pricescale",
              "required": false,
              "displayType": "const int",
              "allowedTypeIDs": [
                "const int"
              ],
              "possibleValues": [
                "0",
                "1",
                "2",
                "3",
                "4"
              ]
            },
            {
              "name": "scale",
              "desc": "The price scale used.  \nPossible values: [scale.right](#var_scale.right), [scale.left](#var_scale.left), [scale.none](#var_scale.none).  \nThe [scale.none](#var_scale.none) value can only be applied in combination with `overlay = true`.  \nOptional. By default, the script uses the same scale as the chart.",
              "default": "scale.right",
              "required": false,
              "displayType": "const scale_type",
              "allowedTypeIDs": [
                "const scale_type"
              ],
              "possibleValues": [
                "scale.right",
                "scale.left",
                "scale.none"
              ]
            },
            {
              "name": "max_bars_back",
              "desc": "The length of the historical buffer the script keeps for every variable and function, which determines how many past values can be referenced using the `[]` history-referencing operator.  \nThe required buffer size is automatically detected by the Pine Script™ runtime.  \nUsing this parameter is only necessary when a runtime error occurs because automatic detection fails.  \nMore information on the underlying mechanics of the historical buffer can be found [in our Help Center](https://www.tradingview.com/chart/?solution=43000587849).  \nOptional. The default is 0.",
              "default": "0",
              "required": false,
              "displayType": "const int",
              "allowedTypeIDs": [
                "const int"
              ],
              "possibleValues": [
                "0",
                "10",
                "20",
                "50",
                "100",
                "200"
              ]
            },
            {
              "name": "timeframe",
              "desc": "Adds multi-timeframe functionality to simple scripts. When used, a \"Timeframe\" field will be added to the script\\`s \"Settings/Inputs\" tab.  \nThe field\\`s default value will be the argument supplied, whose format must conform to [timeframe string specifications](https://www.tradingview.com/pine-script-docs/en/v5/concepts/Timeframes.html#timeframe-string-specifications).  \nTo specify the chart\\`s timeframe, use an empty string or the [timeframe.period](#var_timeframe.period) variable.  \nThe parameter cannot be used with scripts using Pine Script™ drawings.  \nOptional. The default is [timeframe.period](#var_timeframe.period).",
              "default": "timeframe.period",
              "required": false,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "isString": true,
              "possibleValues": [
                "\"\"",
                "D",
                "W",
                "M",
                "240",
                "60",
                "15",
                "5"
              ]
            },
            {
              "name": "timeframe_gaps",
              "desc": "Specifies how the indicator\\`s values are displayed on chart bars when the `timeframe` is higher than the chart\\`s.  \nIf [true](#op_true), a value only appears on a chart bar when the higher `timeframe` value becomes available, otherwise [na](#var_na) is returned (thus a \"gap\" occurs).  \nWith [false](#op_false), what would otherwise be gaps are filled with the latest known value returned, avoiding [na](#var_na) values.  \nWhen used, a \"Gaps\" checkbox will appear in the indicator\\`s \"Settings/Inputs\" tab.  \nOptional. The default is [true](#op_true).",
              "default": "true",
              "required": false,
              "displayType": "const bool",
              "allowedTypeIDs": [
                "const bool"
              ],
              "possibleValues": [
                "true",
                "false"
              ]
            },
            {
              "name": "explicit_plot_zorder",
              "desc": "Specifies the order in which the script\\`s plots, fills, and hlines are rendered.  \nIf [true](#op_true), plots are drawn in the order in which they appear in the script\\`s code, each newer plot being drawn above the previous ones.  \nThis only applies to `plot*()` functions, [fill](#fun_fill), and [hline](#fun_hline).  \nOptional. The default is [false](#op_false).",
              "default": "false",
              "required": false,
              "displayType": "const bool",
              "allowedTypeIDs": [
                "const bool"
              ],
              "possibleValues": [
                "true",
                "false"
              ]
            },
            {
              "name": "max_lines_count",
              "desc": "The number of last [line](#op_line) drawings displayed. \nPossible values: 1-500.  \nThe count is approximate; more drawings than the specified count may be displayed.  \nOptional. The default is 50.",
              "default": 50,
              "required": false,
              "displayType": "const int",
              "allowedTypeIDs": [
                "const int"
              ],
              "possibleValues": [
                "100",
                "200",
                "300",
                "500"
              ]
            },
            {
              "name": "max_labels_count",
              "desc": "The number of last [label](#op_label) drawings displayed. \nPossible values: 1-500.  \nThe count is approximate; more drawings than the specified count may be displayed.  \nOptional. The default is 50.",
              "default": 50,
              "required": false,
              "displayType": "const int",
              "allowedTypeIDs": [
                "const int"
              ],
              "possibleValues": [
                "100",
                "200",
                "300",
                "500"
              ]
            },
            {
              "name": "max_boxes_count",
              "desc": "The number of last [box](#op_box) drawings displayed. \nPossible values: 1-500.  \nThe count is approximate; more drawings than the specified count may be displayed.  \nOptional. The default is 50.",
              "default": 50,
              "required": false,
              "displayType": "const int",
              "allowedTypeIDs": [
                "const int"
              ],
              "possibleValues": [
                "100",
                "200",
                "300",
                "500"
              ]
            },
            {
              "name": "max_polylines_count",
              "desc": "The number of last [polyline](#op_polyline) drawings displayed.  \nPossible values: 1-100. The count is approximate; more drawings than the specified count may be displayed. Optional. The default is 50.",
              "default": 50,
              "required": false,
              "displayType": "const int",
              "allowedTypeIDs": [
                "const int"
              ],
              "possibleValues": [
                "20",
                "40",
                "60",
                "100"
              ]
            }
          ],
          "syntax": "indicator(title, shorttitle, overlay, format, precision, scale, max_bars_back, timeframe, timeframe_gaps, explicit_plot_zorder, max_lines_count, max_labels_count, max_boxes_count, max_polylines_count) → void",
          "remarks": "Every indicator script must have one [indicator](#fun_indicator) call.",
          "seeAlso": [
            "[strategy](#fun_strategy)",
            "[library](#fun_library)"
          ],
          "examples": "//@version=5\nindicator(\"My script\", shorttitle=\"Script\")\nplot(close)",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "plot",
          "desc": "Plots a series of data on the chart.",
          "args": [
            {
              "name": "series",
              "desc": "Series of data to be plotted. Required argument.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            },
            {
              "name": "title",
              "desc": "Title of the plot.",
              "default": null,
              "required": true,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "color",
              "desc": "Color of the plot. You can use constants like 'color=color.red' or 'color=#ff001a' as well as complex expressions like 'color = close >= open ? color.green : color.red'.  \nOptional argument.",
              "default": "color.black",
              "required": false,
              "displayType": "series color",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "possibleValues": [
                "colors"
              ]
            },
            {
              "name": "linewidth",
              "desc": "Width of the plotted line. Default value is 1. Not applicable to every style.",
              "default": "1",
              "required": false,
              "displayType": "input int",
              "allowedTypeIDs": [
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            },
            {
              "name": "style",
              "desc": "Type of plot. Possible values are: [plot.style_line](#var_plot.style_line), [plot.style_stepline](#var_plot.style_stepline), [plot.style_stepline_diamond](#var_plot.style_stepline_diamond), [plot.style_histogram](#var_plot.style_histogram), [plot.style_cross](#var_plot.style_cross), [plot.style_area](#var_plot.style_area), [plot.style_columns](#var_plot.style_columns), [plot.style_circles](#var_plot.style_circles), [plot.style_linebr](#var_plot.style_linebr), [plot.style_areabr](#var_plot.style_areabr), [plot.style_steplinebr](#var_plot.style_steplinebr).  \nDefault value is [plot.style_line](#var_plot.style_line).",
              "default": "plot.style_line",
              "required": false,
              "displayType": "input plot_style",
              "allowedTypeIDs": [
                "input plot_style"
              ],
              "possibleValues": [
                "plot.style_line",
                "plot.style_stepline",
                "plot.style_histogram",
                "plot.style_cross",
                "plot.style_area"
              ]
            },
            {
              "name": "trackprice",
              "desc": "If true then a horizontal price line will be shown at the level of the last indicator value.  \nDefault is false.",
              "default": "false",
              "required": false,
              "displayType": "input bool",
              "allowedTypeIDs": [
                "input bool",
                "const bool"
              ],
              "possibleValues": [
                "true",
                "false"
              ]
            },
            {
              "name": "histbase",
              "desc": "The price value used as the reference level when rendering plot with [plot.style_histogram](#var_plot.style_histogram), [plot.style_columns](#var_plot.style_columns) or [plot.style_area](#var_plot.style_area) style.  \nDefault is 0.0.",
              "default": "0.0",
              "required": false,
              "displayType": "input int|float",
              "allowedTypeIDs": [
                "input int",
                "const int",
                "input float",
                "const float"
              ],
              "possibleValues": null
            },
            {
              "name": "offset",
              "desc": "Shifts the plot to the left or to the right on the given number of bars. Default is 0.",
              "default": "0",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "join",
              "desc": "If true then plot points will be joined with line, applicable only to [plot.style_cross](#var_plot.style_cross) and [plot.style_circles](#var_plot.style_circles) styles.  \nDefault is false.",
              "default": "false",
              "required": false,
              "displayType": "input bool",
              "allowedTypeIDs": [
                "input bool",
                "const bool"
              ],
              "possibleValues": [
                "true",
                "false"
              ]
            },
            {
              "name": "editable",
              "desc": "If true then plot style will be editable in Format dialog. Default is true.",
              "default": "true",
              "required": false,
              "displayType": "const bool",
              "allowedTypeIDs": [
                "const bool"
              ],
              "possibleValues": [
                "true",
                "false"
              ]
            },
            {
              "name": "show_last",
              "desc": "If set, defines the number of bars (from the last bar back to the past) to plot on chart.",
              "default": null,
              "required": true,
              "displayType": "input int",
              "allowedTypeIDs": [
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "display",
              "desc": "Controls where the plot\\`s information is displayed. Display options support addition and subtraction, meaning that using `display.all - display.status_line` will display the plot\\`s information everywhere except in the script\\`s status line. `display.price_scale + display.status_line` will display the plot only in the price scale and status line.  \nWhen `display` arguments such as `display.price_scale` have user-controlled chart settings equivalents, the relevant plot information will only appear when all settings allow for it. \nPossible values: [display.none](#var_display.none), [display.pane](#var_display.pane), [display.data_window](#var_display.data_window), [display.price_scale](#var_display.price_scale), [display.status_line](#var_display.status_line), [display.all](#var_display.all).  \nOptional. The default is [display.all](#var_display.all).",
              "default": "display.all",
              "required": false,
              "displayType": "input plot_display",
              "allowedTypeIDs": [
                "input plot_display"
              ],
              "possibleValues": [
                "display.none",
                "display.pane",
                "display.data_window",
                "display.price_scale",
                "display.status_line",
                "display.all"
              ]
            }
          ],
          "syntax": "plot(series, title, color, linewidth, style, trackprice, histbase, offset, join, editable, show_last, display) → plot",
          "returns": "A plot object, that can be used in [fill](#fun_fill)",
          "seeAlso": [
            "[plotshape](#fun_plotshape)",
            "[plotchar](#fun_plotchar)",
            "[plotarrow](#fun_plotarrow)",
            "[barcolor](#fun_barcolor)",
            "[bgcolor](#fun_bgcolor)",
            "[fill](#fun_fill)"
          ],
          "examples": "//@version=5\nindicator(\"plot\")\nplot(high+low, title='Title', color=color.new(#00ffaa, 70), linewidth=2, style=plot.style_area, offset=15, trackprice=true)\n\n// You may fill the background between any two plots with a fill() function:\np1 = plot(open)\np2 = plot(close)\nfill(p1, p2, color=color.new(color.green, 90))",
          "returnedType": "plot",
          "returnedTypes": [
            "plot"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "plotshape",
          "desc": "Plots visual shapes on the chart.",
          "args": [
            {
              "name": "series",
              "desc": "Series of data to be plotted as shapes. Series is treated as a series of boolean values for all location values except [location.absolute](#var_location.absolute).  \nRequired argument.",
              "default": null,
              "required": true,
              "displayType": "series bool",
              "allowedTypeIDs": [
                "series bool",
                "simple bool",
                "input bool",
                "const bool"
              ],
              "possibleValues": null
            },
            {
              "name": "title",
              "desc": "Title of the plot.",
              "default": null,
              "required": true,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "style",
              "desc": "Type of plot. Possible values are: [shape.xcross](#var_shape.xcross), [shape.cross](#var_shape.cross), [shape.triangleup](#var_shape.triangleup), [shape.triangledown](#var_shape.triangledown), [shape.flag](#var_shape.flag), [shape.circle](#var_shape.circle), [shape.arrowup](#var_shape.arrowup), [shape.arrowdown](#var_shape.arrowdown), [shape.labelup](#var_shape.labelup), [shape.labeldown](#var_shape.labeldown), [shape.square](#var_shape.square), [shape.diamond](#var_shape.diamond).  \nDefault value is [shape.xcross](#var_shape.xcross).",
              "default": "shape.xcross",
              "required": false,
              "displayType": "input string",
              "allowedTypeIDs": [
                "input string",
                "const string"
              ],
              "possibleValues": [
                "shape.xcross",
                "shape.cross",
                "shape.triangleup",
                "shape.triangledown",
                "shape.flag"
              ]
            },
            {
              "name": "location",
              "desc": "Location of shapes on the chart. Possible values are: [location.abovebar](#var_location.abovebar), [location.belowbar](#var_location.belowbar), [location.top](#var_location.top), [location.bottom](#var_location.bottom), [location.absolute](#var_location.absolute).  \nDefault value is [location.abovebar](#var_location.abovebar).",
              "default": "location.abovebar",
              "required": true,
              "displayType": "input string",
              "allowedTypeIDs": [
                "input string",
                "const string"
              ],
              "possibleValues": [
                "location.abovebar",
                "location.belowbar",
                "location.top",
                "location.bottom",
                "location.absolute"
              ]
            },
            {
              "name": "color",
              "desc": "Color of the shapes. You can use constants like 'color=color.red' or 'color=#ff001a' as well as complex expressions like 'color = close >= open ? color.green : color.red'.  \nOptional argument.",
              "default": "color.black",
              "required": false,
              "displayType": "series color",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "possibleValues": [
                "colors"
              ]
            },
            {
              "name": "offset",
              "desc": "Shifts shapes to the left or to the right on the given number of bars. Default is 0.",
              "default": "0",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "text",
              "desc": "Text to display with the shape. You can use multiline text, to separate lines use '\\n' escape sequence.  \nExample: 'line one\\nline two'.",
              "default": null,
              "required": true,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "textcolor",
              "desc": "Color of the text. You can use constants like 'textcolor=color.red' or 'textcolor=#ff001a' as well as complex expressions like 'textcolor = close >= open ? color.green : color.red'.  \nOptional argument.",
              "default": "color.black",
              "required": false,
              "displayType": "series color",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "possibleValues": [
                "colors"
              ]
            },
            {
              "name": "editable",
              "desc": "If true then plotshape style will be editable in Format dialog. Default is true.",
              "default": "true",
              "required": false,
              "displayType": "const bool",
              "allowedTypeIDs": [
                "const bool"
              ],
              "possibleValues": [
                "true",
                "false"
              ]
            },
            {
              "name": "show_last",
              "desc": "If set, defines the number of shapes (from the last bar back to the past) to plot on chart.",
              "default": null,
              "required": true,
              "displayType": "input int",
              "allowedTypeIDs": [
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "size",
              "desc": "Size of shapes on the chart. Possible values are: [size.auto](#var_size.auto), [size.tiny](#var_size.tiny), [size.small](#var_size.small), [size.normal](#var_size.normal), [size.large](#var_size.large), [size.huge](#var_size.huge).  \nDefault is [size.auto](#var_size.auto).",
              "default": "size.auto",
              "required": false,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": [
                "size.auto",
                "size.tiny",
                "size.small",
                "size.normal",
                "size.large",
                "size.huge"
              ]
            },
            {
              "name": "display",
              "desc": "Controls where the plot\\`s information is displayed. Display options support addition and subtraction, meaning that using `display.all - display.status_line` will display the plot\\`s information everywhere except in the script\\`s status line. `display.price_scale + display.status_line` will display the plot only in the price scale and status line.  \nWhen `display` arguments such as `display.price_scale` have user-controlled chart settings equivalents, the relevant plot information will only appear when all settings allow for it. \nPossible values: [display.none](#var_display.none), [display.pane](#var_display.pane), [display.data_window](#var_display.data_window), [display.price_scale](#var_display.price_scale), [display.status_line](#var_display.status_line), [display.all](#var_display.all).  \nOptional. The default is [display.all](#var_display.all).",
              "default": "display.all",
              "required": false,
              "displayType": "input plot_display",
              "allowedTypeIDs": [
                "input plot_display"
              ],
              "possibleValues": [
                "display.none",
                "display.pane",
                "display.data_window",
                "display.price_scale",
                "display.status_line",
                "display.all"
              ]
            }
          ],
          "syntax": "plotshape(series, title, style, location, color, offset, text, textcolor, editable, size, show_last, display) → void",
          "remarks": "Use [plotshape](#fun_plotshape) function in conjunction with 'overlay=true' [indicator](#fun_indicator) parameter!",
          "seeAlso": [
            "[plot](#fun_plot)",
            "[plotchar](#fun_plotchar)",
            "[plotarrow](#fun_plotarrow)",
            "[barcolor](#fun_barcolor)",
            "[bgcolor](#fun_bgcolor)"
          ],
          "examples": "//@version=5\nindicator(\"plotshape example 1\", overlay=true)\ndata = close >= open\nplotshape(data, style=shape.xcross)",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "plotchar",
          "desc": "Plots visual shapes using any given one Unicode character on the chart.",
          "args": [
            {
              "name": "series",
              "desc": "Series of data to be plotted as shapes. Series is treated as a series of boolean values for all location values except [location.absolute](#var_location.absolute).  \nRequired argument.",
              "default": null,
              "required": true,
              "displayType": "series bool",
              "allowedTypeIDs": [
                "series bool",
                "simple bool",
                "input bool",
                "const bool"
              ],
              "possibleValues": [
                "true",
                "false"
              ]
            },
            {
              "name": "title",
              "desc": "Title of the plot.",
              "default": null,
              "required": true,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "char",
              "desc": "Character to use as a visual shape.",
              "default": null,
              "required": true,
              "displayType": "input string",
              "allowedTypeIDs": [
                "input string",
                "const string"
              ],
              "isString": true,
              "possibleValues": [
                "←",
                "→",
                "↑",
                "↓",
                "●",
                "▲",
                "△",
                "◆",
                "▼",
                "▽",
                "○",
                "■",
                "□"
              ]
            },
            {
              "name": "location",
              "desc": "Location of shapes on the chart. Possible values are: [location.abovebar](#var_location.abovebar), [location.belowbar](#var_location.belowbar), [location.top](#var_location.top), [location.bottom](#var_location.bottom), [location.absolute](#var_location.absolute).  \nDefault value is [location.abovebar](#var_location.abovebar).",
              "default": "location.abovebar",
              "required": false,
              "displayType": "input string",
              "allowedTypeIDs": [
                "input string",
                "const string"
              ],
              "possibleValues": [
                "location.abovebar",
                "location.belowbar",
                "location.top",
                "location.bottom",
                "location.absolute"
              ]
            },
            {
              "name": "color",
              "desc": "Color of the shapes. You can use constants like 'color=color.red' or 'color=#ff001a' as well as complex expressions like 'color = close >= open ? color.green : color.red'.  \nOptional argument.",
              "default": "color.black",
              "required": false,
              "displayType": "series color",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "possibleValues": [
                "colors"
              ]
            },
            {
              "name": "offset",
              "desc": "Shifts shapes to the left or to the right on the given number of bars. Default is 0.",
              "default": "0",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "text",
              "desc": "Text to display with the shape. You can use multiline text, to separate lines use '\\n' escape sequence.  \nExample: 'line one\\nline two'.",
              "default": null,
              "required": true,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "textcolor",
              "desc": "Color of the text. You can use constants like 'textcolor=color.red' or 'textcolor=#ff001a' as well as complex expressions like 'textcolor = close >= open ? color.green : color.red'.  \nOptional argument.",
              "default": "color.black",
              "required": false,
              "displayType": "series color",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "possibleValues": [
                "colors"
              ]
            },
            {
              "name": "editable",
              "desc": "If true then plotchar style will be editable in Format dialog. Default is true.",
              "default": "true",
              "required": false,
              "displayType": "const bool",
              "allowedTypeIDs": [
                "const bool"
              ],
              "possibleValues": [
                "true",
                "false"
              ]
            },
            {
              "name": "show_last",
              "desc": "If set, defines the number of chars (from the last bar back to the past) to plot on chart.",
              "default": null,
              "required": true,
              "displayType": "input int",
              "allowedTypeIDs": [
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "size",
              "desc": "Size of characters on the chart. Possible values are: [size.auto](#var_size.auto), [size.tiny](#var_size.tiny), [size.small](#var_size.small), [size.normal](#var_size.normal), [size.large](#var_size.large), [size.huge](#var_size.huge).  \nDefault is [size.auto](#var_size.auto).",
              "default": "size.auto",
              "required": false,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": [
                "size.auto",
                "size.tiny",
                "size.small",
                "size.normal",
                "size.large",
                "size.huge"
              ]
            },
            {
              "name": "display",
              "desc": "Controls where the plot\\`s information is displayed. Display options support addition and subtraction, meaning that using `display.all - display.status_line` will display the plot\\`s information everywhere except in the script\\`s status line. `display.price_scale + display.status_line` will display the plot only in the price scale and status line.  \nWhen `display` arguments such as `display.price_scale` have user-controlled chart settings equivalents, the relevant plot information will only appear when all settings allow for it. \nPossible values: [display.none](#var_display.none), [display.pane](#var_display.pane), [display.data_window](#var_display.data_window), [display.price_scale](#var_display.price_scale), [display.status_line](#var_display.status_line), [display.all](#var_display.all).  \nOptional. The default is [display.all](#var_display.all).",
              "default": "display.all",
              "required": false,
              "displayType": "input plot_display",
              "allowedTypeIDs": [
                "input plot_display"
              ],
              "possibleValues": [
                "display.none",
                "display.pane",
                "display.data_window",
                "display.price_scale",
                "display.status_line",
                "display.all"
              ]
            }
          ],
          "syntax": "plotchar(series, title, char, location, color, offset, text, textcolor, editable, size, show_last, display) → void",
          "remarks": "Use [plotchar](#fun_plotchar) function in conjunction with 'overlay=true' [indicator](#fun_indicator) parameter!",
          "seeAlso": [
            "[plot](#fun_plot)",
            "[plotshape](#fun_plotshape)",
            "[plotarrow](#fun_plotarrow)",
            "[barcolor](#fun_barcolor)",
            "[bgcolor](#fun_bgcolor)"
          ],
          "examples": "//@version=5\nindicator(\"plotchar example\", overlay=true)\ndata = close >= open\nplotchar(data, char='❄')",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "plotarrow",
          "desc": "Plots up and down arrows on the chart. Up arrow is drawn at every indicator positive value, down arrow is drawn at every negative value.  \nIf indicator returns [na](#var_na) then no arrow is drawn.  \nArrows has different height, the more absolute indicator value the longer arrow is drawn.",
          "args": [
            {
              "name": "series",
              "desc": "Series of data to be plotted as arrows. Required argument.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            },
            {
              "name": "title",
              "desc": "Title of the plot.",
              "default": null,
              "required": true,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "colorup",
              "desc": "Color of the up arrows.",
              "default": "color.black",
              "required": false,
              "displayType": "series color",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "possibleValues": [
                "colors"
              ]
            },
            {
              "name": "colordown",
              "desc": "Color of the down arrows. Optional argument.",
              "default": "color.black",
              "required": false,
              "displayType": "series color",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "possibleValues": [
                "colors"
              ]
            },
            {
              "name": "offset",
              "desc": "Shifts arrows to the left or to the right on the given number of bars. Default is 0.",
              "default": "0",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "minheight",
              "desc": "Minimal possible arrow height in pixels. Default is 5.",
              "default": "5",
              "required": false,
              "displayType": "input int",
              "allowedTypeIDs": [
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            },
            {
              "name": "maxheight",
              "desc": "Maximum possible arrow height in pixels. Default is 100.",
              "default": "100",
              "required": false,
              "displayType": "input int",
              "allowedTypeIDs": [
                "input int",
                "const int"
              ],
              "possibleValues": [
                "50",
                "75",
                "100",
                "125",
                "150"
              ]
            },
            {
              "name": "editable",
              "desc": "If true then plotarrow style will be editable in Format dialog. Default is true.",
              "default": "true",
              "required": false,
              "displayType": "const bool",
              "allowedTypeIDs": [
                "const bool"
              ],
              "possibleValues": [
                "true",
                "false"
              ]
            },
            {
              "name": "show_last",
              "desc": "If set, defines the number of arrows (from the last bar back to the past) to plot on chart.",
              "default": null,
              "required": true,
              "displayType": "input int",
              "allowedTypeIDs": [
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "display",
              "desc": "Controls where the plot\\`s information is displayed. Display options support addition and subtraction, meaning that using `display.all - display.status_line` will display the plot\\`s information everywhere except in the script\\`s status line. `display.price_scale + display.status_line` will display the plot only in the price scale and status line.  \nWhen `display` arguments such as `display.price_scale` have user-controlled chart settings equivalents, the relevant plot information will only appear when all settings allow for it. \nPossible values: [display.none](#var_display.none), [display.pane](#var_display.pane), [display.data_window](#var_display.data_window), [display.price_scale](#var_display.price_scale), [display.status_line](#var_display.status_line), [display.all](#var_display.all).  \nOptional. The default is [display.all](#var_display.all).",
              "default": "display.all",
              "required": false,
              "displayType": "input plot_display",
              "allowedTypeIDs": [
                "input plot_display"
              ],
              "possibleValues": [
                "display.none",
                "display.pane",
                "display.data_window",
                "display.price_scale",
                "display.status_line",
                "display.all"
              ]
            }
          ],
          "syntax": "plotarrow(series, title, colorup, colordown, offset, minheight, maxheight, editable, show_last, display) → void",
          "remarks": "Use [plotarrow](#fun_plotarrow) function in conjunction with 'overlay=true' [indicator](#fun_indicator) parameter!",
          "seeAlso": [
            "[plot](#fun_plot)",
            "[plotshape](#fun_plotshape)",
            "[plotchar](#fun_plotchar)",
            "[barcolor](#fun_barcolor)",
            "[bgcolor](#fun_bgcolor)"
          ],
          "examples": "//@version=5\nindicator(\"plotarrow example\", overlay=true)\ncodiff = close - open\nplotarrow(codiff, colorup=color.new(color.teal, 40), colordown=color.new(color.orange, 40))",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "plotbar",
          "desc": "Plots ohlc bars on the chart.",
          "args": [
            {
              "name": "open",
              "desc": "Open series of data to be used as open values of bars. Required argument.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "open"
              ]
            },
            {
              "name": "high",
              "desc": "High series of data to be used as high values of bars. Required argument.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "high"
              ]
            },
            {
              "name": "low",
              "desc": "Low series of data to be used as low values of bars. Required argument.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "low"
              ]
            },
            {
              "name": "close",
              "desc": "Close series of data to be used as close values of bars. Required argument.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "close"
              ]
            },
            {
              "name": "title",
              "desc": "Title of the plotbar. Optional argument.",
              "default": null,
              "required": false,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "color",
              "desc": "Color of the ohlc bars. You can use constants like 'color=color.red' or 'color=#ff001a' as well as complex expressions like 'color = close >= open ? color.green : color.red'.  \nOptional argument.",
              "default": "color.blue",
              "required": false,
              "displayType": "series color",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "possibleValues": [
                "colors"
              ]
            },
            {
              "name": "editable",
              "desc": "If true then plotbar style will be editable in Format dialog. Default is true.",
              "default": "true",
              "required": false,
              "displayType": "const bool",
              "allowedTypeIDs": [
                "const bool"
              ],
              "possibleValues": [
                "true",
                "false"
              ]
            },
            {
              "name": "show_last",
              "desc": "If set, defines the number of bars (from the last bar back to the past) to plot on chart.",
              "default": null,
              "required": true,
              "displayType": "input int",
              "allowedTypeIDs": [
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "display",
              "desc": "Controls where the plot\\`s information is displayed. Display options support addition and subtraction, meaning that using `display.all - display.status_line` will display the plot\\`s information everywhere except in the script\\`s status line. `display.price_scale + display.status_line` will display the plot only in the price scale and status line.  \nWhen `display` arguments such as `display.price_scale` have user-controlled chart settings equivalents, the relevant plot information will only appear when all settings allow for it. \nPossible values: [display.none](#var_display.none), [display.pane](#var_display.pane), [display.data_window](#var_display.data_window), [display.price_scale](#var_display.price_scale), [display.status_line](#var_display.status_line), [display.all](#var_display.all).  \nOptional. The default is [display.all](#var_display.all).",
              "default": "display.all",
              "required": false,
              "displayType": "input plot_display",
              "allowedTypeIDs": [
                "input plot_display"
              ],
              "possibleValues": [
                "display.none",
                "display.pane",
                "display.data_window",
                "display.price_scale",
                "display.status_line",
                "display.all"
              ]
            }
          ],
          "syntax": "plotbar(open, high, low, close, title, color, editable, show_last, display) → void",
          "remarks": "Even if one value of open, high, low or close equal NaN then bar no draw.\nThe maximal value of open, high, low or close will be set as 'high', and the minimal value will be set as 'low'.",
          "seeAlso": [
            "[plotcandle](#fun_plotcandle)"
          ],
          "examples": "//@version=5\nindicator(\"plotbar example\", overlay=true)\nplotbar(open, high, low, close, title='Title', color = open < close ? color.green : color.red)",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "plotcandle",
          "desc": "Plots candles on the chart.",
          "args": [
            {
              "name": "open",
              "desc": "Open series of data to be used as open values of candles. Required argument.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "open"
              ]
            },
            {
              "name": "high",
              "desc": "High series of data to be used as high values of candles. Required argument.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "high"
              ]
            },
            {
              "name": "low",
              "desc": "Low series of data to be used as low values of candles. Required argument.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "low"
              ]
            },
            {
              "name": "close",
              "desc": "Close series of data to be used as close values of candles. Required argument.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "close"
              ]
            },
            {
              "name": "title",
              "desc": "Title of the plotcandles. Optional argument.",
              "default": null,
              "required": false,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "color",
              "desc": "Color of the candles. You can use constants like 'color=color.red' or 'color=#ff001a' as well as complex expressions like 'color = close >= open ? color.green : color.red'.  \nOptional argument.",
              "default": "color.blue",
              "required": false,
              "displayType": "series color",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "possibleValues": [
                "colors"
              ]
            },
            {
              "name": "wickcolor",
              "desc": "The color of the wick of candles. An optional argument.",
              "default": "color.silver",
              "required": false,
              "displayType": "series color",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "possibleValues": [
                "colors"
              ]
            },
            {
              "name": "editable",
              "desc": "If true then plotcandle style will be editable in Format dialog. Default is true.",
              "default": "true",
              "required": false,
              "displayType": "const bool",
              "allowedTypeIDs": [
                "const bool"
              ],
              "possibleValues": [
                "true",
                "false"
              ]
            },
            {
              "name": "show_last",
              "desc": "If set, defines the number of candles (from the last bar back to the past) to plot on chart.",
              "default": null,
              "required": true,
              "displayType": "input int",
              "allowedTypeIDs": [
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "bordercolor",
              "desc": "The border color of candles. An optional argument.",
              "default": "color.black",
              "required": false,
              "displayType": "series color",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "possibleValues": [
                "colors"
              ]
            },
            {
              "name": "display",
              "desc": "Controls where the plot\\`s information is displayed. Display options support addition and subtraction, meaning that using `display.all - display.status_line` will display the plot\\`s information everywhere except in the script\\`s status line. `display.price_scale + display.status_line` will display the plot only in the price scale and status line.  \nWhen `display` arguments such as `display.price_scale` have user-controlled chart settings equivalents, the relevant plot information will only appear when all settings allow for it. \nPossible values: [display.none](#var_display.none), [display.pane](#var_display.pane), [display.data_window](#var_display.data_window), [display.price_scale](#var_display.price_scale), [display.status_line](#var_display.status_line), [display.all](#var_display.all).  \nOptional. The default is [display.all](#var_display.all).",
              "default": "display.all",
              "required": false,
              "displayType": "input plot_display",
              "allowedTypeIDs": [
                "input plot_display"
              ],
              "possibleValues": [
                "display.none",
                "display.pane",
                "display.data_window",
                "display.price_scale",
                "display.status_line",
                "display.all"
              ]
            }
          ],
          "syntax": "plotcandle(open, high, low, close, title, color, wickcolor, editable, show_last, bordercolor, display) → void",
          "remarks": "Even if one value of open, high, low or close equal NaN then bar no draw.\nThe maximal value of open, high, low or close will be set as 'high', and the minimal value will be set as 'low'.",
          "seeAlso": [
            "[plotbar](#fun_plotbar)"
          ],
          "examples": "//@version=5\nindicator(\"plotcandle example\", overlay=true)\nplotcandle(open, high, low, close, title='Title', color = open < close ? color.green : color.red, wickcolor=color.black)",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "barcolor",
          "desc": "Set color of bars.",
          "args": [
            {
              "name": "color",
              "desc": "Color of bars. You can use constants like 'red' or '#ff001a' as well as complex expressions like 'close >= open ? color.green : color.red'.  \nRequired argument.",
              "default": "color.blue",
              "required": true,
              "displayType": "series color",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "possibleValues": [
                "colors"
              ]
            },
            {
              "name": "offset",
              "desc": "Shifts the color series to the left or to the right on the given number of bars.  \nDefault is 0.",
              "default": "0",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "editable",
              "desc": "If true then barcolor style will be editable in Format dialog. Default is true.",
              "default": "true",
              "required": false,
              "displayType": "const bool",
              "allowedTypeIDs": [
                "const bool"
              ],
              "possibleValues": [
                "true",
                "false"
              ]
            },
            {
              "name": "show_last",
              "desc": "If set, defines the number of bars (from the last bar back to the past) to fill on chart.",
              "default": null,
              "required": true,
              "displayType": "input int",
              "allowedTypeIDs": [
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "title",
              "desc": "Title of the barcolor. Optional argument.",
              "default": null,
              "required": false,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "display",
              "desc": "Controls where the barcolor is displayed. Possible values are: [display.none](#var_display.none), [display.all](#var_display.all).  \nDefault is [display.all](#var_display.all).",
              "default": "display.all",
              "required": false,
              "displayType": "input plot_simple_display",
              "allowedTypeIDs": [
                "input plot_simple_display"
              ],
              "possibleValues": [
                "display.none",
                "display.pane",
                "display.data_window",
                "display.price_scale",
                "display.status_line",
                "display.all"
              ]
            }
          ],
          "syntax": "barcolor(color, offset, editable, show_last, title, display) → void",
          "seeAlso": [
            "[bgcolor](#fun_bgcolor)",
            "[plot](#fun_plot)",
            "[fill](#fun_fill)"
          ],
          "examples": "//@version=5\nindicator(\"barcolor example\", overlay=true)\nbarcolor(close < open ? color.black : color.white)",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "bgcolor",
          "desc": "Fill background of bars with specified color.",
          "args": [
            {
              "name": "color",
              "desc": "Color of the filled background. You can use constants like 'red' or '#ff001a' as well as complex expressions like 'close >= open ? color.green : color.red'.  \nRequired argument.",
              "default": null,
              "required": true,
              "displayType": "series color",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "possibleValues": [
                "colors"
              ]
            },
            {
              "name": "offset",
              "desc": "Shifts the color series to the left or to the right on the given number of bars.  \nDefault is 0.",
              "default": "0",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "editable",
              "desc": "If true then bgcolor style will be editable in Format dialog. Default is true.",
              "default": "true",
              "required": false,
              "displayType": "const bool",
              "allowedTypeIDs": [
                "const bool"
              ],
              "possibleValues": [
                "true",
                "false"
              ]
            },
            {
              "name": "show_last",
              "desc": "If set, defines the number of bars (from the last bar back to the past) to fill on chart.",
              "default": null,
              "required": true,
              "displayType": "input int",
              "allowedTypeIDs": [
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "title",
              "desc": "Title of the bgcolor. Optional argument.",
              "default": null,
              "required": false,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "display",
              "desc": "Controls where the bgcolor is displayed. Possible values are: [display.none](#var_display.none), [display.all](#var_display.all).  \nDefault is [display.all](#var_display.all).",
              "default": "display.all",
              "required": false,
              "displayType": "input plot_simple_display",
              "allowedTypeIDs": [
                "input plot_simple_display"
              ],
              "possibleValues": [
                "display.none",
                "display.pane",
                "display.data_window",
                "display.price_scale",
                "display.status_line",
                "display.all"
              ]
            }
          ],
          "syntax": "bgcolor(color, offset, editable, show_last, title, display) → void",
          "seeAlso": [
            "[barcolor](#fun_barcolor)",
            "[plot](#fun_plot)",
            "[fill](#fun_fill)"
          ],
          "examples": "//@version=5\nindicator(\"bgcolor example\", overlay=true)\nbgcolor(close < open ? color.new(color.red, 70) : color.new(color.green, 70))",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "color.new",
          "desc": "Function color applies the specified transparency to the given color.",
          "args": [
            {
              "name": "color",
              "desc": "Color to apply transparency to.",
              "default": null,
              "required": true,
              "displayType": "series color",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "possibleValues": [
                "colors"
              ]
            },
            {
              "name": "transp",
              "desc": "Possible values are from 0 (not transparent) to 100 (invisible).",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                0,
                25,
                50,
                75,
                100
              ]
            }
          ],
          "syntax": "color.new(color, transp) → series color",
          "remarks": "Using arguments that are not constants (e.g., 'simple', 'input' or 'series')  \nwill have an impact on the colors displayed in the script\\`s \"Settings/Style\" tab.  \nSee the [User Manual](https://www.tradingview.com/pine-script-docs/en/v5/concepts/Colors.html#stylecolors) for more information.",
          "returns": "Color with specified transparency.",
          "examples": "//@version=5\nindicator(\"color.new\", overlay=true)\nplot(close, color=color.new(color.red, 50))",
          "returnedType": "color",
          "returnedTypes": [
            "const color",
            "series color",
            "simple color",
            "input color"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "color.rgb",
          "desc": "Creates a new color with transparency using the RGB color model.",
          "args": [
            {
              "name": "red",
              "desc": "Red color component. Possible values are from 0 to 255.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "0",
                "64",
                "128",
                "192",
                "255"
              ]
            },
            {
              "name": "green",
              "desc": "Green color component. Possible values are from 0 to 255.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "0",
                "64",
                "128",
                "192",
                "255"
              ]
            },
            {
              "name": "blue",
              "desc": "Blue color component. Possible values are from 0 to 255.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "0",
                "64",
                "128",
                "192",
                "255"
              ]
            },
            {
              "name": "transp",
              "desc": "Optional. Color transparency. Possible values are from 0 (opaque) to 100 (invisible).  \nDefault value is 0.",
              "default": "0",
              "required": false,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "0",
                "25",
                "50",
                "75",
                "100"
              ]
            }
          ],
          "syntax": "color.rgb(red, green, blue, transp) → series color",
          "remarks": "Using arguments that are not constants (e.g., 'simple', 'input' or 'series')  \nwill have an impact on the colors displayed in the script\\`s \"Settings/Style\" tab.  \nSee the [User Manual](https://www.tradingview.com/pine-script-docs/en/v5/concepts/Colors.html#stylecolors) for more information.",
          "returns": "Color with specified transparency.",
          "examples": "//@version=5\nindicator(\"color.rgb\", overlay=true)\nplot(close, color=color.rgb(255, 0, 0, 50))",
          "returnedType": "color",
          "returnedTypes": [
            "series color",
            "simple color",
            "input color",
            "const color"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "color.r",
          "desc": "Retrieves the value of the color\\`s red component.",
          "args": [
            {
              "name": "color",
              "desc": "Color.",
              "default": null,
              "required": true,
              "displayType": "series color",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "possibleValues": [
                "colors"
              ]
            }
          ],
          "syntax": "color.r(color) → series float",
          "returns": "The value (0 to 255) of the color\\`s red component.",
          "examples": "//@version=5\nindicator(\"color.r\", overlay=true)\nplot(color.r(color.red))",
          "returnedType": "float",
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "color.g",
          "desc": "Retrieves the value of the color\\`s green component.",
          "args": [
            {
              "name": "color",
              "desc": "Color.",
              "default": null,
              "required": true,
              "displayType": "series color",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "possibleValues": [
                "colors"
              ]
            }
          ],
          "syntax": "color.g(color) → series float",
          "returns": "The value (0 to 255) of the color\\`s green component.",
          "examples": "//@version=5\nindicator(\"color.g\", overlay=true)\nplot(color.g(color.green))",
          "returnedType": "float",
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "color.b",
          "desc": "Retrieves the value of the color\\`s blue component.",
          "args": [
            {
              "name": "color",
              "desc": "Color.",
              "default": null,
              "required": true,
              "displayType": "series color",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "possibleValues": [
                "colors"
              ]
            }
          ],
          "syntax": "color.b(color) → series float",
          "returns": "The value (0 to 255) of the color\\`s blue component.",
          "examples": "//@version=5\nindicator(\"color.b\", overlay=true)\nplot(color.b(color.blue))",
          "returnedType": "float",
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "color.t",
          "desc": "Retrieves the color\\`s transparency.",
          "args": [
            {
              "name": "color",
              "desc": "Color.",
              "default": null,
              "required": true,
              "displayType": "series color",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "possibleValues": [
                "colors"
              ]
            }
          ],
          "syntax": "color.t(color) → series float",
          "returns": "The value (0-100) of the color\\`s transparency.",
          "examples": "//@version=5\nindicator(\"color.t\", overlay=true)\nplot(color.t(color.new(color.red, 50)))",
          "returnedType": "float",
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "color.from_gradient",
          "desc": "Based on the relative position of value in the bottom_value to top_value range, the function returns a color from the gradient defined by bottom_color to top_color.",
          "args": [
            {
              "name": "value",
              "desc": "Value to calculate the position-dependent color.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            },
            {
              "name": "bottom_value",
              "desc": "Bottom position value corresponding to bottom_color.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            },
            {
              "name": "top_value",
              "desc": "Top position value corresponding to top_color.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            },
            {
              "name": "bottom_color",
              "desc": "Bottom position color.",
              "default": null,
              "required": true,
              "displayType": "series color",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "possibleValues": [
                "colors"
              ]
            },
            {
              "name": "top_color",
              "desc": "Top position color.",
              "default": null,
              "required": true,
              "displayType": "series color",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "possibleValues": [
                "colors"
              ]
            }
          ],
          "syntax": "color.from_gradient(value, bottom_value, top_value, bottom_color, top_color) → series color",
          "remarks": "Using this function will have an impact on the colors displayed in the script\\`s \"Settings/Style\" tab.  \nSee the [User Manual](https://www.tradingview.com/pine-script-docs/en/v5/concepts/Colors.html#stylecolors) for more information.",
          "returns": "A color calculated from the linear gradient between bottom_color to top_color.",
          "examples": "//@version=5\nindicator(\"color.from_gradient\", overlay=true)\ncolor1 = color.from_gradient(close, low, high, color.yellow, color.lime)\ncolor2 = color.from_gradient(ta.rsi(close, 7), 0, 100, color.rgb(255, 0, 0), color.rgb(0, 255, 0, 50))\nplot(close, color=color1)\nplot(ta.rsi(close, 7), color=color2)",
          "returnedType": "color",
          "returnedTypes": [
            "series color",
            "simple color",
            "input color",
            "const color"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "alertcondition",
          "desc": "Creates alert condition, that is available in Create Alert dialog. Please note, that [alertcondition](#fun_alertcondition) does NOT create an alert, it just gives you more options in Create Alert dialog.  \nAlso, [alertcondition](#fun_alertcondition) effect is invisible on chart.",
          "args": [
            {
              "name": "condition",
              "desc": "Series of boolean values that is used for alert. True values mean alert fire, false - no alert.  \nRequired argument.",
              "default": null,
              "required": true,
              "displayType": "series bool",
              "allowedTypeIDs": [
                "series bool",
                "simple bool",
                "input bool",
                "const bool"
              ],
              "possibleValues": [
                "true",
                "false"
              ]
            },
            {
              "name": "title",
              "desc": "Title of the alert condition. Optional argument.",
              "default": null,
              "required": false,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "message",
              "desc": "Message to display when alert fires. Optional argument.",
              "default": null,
              "required": false,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "alertcondition(condition, title, message) → void",
          "remarks": "Please note that an alertcondition call generates an additional plot. All such calls are taken into account when we calculate the number of the output series per script.",
          "seeAlso": [
            "[alert](#fun_alert)"
          ],
          "examples": "//@version=5\nindicator(\"alertcondition\", overlay=true)\nalertcondition(close >= open, title='Alert on Green Bar', message='Green Bar!')",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "input",
          "desc": "Adds an input to the Inputs tab of your script\\`s Settings, which allows you to provide configuration options to script users. This function automatically detects the type of the argument used for 'defval' and uses the corresponding input widget.",
          "args": [
            {
              "name": "defval",
              "desc": "Determines the default value of the input variable proposed in the script\\`s \"Settings/Inputs\" tab, from where script users can change it.  \nSource-type built-ins are built-in series float variables that specify the source of the calculation: `close`, `hlc3`, etc.",
              "default": null,
              "required": true,
              "displayType": "const int|float|bool|string|color|<open|high|low|close|hl2|hlc3|ohlc4|hlcc4>",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float",
                "const bool",
                "const color",
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "title",
              "desc": "Title of the input. If not specified, the variable name is used as the input\\`s title.  \nIf the title is specified, but it is empty, the name will be an empty string.",
              "default": "'variable_name'",
              "required": false,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "tooltip",
              "desc": "The string that will be shown to the user when hovering over the tooltip icon.",
              "default": null,
              "required": false,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "inline",
              "desc": "Combines all the input calls using the same argument in one line. The string used as an argument is not displayed.  \nIt is only used to identify inputs belonging to the same line.",
              "default": null,
              "required": false,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "group",
              "desc": "Creates a header above all inputs using the same group argument string. The string is also used as the header\\`s text.",
              "default": null,
              "required": false,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "display",
              "desc": "Controls where the script will display the input\\`s information, aside from within the script\\`s settings.  \nThis option allows one to remove a specific input from the script\\`s status line or the Data Window to ensure only the most necessary inputs are displayed there. \nPossible values: [display.none](#var_display.none), [display.data_window](#var_display.data_window), [display.status_line](#var_display.status_line), [display.all](#var_display.all).  \nOptional. The default depends on the type of the value passed to `defval`: [display.none](#var_display.none) for [bool](#op_bool) and [color](#op_color) values, [display.all](#var_display.all) for everything else.",
              "default": "display.none",
              "required": false,
              "displayType": "const plot_display",
              "allowedTypeIDs": [
                "const plot_display"
              ],
              "possibleValues": [
                "display.none",
                "display.pane",
                "display.data_window",
                "display.price_scale",
                "display.status_line",
                "display.all"
              ]
            }
          ],
          "syntax": "input(defval, title, tooltip, inline, group, display) → input bool|color|int|string|float",
          "remarks": "Result of [input](#fun_input) function always should be assigned to a variable, see examples above.",
          "returns": "Value of input variable.",
          "seeAlso": [
            "[input.bool](#fun_input.bool)",
            "[input.color](#fun_input.color)",
            "[input.int](#fun_input.int)",
            "[input.float](#fun_input.float)",
            "[input.string](#fun_input.string)",
            "[input.symbol](#fun_input.symbol)",
            "[input.timeframe](#fun_input.timeframe)",
            "[input.text_area](#fun_input.text_area)",
            "[input.session](#fun_input.session)",
            "[input.source](#fun_input.source)",
            "[input.time](#fun_input.time)"
          ],
          "examples": "//@version=5\nindicator(\"input\", overlay=true)\ni_switch = input(true, \"On/Off\")\nplot(i_switch ? open : na)\n\ni_len = input(7, \"Length\")\ni_src = input(close, \"Source\")\nplot(ta.sma(i_src, i_len))\n\ni_border = input(142.50, \"Price Border\")\nhline(i_border)\nbgcolor(close > i_border ? color.green : color.red)\n\ni_col = input(color.red, \"Plot Color\")\nplot(close, color=i_col)\n\ni_text = input(\"Hello!\", \"Message\")\nl = label.new(bar_index, high, text=i_text)\nlabel.delete(l[1])",
          "returnedType": [
            "string",
            "int",
            "bool",
            "float",
            "color"
          ],
          "returnedTypes": [
            "input bool",
            "const bool",
            "input color",
            "const color",
            "input int",
            "const int",
            "input float",
            "const float",
            "input string",
            "const string",
            "series float",
            "simple float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "input.bool",
          "desc": "Adds an input to the Inputs tab of your script\\`s Settings, which allows you to provide configuration options to script users. This function adds a checkmark to the script\\`s inputs.",
          "args": [
            {
              "name": "defval",
              "desc": "Determines the default value of the input variable proposed in the script\\`s \"Settings/Inputs\" tab, from where the user can change it.",
              "default": null,
              "required": true,
              "displayType": "const bool",
              "allowedTypeIDs": [
                "const bool"
              ],
              "possibleValues": [
                "true",
                "false"
              ]
            },
            {
              "name": "title",
              "desc": "Title of the input. If not specified, the variable name is used as the input\\`s title.  \nIf the title is specified, but it is empty, the name will be an empty string.",
              "default": "'variable_name'",
              "required": false,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "tooltip",
              "desc": "The string that will be shown to the user when hovering over the tooltip icon.",
              "default": null,
              "required": false,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "inline",
              "desc": "Combines all the input calls using the same argument in one line. The string used as an argument is not displayed.  \nIt is only used to identify inputs belonging to the same line.",
              "default": null,
              "required": false,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "group",
              "desc": "Creates a header above all inputs using the same group argument string. The string is also used as the header\\`s text.",
              "default": null,
              "required": false,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "confirm",
              "desc": "If true, then user will be asked to confirm input value before indicator is added to chart.  \nDefault value is false.",
              "default": "false",
              "required": false,
              "displayType": "const bool",
              "allowedTypeIDs": [
                "const bool"
              ],
              "possibleValues": [
                "true",
                "false"
              ]
            },
            {
              "name": "display",
              "desc": "Controls where the script will display the input\\`s information, aside from within the script\\`s settings.  \nThis option allows one to remove a specific input from the script\\`s status line or the Data Window to ensure only the most necessary inputs are displayed there. \nPossible values: [display.none](#var_display.none), [display.data_window](#var_display.data_window), [display.status_line](#var_display.status_line), [display.all](#var_display.all).  \nOptional. The default is [display.none](#var_display.none).",
              "default": "display.none",
              "required": false,
              "displayType": "const plot_display",
              "allowedTypeIDs": [
                "const plot_display"
              ],
              "possibleValues": [
                "display.none",
                "display.pane",
                "display.data_window",
                "display.price_scale",
                "display.status_line",
                "display.all"
              ]
            }
          ],
          "syntax": "input.bool(defval, title, tooltip, inline, group, confirm, display) → input bool",
          "remarks": "Result of [input.bool](#fun_input.bool) function always should be assigned to a variable, see examples above.",
          "returns": "Value of input variable.",
          "seeAlso": [
            "[input.int](#fun_input.int)",
            "[input.float](#fun_input.float)",
            "[input.string](#fun_input.string)",
            "[input.text_area](#fun_input.text_area)",
            "[input.symbol](#fun_input.symbol)",
            "[input.timeframe](#fun_input.timeframe)",
            "[input.session](#fun_input.session)",
            "[input.source](#fun_input.source)",
            "[input.color](#fun_input.color)",
            "[input.time](#fun_input.time)",
            "[input](#fun_input)"
          ],
          "examples": "//@version=5\nindicator(\"input.bool\", overlay=true)\ni_switch = input.bool(true, \"On/Off\")\nplot(i_switch ? open : na)",
          "returnedType": "bool",
          "returnedTypes": [
            "input bool",
            "const bool"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "input.int",
          "desc": "Adds an input to the Inputs tab of your script\\`s Settings, which allows you to provide configuration options to script users. This function adds a field for an integer input to the script\\`s inputs.",
          "args": [
            {
              "name": "defval",
              "desc": "Determines the default value of the input variable proposed in the script\\`s \"Settings/Inputs\" tab, from where script users can change it.  \nWhen a list of values is used with the `options` parameter, the value must be one of them.",
              "default": null,
              "required": true,
              "displayType": "const int",
              "allowedTypeIDs": [
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "title",
              "desc": "Title of the input. If not specified, the variable name is used as the input\\`s title.  \nIf the title is specified, but it is empty, the name will be an empty string.",
              "default": "'variable_name'",
              "required": false,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "minval",
              "desc": "Minimal possible value of the input variable. Optional.",
              "default": null,
              "required": false,
              "displayType": "const int",
              "allowedTypeIDs": [
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "maxval",
              "desc": "Maximum possible value of the input variable. Optional.",
              "default": null,
              "required": false,
              "displayType": "const int",
              "allowedTypeIDs": [
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "step",
              "desc": "Step value used for incrementing/decrementing the input. Optional. The default is 1.",
              "default": "1.0",
              "required": false,
              "displayType": "const int",
              "allowedTypeIDs": [
                "const int"
              ],
              "possibleValues": [
                1
              ]
            },
            {
              "name": "options",
              "desc": "A list of options to choose from a dropdown menu, separated by commas and enclosed in square brackets: [val1, val2, ...].  \nWhen using this parameter, the `minval`, `maxval` and `step` parameters cannot be used.",
              "default": null,
              "required": true,
              "displayType": "const int [val1, val2, ...]",
              "allowedTypeIDs": [
                "[const int...]"
              ],
              "possibleValues": null
            },
            {
              "name": "tooltip",
              "desc": "The string that will be shown to the user when hovering over the tooltip icon.",
              "default": null,
              "required": false,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "inline",
              "desc": "Combines all the input calls using the same argument in one line. The string used as an argument is not displayed.  \nIt is only used to identify inputs belonging to the same line.",
              "default": null,
              "required": false,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "group",
              "desc": "Creates a header above all inputs using the same group argument string. The string is also used as the header\\`s text.",
              "default": null,
              "required": false,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "confirm",
              "desc": "If true, then user will be asked to confirm input value before indicator is added to chart.  \nDefault value is false.",
              "default": "false",
              "required": false,
              "displayType": "const bool",
              "allowedTypeIDs": [
                "const bool"
              ],
              "possibleValues": [
                "true",
                "false"
              ]
            },
            {
              "name": "display",
              "desc": "Controls where the script will display the input\\`s information, aside from within the script\\`s settings.  \nThis option allows one to remove a specific input from the script\\`s status line or the Data Window to ensure only the most necessary inputs are displayed there. \nPossible values: [display.none](#var_display.none), [display.data_window](#var_display.data_window), [display.status_line](#var_display.status_line), [display.all](#var_display.all).  \nOptional. The default is [display.all](#var_display.all).",
              "default": "display.all",
              "required": false,
              "displayType": "const plot_display",
              "allowedTypeIDs": [
                "const plot_display"
              ],
              "possibleValues": [
                "display.none",
                "display.pane",
                "display.data_window",
                "display.price_scale",
                "display.status_line",
                "display.all"
              ]
            }
          ],
          "syntax": "input.int(defval, title, minval, maxval, step, tooltip, inline, group, confirm, display) → input int\ninput.int(defval, title, options, tooltip, inline, group, confirm, display) → input int",
          "remarks": "Result of [input.int](#fun_input.int) function always should be assigned to a variable, see examples above.",
          "returns": "Value of input variable.",
          "seeAlso": [
            "[input.bool](#fun_input.bool)",
            "[input.float](#fun_input.float)",
            "[input.string](#fun_input.string)",
            "[input.text_area](#fun_input.text_area)",
            "[input.symbol](#fun_input.symbol)",
            "[input.timeframe](#fun_input.timeframe)",
            "[input.session](#fun_input.session)",
            "[input.source](#fun_input.source)",
            "[input.color](#fun_input.color)",
            "[input.time](#fun_input.time)",
            "[input](#fun_input)"
          ],
          "examples": "//@version=5\nindicator(\"input.int\", overlay=true)\ni_len1 = input.int(10, \"Length 1\", minval=5, maxval=21, step=1)\nplot(ta.sma(close, i_len1))\n\ni_len2 = input.int(10, \"Length 2\", options=[5, 10, 21])\nplot(ta.sma(close, i_len2))",
          "returnedType": "int",
          "returnedTypes": [
            "input int",
            "const int"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "input.float",
          "desc": "Adds an input to the Inputs tab of your script\\`s Settings, which allows you to provide configuration options to script users. This function adds a field for a float input to the script\\`s inputs.",
          "args": [
            {
              "name": "defval",
              "desc": "Determines the default value of the input variable proposed in the script\\`s \"Settings/Inputs\" tab, from where script users can change it.  \nWhen a list of values is used with the `options` parameter, the value must be one of them.",
              "default": null,
              "required": true,
              "displayType": "const int|float",
              "allowedTypeIDs": [
                "const int",
                "const float"
              ],
              "possibleValues": null
            },
            {
              "name": "title",
              "desc": "Title of the input. If not specified, the variable name is used as the input\\`s title.  \nIf the title is specified, but it is empty, the name will be an empty string.",
              "default": "'variable_name'",
              "required": false,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "minval",
              "desc": "Minimal possible value of the input variable. Optional.",
              "default": null,
              "required": false,
              "displayType": "const int|float",
              "allowedTypeIDs": [
                "const int",
                "const float"
              ],
              "possibleValues": null
            },
            {
              "name": "maxval",
              "desc": "Maximum possible value of the input variable. Optional.",
              "default": null,
              "required": false,
              "displayType": "const int|float",
              "allowedTypeIDs": [
                "const int",
                "const float"
              ],
              "possibleValues": null
            },
            {
              "name": "step",
              "desc": "Step value used for incrementing/decrementing the input. Optional. The default is 1.",
              "default": "1.0",
              "required": false,
              "displayType": "const int|float",
              "allowedTypeIDs": [
                "const int",
                "const float"
              ],
              "possibleValues": null
            },
            {
              "name": "options",
              "desc": "A list of options to choose from a dropdown menu, separated by commas and enclosed in square brackets: [val1, val2, ...].  \nWhen using this parameter, the `minval`, `maxval` and `step` parameters cannot be used.",
              "default": null,
              "required": true,
              "displayType": "const int|float [val1, val2, ...]",
              "allowedTypeIDs": [
                "[const float...]"
              ],
              "possibleValues": null
            },
            {
              "name": "tooltip",
              "desc": "The string that will be shown to the user when hovering over the tooltip icon.",
              "default": null,
              "required": false,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "inline",
              "desc": "Combines all the input calls using the same argument in one line. The string used as an argument is not displayed.  \nIt is only used to identify inputs belonging to the same line.",
              "default": null,
              "required": false,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "group",
              "desc": "Creates a header above all inputs using the same group argument string. The string is also used as the header\\`s text.",
              "default": null,
              "required": false,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "confirm",
              "desc": "If true, then user will be asked to confirm input value before indicator is added to chart.  \nDefault value is false.",
              "default": "false",
              "required": false,
              "displayType": "const bool",
              "allowedTypeIDs": [
                "const bool"
              ],
              "possibleValues": [
                "true",
                "false"
              ]
            },
            {
              "name": "display",
              "desc": "Controls where the script will display the input\\`s information, aside from within the script\\`s settings.  \nThis option allows one to remove a specific input from the script\\`s status line or the Data Window to ensure only the most necessary inputs are displayed there. \nPossible values: [display.none](#var_display.none), [display.data_window](#var_display.data_window), [display.status_line](#var_display.status_line), [display.all](#var_display.all).  \nOptional. The default is [display.all](#var_display.all).",
              "default": "display.all",
              "required": false,
              "displayType": "const plot_display",
              "allowedTypeIDs": [
                "const plot_display"
              ],
              "possibleValues": [
                "display.none",
                "display.pane",
                "display.data_window",
                "display.price_scale",
                "display.status_line",
                "display.all"
              ]
            }
          ],
          "syntax": "input.float(defval, title, minval, maxval, step, tooltip, inline, group, confirm, display) → input float\ninput.float(defval, title, options, tooltip, inline, group, confirm, display) → input float",
          "remarks": "Result of [input.float](#fun_input.float) function always should be assigned to a variable, see examples above.",
          "returns": "Value of input variable.",
          "seeAlso": [
            "[input.bool](#fun_input.bool)",
            "[input.int](#fun_input.int)",
            "[input.string](#fun_input.string)",
            "[input.text_area](#fun_input.text_area)",
            "[input.symbol](#fun_input.symbol)",
            "[input.timeframe](#fun_input.timeframe)",
            "[input.session](#fun_input.session)",
            "[input.source](#fun_input.source)",
            "[input.color](#fun_input.color)",
            "[input.time](#fun_input.time)",
            "[input](#fun_input)"
          ],
          "examples": "//@version=5\nindicator(\"input.float\", overlay=true)\ni_angle1 = input.float(0.5, \"Sin Angle\", minval=-3.14, maxval=3.14, step=0.02)\nplot(math.sin(i_angle1) > 0 ? close : open, \"sin\", color=color.green)\n\ni_angle2 = input.float(0, \"Cos Angle\", options=[-3.14, -1.57, 0, 1.57, 3.14])\nplot(math.cos(i_angle2) > 0 ? close : open, \"cos\", color=color.red)",
          "returnedType": "float",
          "returnedTypes": [
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "input.string",
          "desc": "Adds an input to the Inputs tab of your script\\`s Settings, which allows you to provide configuration options to script users. This function adds a field for a string input to the script\\`s inputs.",
          "args": [
            {
              "name": "defval",
              "desc": "Determines the default value of the input variable proposed in the script\\`s \"Settings/Inputs\" tab, from where the user can change it.  \nWhen a list of values is used with the `options` parameter, the value must be one of them.",
              "default": null,
              "required": true,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "title",
              "desc": "Title of the input. If not specified, the variable name is used as the input\\`s title.  \nIf the title is specified, but it is empty, the name will be an empty string.",
              "default": "'variable_name'",
              "required": false,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "options",
              "desc": "A list of options to choose from.",
              "default": null,
              "required": false,
              "displayType": "const string [val1, val2, ...]",
              "allowedTypeIDs": [
                "[const string...]"
              ],
              "possibleValues": null
            },
            {
              "name": "tooltip",
              "desc": "The string that will be shown to the user when hovering over the tooltip icon.",
              "default": null,
              "required": false,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "inline",
              "desc": "Combines all the input calls using the same argument in one line. The string used as an argument is not displayed.  \nIt is only used to identify inputs belonging to the same line.",
              "default": null,
              "required": false,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "group",
              "desc": "Creates a header above all inputs using the same group argument string. The string is also used as the header\\`s text.",
              "default": null,
              "required": false,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "confirm",
              "desc": "If true, then user will be asked to confirm input value before indicator is added to chart.  \nDefault value is false.",
              "default": "false",
              "required": false,
              "displayType": "const bool",
              "allowedTypeIDs": [
                "const bool"
              ],
              "possibleValues": [
                "true",
                "false"
              ]
            },
            {
              "name": "display",
              "desc": "Controls where the script will display the input\\`s information, aside from within the script\\`s settings.  \nThis option allows one to remove a specific input from the script\\`s status line or the Data Window to ensure only the most necessary inputs are displayed there. \nPossible values: [display.none](#var_display.none), [display.data_window](#var_display.data_window), [display.status_line](#var_display.status_line), [display.all](#var_display.all).  \nOptional. The default is [display.all](#var_display.all).",
              "default": "display.all",
              "required": false,
              "displayType": "const plot_display",
              "allowedTypeIDs": [
                "const plot_display"
              ],
              "possibleValues": [
                "display.none",
                "display.pane",
                "display.data_window",
                "display.price_scale",
                "display.status_line",
                "display.all"
              ]
            }
          ],
          "syntax": "input.string(defval, title, options, tooltip, inline, group, confirm, display) → input string",
          "remarks": "Result of [input.string](#fun_input.string) function always should be assigned to a variable, see examples above.",
          "returns": "Value of input variable.",
          "seeAlso": [
            "[input.text_area](#fun_input.text_area)",
            "[input.bool](#fun_input.bool)",
            "[input.int](#fun_input.int)",
            "[input.float](#fun_input.float)",
            "[input.symbol](#fun_input.symbol)",
            "[input.timeframe](#fun_input.timeframe)",
            "[input.session](#fun_input.session)",
            "[input.source](#fun_input.source)",
            "[input.color](#fun_input.color)",
            "[input.time](#fun_input.time)",
            "[input](#fun_input)"
          ],
          "examples": "//@version=5\nindicator(\"input.string\", overlay=true)\ni_text = input.string(\"Hello!\", \"Message\")\nl = label.new(bar_index, high, i_text)\nlabel.delete(l[1])",
          "returnedType": "string",
          "returnedTypes": [
            "input string",
            "const string"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "input.text_area",
          "desc": "Adds an input to the Inputs tab of your script\\`s Settings, which allows you to provide configuration options to script users. This function adds a field for a multiline text input.",
          "args": [
            {
              "name": "defval",
              "desc": "Determines the default value of the input variable proposed in the script\\`s \"Settings/Inputs\" tab, from where the user can change it.",
              "default": null,
              "required": true,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "title",
              "desc": "Title of the input. If not specified, the variable name is used as the input\\`s title.  \nIf the title is specified, but it is empty, the name will be an empty string.",
              "default": "'variable_name'",
              "required": false,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "tooltip",
              "desc": "The string that will be shown to the user when hovering over the tooltip icon.",
              "default": null,
              "required": false,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "group",
              "desc": "Creates a header above all inputs using the same group argument string. The string is also used as the header\\`s text.",
              "default": null,
              "required": false,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "confirm",
              "desc": "If true, then user will be asked to confirm input value before indicator is added to chart.  \nDefault value is false.",
              "default": "false",
              "required": false,
              "displayType": "const bool",
              "allowedTypeIDs": [
                "const bool"
              ],
              "possibleValues": [
                "true",
                "false"
              ]
            },
            {
              "name": "display",
              "desc": "Controls where the script will display the input\\`s information, aside from within the script\\`s settings.  \nThis option allows one to remove a specific input from the script\\`s status line or the Data Window to ensure only the most necessary inputs are displayed there. \nPossible values: [display.none](#var_display.none), [display.data_window](#var_display.data_window), [display.status_line](#var_display.status_line), [display.all](#var_display.all).  \nOptional. The default is [display.none](#var_display.none).",
              "default": "display.none",
              "required": false,
              "displayType": "const plot_display",
              "allowedTypeIDs": [
                "const plot_display"
              ],
              "possibleValues": [
                "display.none",
                "display.pane",
                "display.data_window",
                "display.price_scale",
                "display.status_line",
                "display.all"
              ]
            }
          ],
          "syntax": "input.text_area(defval, title, tooltip, group, confirm, display) → input string",
          "remarks": "Result of [input.text_area](#fun_input.text_area) function always should be assigned to a variable, see examples above.",
          "returns": "Value of input variable.",
          "seeAlso": [
            "[input.string](#fun_input.string)",
            "[input.bool](#fun_input.bool)",
            "[input.int](#fun_input.int)",
            "[input.float](#fun_input.float)",
            "[input.symbol](#fun_input.symbol)",
            "[input.timeframe](#fun_input.timeframe)",
            "[input.session](#fun_input.session)",
            "[input.source](#fun_input.source)",
            "[input.color](#fun_input.color)",
            "[input.time](#fun_input.time)",
            "[input](#fun_input)"
          ],
          "examples": "//@version=5\nindicator(\"input.text_area\")\ni_text = input.text_area(defval = \"Hello \\nWorld!\", title = \"Message\")\nplot(close)",
          "returnedType": "string",
          "returnedTypes": [
            "input string",
            "const string"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "input.symbol",
          "desc": "Adds an input to the Inputs tab of your script\\`s Settings, which allows you to provide configuration options to script users. This function adds a field that allows the user to select a specific symbol using the symbol search and returns that symbol, paired with its exchange prefix, as a string.",
          "args": [
            {
              "name": "defval",
              "desc": "Determines the default value of the input variable proposed in the script\\`s \"Settings/Inputs\" tab, from where the user can change it.",
              "default": null,
              "required": true,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "title",
              "desc": "Title of the input. If not specified, the variable name is used as the input\\`s title.  \nIf the title is specified, but it is empty, the name will be an empty string.",
              "default": "'variable_name'",
              "required": false,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "tooltip",
              "desc": "The string that will be shown to the user when hovering over the tooltip icon.",
              "default": null,
              "required": false,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "inline",
              "desc": "Combines all the input calls using the same argument in one line. The string used as an argument is not displayed.  \nIt is only used to identify inputs belonging to the same line.",
              "default": null,
              "required": false,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "group",
              "desc": "Creates a header above all inputs using the same group argument string. The string is also used as the header\\`s text.",
              "default": null,
              "required": false,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "confirm",
              "desc": "If true, then user will be asked to confirm input value before indicator is added to chart.  \nDefault value is false.",
              "default": "false",
              "required": false,
              "displayType": "const bool",
              "allowedTypeIDs": [
                "const bool"
              ],
              "possibleValues": [
                "false",
                "true"
              ]
            },
            {
              "name": "display",
              "desc": "Controls where the script will display the input\\`s information, aside from within the script\\`s settings.  \nThis option allows one to remove a specific input from the script\\`s status line or the Data Window to ensure only the most necessary inputs are displayed there. \nPossible values: [display.none](#var_display.none), [display.data_window](#var_display.data_window), [display.status_line](#var_display.status_line), [display.all](#var_display.all).  \nOptional. The default is [display.all](#var_display.all).",
              "default": "display.all",
              "required": false,
              "displayType": "const plot_display",
              "allowedTypeIDs": [
                "const plot_display"
              ],
              "possibleValues": [
                "display.none",
                "display.pane",
                "display.data_window",
                "display.price_scale",
                "display.status_line",
                "display.all"
              ]
            }
          ],
          "syntax": "input.symbol(defval, title, tooltip, inline, group, confirm, display) → input string",
          "remarks": "Result of [input.symbol](#fun_input.symbol) function always should be assigned to a variable, see examples above.",
          "returns": "Value of input variable.",
          "seeAlso": [
            "[input.bool](#fun_input.bool)",
            "[input.int](#fun_input.int)",
            "[input.float](#fun_input.float)",
            "[input.string](#fun_input.string)",
            "[input.text_area](#fun_input.text_area)",
            "[input.timeframe](#fun_input.timeframe)",
            "[input.session](#fun_input.session)",
            "[input.source](#fun_input.source)",
            "[input.color](#fun_input.color)",
            "[input.time](#fun_input.time)",
            "[input](#fun_input)"
          ],
          "examples": "//@version=5\nindicator(\"input.symbol\", overlay=true)\ni_sym = input.symbol(\"DELL\", \"Symbol\")\ns = request.security(i_sym, 'D', close)\nplot(s)",
          "returnedType": "string",
          "returnedTypes": [
            "input string",
            "const string"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "input.timeframe",
          "desc": "Adds an input to the Inputs tab of your script\\`s Settings, which allows you to provide configuration options to script users. This function adds a dropdown that allows the user to select a specific timeframe via the timeframe selector and returns it as a string. The selector includes the custom timeframes a user may have added using the chart\\`s Timeframe dropdown.",
          "args": [
            {
              "name": "defval",
              "desc": "Determines the default value of the input variable proposed in the script\\`s \"Settings/Inputs\" tab, from where the user can change it.  \nWhen a list of values is used with the `options` parameter, the value must be one of them.",
              "default": null,
              "required": true,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "isString": true,
              "possibleValues": [
                "15",
                "60",
                "D",
                "W",
                "M"
              ]
            },
            {
              "name": "title",
              "desc": "Title of the input. If not specified, the variable name is used as the input\\`s title.  \nIf the title is specified, but it is empty, the name will be an empty string.",
              "default": "'variable_name'",
              "required": false,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "options",
              "desc": "A list of options to choose from.",
              "default": null,
              "required": false,
              "displayType": "const string [val1, val2, ...]",
              "allowedTypeIDs": [
                "[const string...]"
              ],
              "possibleValues": null
            },
            {
              "name": "tooltip",
              "desc": "The string that will be shown to the user when hovering over the tooltip icon.",
              "default": null,
              "required": false,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "inline",
              "desc": "Combines all the input calls using the same argument in one line. The string used as an argument is not displayed.  \nIt is only used to identify inputs belonging to the same line.",
              "default": null,
              "required": false,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "group",
              "desc": "Creates a header above all inputs using the same group argument string. The string is also used as the header\\`s text.",
              "default": null,
              "required": false,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "confirm",
              "desc": "If true, then user will be asked to confirm input value before indicator is added to chart.  \nDefault value is false.",
              "default": "false",
              "required": false,
              "displayType": "const bool",
              "allowedTypeIDs": [
                "const bool"
              ],
              "possibleValues": [
                "true",
                "false"
              ]
            },
            {
              "name": "display",
              "desc": "Controls where the script will display the input\\`s information, aside from within the script\\`s settings.  \nThis option allows one to remove a specific input from the script\\`s status line or the Data Window to ensure only the most necessary inputs are displayed there. \nPossible values: [display.none](#var_display.none), [display.data_window](#var_display.data_window), [display.status_line](#var_display.status_line), [display.all](#var_display.all).  \nOptional. The default is [display.all](#var_display.all).",
              "default": "display.all",
              "required": false,
              "displayType": "const plot_display",
              "allowedTypeIDs": [
                "const plot_display"
              ],
              "possibleValues": [
                "display.none",
                "display.pane",
                "display.data_window",
                "display.price_scale",
                "display.status_line",
                "display.all"
              ]
            }
          ],
          "syntax": "input.timeframe(defval, title, options, tooltip, inline, group, confirm, display) → input string",
          "remarks": "Result of [input.timeframe](#fun_input.timeframe) function always should be assigned to a variable, see examples above.",
          "returns": "Value of input variable.",
          "seeAlso": [
            "[input.bool](#fun_input.bool)",
            "[input.int](#fun_input.int)",
            "[input.float](#fun_input.float)",
            "[input.string](#fun_input.string)",
            "[input.text_area](#fun_input.text_area)",
            "[input.symbol](#fun_input.symbol)",
            "[input.session](#fun_input.session)",
            "[input.source](#fun_input.source)",
            "[input.color](#fun_input.color)",
            "[input.time](#fun_input.time)",
            "[input](#fun_input)"
          ],
          "examples": "//@version=5\nindicator(\"input.timeframe\", overlay=true)\ni_res = input.timeframe('D', \"Resolution\", options=['D', 'W', 'M'])\ns = request.security(\"AAPL\", i_res, close)\nplot(s)",
          "returnedType": "string",
          "returnedTypes": [
            "input string",
            "const string"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "input.session",
          "desc": "Adds an input to the Inputs tab of your script\\`s Settings, which allows you to provide configuration options to script users. This function adds two dropdowns that allow the user to specify the beginning and the end of a session using the session selector and returns the result as a string.",
          "args": [
            {
              "name": "defval",
              "desc": "Determines the default value of the input variable proposed in the script\\`s \"Settings/Inputs\" tab, from where the user can change it.  \nWhen a list of values is used with the `options` parameter, the value must be one of them.",
              "default": null,
              "required": true,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "title",
              "desc": "Title of the input. If not specified, the variable name is used as the input\\`s title.  \nIf the title is specified, but it is empty, the name will be an empty string.",
              "default": "'variable_name'",
              "required": false,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "options",
              "desc": "A list of options to choose from.",
              "default": null,
              "required": false,
              "displayType": "const string [val1, val2, ...]",
              "allowedTypeIDs": [
                "[const string...]"
              ],
              "possibleValues": null
            },
            {
              "name": "tooltip",
              "desc": "The string that will be shown to the user when hovering over the tooltip icon.",
              "default": null,
              "required": false,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "inline",
              "desc": "Combines all the input calls using the same argument in one line. The string used as an argument is not displayed.  \nIt is only used to identify inputs belonging to the same line.",
              "default": null,
              "required": false,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "group",
              "desc": "Creates a header above all inputs using the same group argument string. The string is also used as the header\\`s text.",
              "default": null,
              "required": false,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "confirm",
              "desc": "If true, then user will be asked to confirm input value before indicator is added to chart.  \nDefault value is false.",
              "default": "false",
              "required": false,
              "displayType": "const bool",
              "allowedTypeIDs": [
                "const bool"
              ],
              "possibleValues": [
                "true",
                "false"
              ]
            },
            {
              "name": "display",
              "desc": "Controls where the script will display the input\\`s information, aside from within the script\\`s settings.  \nThis option allows one to remove a specific input from the script\\`s status line or the Data Window to ensure only the most necessary inputs are displayed there. \nPossible values: [display.none](#var_display.none), [display.data_window](#var_display.data_window), [display.status_line](#var_display.status_line), [display.all](#var_display.all).  \nOptional. The default is [display.all](#var_display.all).",
              "default": "display.all",
              "required": false,
              "displayType": "const plot_display",
              "allowedTypeIDs": [
                "const plot_display"
              ],
              "possibleValues": [
                "display.none",
                "display.pane",
                "display.data_window",
                "display.price_scale",
                "display.status_line",
                "display.all"
              ]
            }
          ],
          "syntax": "input.session(defval, title, options, tooltip, inline, group, confirm, display) → input string",
          "remarks": "Result of [input.session](#fun_input.session) function always should be assigned to a variable, see examples above.",
          "returns": "Value of input variable.",
          "seeAlso": [
            "[input.bool](#fun_input.bool)",
            "[input.int](#fun_input.int)",
            "[input.float](#fun_input.float)",
            "[input.string](#fun_input.string)",
            "[input.text_area](#fun_input.text_area)",
            "[input.symbol](#fun_input.symbol)",
            "[input.timeframe](#fun_input.timeframe)",
            "[input.source](#fun_input.source)",
            "[input.color](#fun_input.color)",
            "[input.time](#fun_input.time)",
            "[input](#fun_input)"
          ],
          "examples": "//@version=5\nindicator(\"input.session\", overlay=true)\ni_sess = input.session(\"1300-1700\", \"Session\", options=[\"0930-1600\", \"1300-1700\", \"1700-2100\"])\nt = time(timeframe.period, i_sess)\nbgcolor(time == t ? color.green : na)",
          "returnedType": "string",
          "returnedTypes": [
            "input string",
            "const string"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "input.source",
          "desc": "Adds an input to the Inputs tab of your script\\`s Settings, which allows you to provide configuration options to script users.  \nThis function adds a dropdown that allows the user to select a source for the calculation, e.g. [close](#var_close), [hl2](#var_hl2), etc.  \nThe user can also select an output from another indicator on their chart as the source.",
          "args": [
            {
              "name": "defval",
              "desc": "Determines the default value of the input variable proposed in the script\\`s \"Settings/Inputs\" tab, from where the user can change it.",
              "default": null,
              "required": true,
              "displayType": "<open|high|low|close|hl2|hlc3|ohlc4|hlcc4>",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "open",
                "high",
                "low",
                "close",
                "hl2"
              ]
            },
            {
              "name": "title",
              "desc": "Title of the input. If not specified, the variable name is used as the input\\`s title.  \nIf the title is specified, but it is empty, the name will be an empty string.",
              "default": "'variable_name'",
              "required": false,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "tooltip",
              "desc": "The string that will be shown to the user when hovering over the tooltip icon.",
              "default": null,
              "required": false,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "inline",
              "desc": "Combines all the input calls using the same argument in one line. The string used as an argument is not displayed.  \nIt is only used to identify inputs belonging to the same line.",
              "default": null,
              "required": false,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "group",
              "desc": "Creates a header above all inputs using the same group argument string. The string is also used as the header\\`s text.",
              "default": null,
              "required": false,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "display",
              "desc": "Controls where the script will display the input\\`s information, aside from within the script\\`s settings.  \nThis option allows one to remove a specific input from the script\\`s status line or the Data Window to ensure only the most necessary inputs are displayed there. \nPossible values: [display.none](#var_display.none), [display.data_window](#var_display.data_window), [display.status_line](#var_display.status_line), [display.all](#var_display.all).  \nOptional. The default is [display.all](#var_display.all).",
              "default": "display.all",
              "required": false,
              "displayType": "const plot_display",
              "allowedTypeIDs": [
                "const plot_display"
              ],
              "possibleValues": [
                "display.none",
                "display.pane",
                "display.data_window",
                "display.price_scale",
                "display.status_line",
                "display.all"
              ]
            }
          ],
          "syntax": "input.source(defval, title, tooltip, inline, group, display) → series float",
          "remarks": "Result of [input.source](#fun_input.source) function always should be assigned to a variable, see examples above.",
          "returns": "Value of input variable.",
          "seeAlso": [
            "[input.bool](#fun_input.bool)",
            "[input.int](#fun_input.int)",
            "[input.float](#fun_input.float)",
            "[input.string](#fun_input.string)",
            "[input.text_area](#fun_input.text_area)",
            "[input.symbol](#fun_input.symbol)",
            "[input.timeframe](#fun_input.timeframe)",
            "[input.session](#fun_input.session)",
            "[input.color](#fun_input.color)",
            "[input.time](#fun_input.time)",
            "[input](#fun_input)"
          ],
          "examples": "//@version=5\nindicator(\"input.source\", overlay=true)\ni_src = input.source(close, \"Source\")\nplot(i_src)",
          "returnedType": "float",
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "input.color",
          "desc": "Adds an input to the Inputs tab of your script\\`s Settings, which allows you to provide configuration options to script users. This function adds a color picker that allows the user to select a color and transparency, either from a palette or a hex value.",
          "args": [
            {
              "name": "defval",
              "desc": "Determines the default value of the input variable proposed in the script\\`s \"Settings/Inputs\" tab, from where the user can change it.",
              "default": null,
              "required": true,
              "displayType": "const color",
              "allowedTypeIDs": [
                "const color"
              ],
              "possibleValues": [
                "colors"
              ]
            },
            {
              "name": "title",
              "desc": "Title of the input. If not specified, the variable name is used as the input\\`s title.  \nIf the title is specified, but it is empty, the name will be an empty string.",
              "default": "'variable_name'",
              "required": false,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "tooltip",
              "desc": "The string that will be shown to the user when hovering over the tooltip icon.",
              "default": null,
              "required": false,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "inline",
              "desc": "Combines all the input calls using the same argument in one line. The string used as an argument is not displayed.  \nIt is only used to identify inputs belonging to the same line.",
              "default": null,
              "required": false,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "group",
              "desc": "Creates a header above all inputs using the same group argument string. The string is also used as the header\\`s text.",
              "default": null,
              "required": false,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "confirm",
              "desc": "If true, then user will be asked to confirm input value before indicator is added to chart.  \nDefault value is false.",
              "default": "false",
              "required": false,
              "displayType": "const bool",
              "allowedTypeIDs": [
                "const bool"
              ],
              "possibleValues": [
                "true",
                "false"
              ]
            },
            {
              "name": "display",
              "desc": "Controls where the script will display the input\\`s information, aside from within the script\\`s settings.  \nThis option allows one to remove a specific input from the script\\`s status line or the Data Window to ensure only the most necessary inputs are displayed there. \nPossible values: [display.none](#var_display.none), [display.data_window](#var_display.data_window), [display.status_line](#var_display.status_line), [display.all](#var_display.all).  \nOptional. The default is [display.none](#var_display.none).",
              "default": "display.none",
              "required": false,
              "displayType": "const plot_display",
              "allowedTypeIDs": [
                "const plot_display"
              ],
              "possibleValues": [
                "display.none",
                "display.pane",
                "display.data_window",
                "display.price_scale",
                "display.status_line",
                "display.all"
              ]
            }
          ],
          "syntax": "input.color(defval, title, tooltip, inline, group, confirm, display) → input color",
          "remarks": "Result of [input.color](#fun_input.color) function always should be assigned to a variable, see examples above.",
          "returns": "Value of input variable.",
          "seeAlso": [
            "[input.bool](#fun_input.bool)",
            "[input.int](#fun_input.int)",
            "[input.float](#fun_input.float)",
            "[input.string](#fun_input.string)",
            "[input.text_area](#fun_input.text_area)",
            "[input.symbol](#fun_input.symbol)",
            "[input.timeframe](#fun_input.timeframe)",
            "[input.session](#fun_input.session)",
            "[input.source](#fun_input.source)",
            "[input.time](#fun_input.time)",
            "[input](#fun_input)"
          ],
          "examples": "//@version=5\nindicator(\"input.color\", overlay=true)\ni_col = input.color(color.red, \"Plot Color\")\nplot(close, color=i_col)",
          "returnedType": "color",
          "returnedTypes": [
            "input color",
            "const color"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "input.time",
          "desc": "Adds a time input to the script\\`s \"Settings/Inputs\" tab. This function adds two input widgets on the same line: one for the date and one for the time.  \nThe function returns a date/time value in UNIX format.  \nUsing `confirm = true` activates the interactive input mode where a point in time is selected by clicking on the chart.",
          "args": [
            {
              "name": "defval",
              "desc": "Determines the default value of the input variable proposed in the script\\`s \"Settings/Inputs\" tab, from where the user can change it.  \nThe value can be a [timestamp](#fun_timestamp) function, but only if it uses a date argument in const string format.",
              "default": null,
              "required": true,
              "displayType": "const int",
              "allowedTypeIDs": [
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "title",
              "desc": "Title of the input. If not specified, the variable name is used as the input\\`s title.  \nIf the title is specified, but it is empty, the name will be an empty string.",
              "default": "'variable_name'",
              "required": false,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "tooltip",
              "desc": "The string that will be shown to the user when hovering over the tooltip icon.",
              "default": null,
              "required": false,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "inline",
              "desc": "Combines all the input calls using the same argument in one line. The string used as an argument is not displayed.  \nIt is only used to identify inputs belonging to the same line.",
              "default": null,
              "required": false,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "group",
              "desc": "Creates a header above all inputs using the same group argument string. The string is also used as the header\\`s text.",
              "default": null,
              "required": false,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "confirm",
              "desc": "If true, the interactive input mode is enabled and the selection is done by clicking on the chart when the indicator is added to the chart, or by selecting the indicator and moving the selection after that.  \nOptional. The default is false.",
              "default": "false",
              "required": false,
              "displayType": "const bool",
              "allowedTypeIDs": [
                "const bool"
              ],
              "possibleValues": [
                "true",
                "false"
              ]
            },
            {
              "name": "display",
              "desc": "Controls where the script will display the input\\`s information, aside from within the script\\`s settings.  \nThis option allows one to remove a specific input from the script\\`s status line or the Data Window to ensure only the most necessary inputs are displayed there. \nPossible values: [display.none](#var_display.none), [display.data_window](#var_display.data_window), [display.status_line](#var_display.status_line), [display.all](#var_display.all).  \nOptional. The default is [display.none](#var_display.none).",
              "default": "display.none",
              "required": false,
              "displayType": "const plot_display",
              "allowedTypeIDs": [
                "const plot_display"
              ],
              "possibleValues": [
                "display.none",
                "display.pane",
                "display.data_window",
                "display.price_scale",
                "display.status_line",
                "display.all"
              ]
            }
          ],
          "syntax": "input.time(defval, title, tooltip, inline, group, confirm, display) → input int",
          "remarks": "When using interactive mode, a price input can be combined with a time input if both function calls use the same argument for their `inline` parameter.",
          "returns": "Value of input variable.",
          "seeAlso": [
            "[input.bool](#fun_input.bool)",
            "[input.int](#fun_input.int)",
            "[input.float](#fun_input.float)",
            "[input.string](#fun_input.string)",
            "[input.text_area](#fun_input.text_area)",
            "[input.symbol](#fun_input.symbol)",
            "[input.timeframe](#fun_input.timeframe)",
            "[input.session](#fun_input.session)",
            "[input.source](#fun_input.source)",
            "[input.color](#fun_input.color)",
            "[input](#fun_input)"
          ],
          "examples": "//@version=5\nindicator(\"input.time\", overlay=true)\ni_date = input.time(timestamp(\"20 Jul 2021 00:00 +0300\"), \"Date\")\nl = label.new(i_date, high, \"Date\", xloc=xloc.bar_time)\nlabel.delete(l[1])",
          "returnedType": "int",
          "returnedTypes": [
            "input int",
            "const int"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "input.price",
          "desc": "Adds a price input to the script\\`s \"Settings/Inputs\" tab. Using `confirm = true` activates the interactive input mode where a price is selected by clicking on the chart.",
          "args": [
            {
              "name": "defval",
              "desc": "Determines the default value of the input variable proposed in the script\\`s \"Settings/Inputs\" tab, from where the user can change it.",
              "default": null,
              "required": true,
              "displayType": "const int|float",
              "allowedTypeIDs": [
                "const int",
                "const float"
              ],
              "possibleValues": null
            },
            {
              "name": "title",
              "desc": "Title of the input. If not specified, the variable name is used as the input\\`s title.  \nIf the title is specified, but it is empty, the name will be an empty string.",
              "default": "'variable_name'",
              "required": false,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "tooltip",
              "desc": "The string that will be shown to the user when hovering over the tooltip icon.",
              "default": null,
              "required": false,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "inline",
              "desc": "Combines all the input calls using the same argument in one line. The string used as an argument is not displayed.  \nIt is only used to identify inputs belonging to the same line.",
              "default": null,
              "required": false,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "group",
              "desc": "Creates a header above all inputs using the same group argument string. The string is also used as the header\\`s text.",
              "default": null,
              "required": false,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "confirm",
              "desc": "If true, the interactive input mode is enabled and the selection is done by clicking on the chart when the indicator is added to the chart, or by selecting the indicator and moving the selection after that.  \nOptional. The default is false.",
              "default": "false",
              "required": false,
              "displayType": "const bool",
              "allowedTypeIDs": [
                "const bool"
              ],
              "possibleValues": [
                "true",
                "false"
              ]
            },
            {
              "name": "display",
              "desc": "Controls where the script will display the input\\`s information, aside from within the script\\`s settings.  \nThis option allows one to remove a specific input from the script\\`s status line or the Data Window to ensure only the most necessary inputs are displayed there. \nPossible values: [display.none](#var_display.none), [display.data_window](#var_display.data_window), [display.status_line](#var_display.status_line), [display.all](#var_display.all).  \nOptional. The default is [display.all](#var_display.all).",
              "default": "display.all",
              "required": false,
              "displayType": "const plot_display",
              "allowedTypeIDs": [
                "const plot_display"
              ],
              "possibleValues": [
                "display.none",
                "display.pane",
                "display.data_window",
                "display.price_scale",
                "display.status_line",
                "display.all"
              ]
            }
          ],
          "syntax": "input.price(defval, title, tooltip, inline, group, confirm, display) → input float",
          "remarks": "When using interactive mode, a time input can be combined with a price input if both function calls use the same argument for their `inline` parameter.",
          "returns": "Value of input variable.",
          "seeAlso": [
            "[input.bool](#fun_input.bool)",
            "[input.int](#fun_input.int)",
            "[input.float](#fun_input.float)",
            "[input.string](#fun_input.string)",
            "[input.text_area](#fun_input.text_area)",
            "[input.symbol](#fun_input.symbol)",
            "[input.resolution](#fun_input.resolution)",
            "[input.session](#fun_input.session)",
            "[input.source](#fun_input.source)",
            "[input.color](#fun_input.color)",
            "[input](#fun_input)"
          ],
          "examples": "//@version=5\nindicator(\"input.price\", overlay=true)\nprice1 = input.price(title=\"Date\", defval=42)\nplot(price1)\n\nprice2 = input.price(54, title=\"Date\")\nplot(price2)",
          "returnedType": "float",
          "returnedTypes": [
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "hline",
          "desc": "Renders a horizontal line at a given fixed price level.",
          "args": [
            {
              "name": "price",
              "desc": "Price value at which the object will be rendered. Required argument.",
              "default": null,
              "required": true,
              "displayType": "input int|float",
              "allowedTypeIDs": [
                "input int",
                "const int",
                "input float",
                "const float"
              ],
              "possibleValues": null
            },
            {
              "name": "title",
              "desc": "Title of the object.",
              "default": null,
              "required": true,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "color",
              "desc": "Color of the rendered line. Must be a constant value (not an expression). Optional argument.",
              "default": null,
              "required": false,
              "displayType": "input color",
              "allowedTypeIDs": [
                "input color",
                "const color"
              ],
              "possibleValues": [
                "colors"
              ]
            },
            {
              "name": "linestyle",
              "desc": "Style of the rendered line. Possible values are: [hline.style_solid](#var_hline.style_solid), [hline.style_dotted](#var_hline.style_dotted), [hline.style_dashed](#var_hline.style_dashed).  \nOptional argument.",
              "default": "hline.style_solid",
              "required": false,
              "displayType": "input hline_style",
              "allowedTypeIDs": [
                "input hline_style"
              ],
              "possibleValues": [
                "hline.style_solid",
                "hline.style_dotted",
                "hline.style_dashed"
              ]
            },
            {
              "name": "linewidth",
              "desc": "Width of the rendered line. Default value is 1.",
              "default": "1",
              "required": false,
              "displayType": "input int",
              "allowedTypeIDs": [
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            },
            {
              "name": "editable",
              "desc": "If true then hline style will be editable in Format dialog. Default is true.",
              "default": "true",
              "required": false,
              "displayType": "const bool",
              "allowedTypeIDs": [
                "const bool"
              ],
              "possibleValues": [
                "true",
                "false"
              ]
            },
            {
              "name": "display",
              "desc": "Controls where the hline is displayed. Possible values are: [display.none](#var_display.none), [display.all](#var_display.all).  \nDefault is [display.all](#var_display.all).",
              "default": "display.all",
              "required": false,
              "displayType": "input plot_simple_display",
              "allowedTypeIDs": [
                "input plot_simple_display"
              ],
              "possibleValues": [
                "display.none",
                "display.pane",
                "display.data_window",
                "display.price_scale",
                "display.status_line",
                "display.all"
              ]
            }
          ],
          "syntax": "hline(price, title, color, linestyle, linewidth, editable, display) → hline",
          "returns": "An hline object, that can be used in [fill](#fun_fill)",
          "seeAlso": [
            "[fill](#fun_fill)"
          ],
          "examples": "//@version=5\nindicator(\"input.hline\", overlay=true)\nhline(3.14, title='Pi', color=color.blue, linestyle=hline.style_dotted, linewidth=2)\n\n// You may fill the background between any two hlines with a fill() function:\nh1 = hline(20)\nh2 = hline(10)\nfill(h1, h2, color=color.new(color.green, 90))",
          "returnedType": "hline",
          "returnedTypes": [
            "hline"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "fill",
          "desc": "Fills background between two plots or hlines with a given color.",
          "args": [
            {
              "name": "hline1",
              "desc": "The first hline object. Required argument.",
              "default": null,
              "required": true,
              "displayType": "hline",
              "allowedTypeIDs": [
                "hline"
              ],
              "possibleValues": null
            },
            {
              "name": "hline2",
              "desc": "The second hline object. Required argument.",
              "default": null,
              "required": true,
              "displayType": "hline",
              "allowedTypeIDs": [
                "hline"
              ],
              "possibleValues": null
            },
            {
              "name": "plot1",
              "desc": "The first plot object. Required argument.",
              "default": null,
              "required": true,
              "displayType": "plot",
              "allowedTypeIDs": [
                "plot"
              ],
              "possibleValues": null
            },
            {
              "name": "plot2",
              "desc": "The second plot object. Required argument.",
              "default": null,
              "required": true,
              "displayType": "plot",
              "allowedTypeIDs": [
                "plot"
              ],
              "possibleValues": null
            },
            {
              "name": "color",
              "desc": "Color of the background fill. You can use constants like 'color=color.red' or 'color=#ff001a' as well as complex expressions like 'color = close >= open ? color.green : color.red'.  \nOptional argument.",
              "default": null,
              "required": false,
              "displayType": "series color",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "possibleValues": [
                "colors"
              ]
            },
            {
              "name": "title",
              "desc": "Title of the created fill object. Optional argument.",
              "default": null,
              "required": false,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "editable",
              "desc": "If true then fill style will be editable in Format dialog. Default is true.",
              "default": "true",
              "required": false,
              "displayType": "const bool",
              "allowedTypeIDs": [
                "const bool"
              ],
              "possibleValues": [
                "true",
                "false"
              ]
            },
            {
              "name": "show_last",
              "desc": "If set, defines the number of bars (from the last bar back to the past) to fill on chart.",
              "default": null,
              "required": true,
              "displayType": "input int",
              "allowedTypeIDs": [
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "fillgaps",
              "desc": "Controls continuing fills on gaps, i.e., when one of the plot() calls returns an na value.  \nWhen true, the last fill will continue on gaps.  \nThe default is false.",
              "default": "false",
              "required": false,
              "displayType": "const bool",
              "allowedTypeIDs": [
                "const bool"
              ],
              "possibleValues": [
                "true",
                "false"
              ]
            },
            {
              "name": "display",
              "desc": "Controls where the fill is displayed. Possible values are: [display.none](#var_display.none), [display.all](#var_display.all).  \nDefault is [display.all](#var_display.all).",
              "default": "display.all",
              "required": false,
              "displayType": "input plot_simple_display",
              "allowedTypeIDs": [
                "input plot_simple_display"
              ],
              "possibleValues": [
                "display.none",
                "display.pane",
                "display.data_window",
                "display.price_scale",
                "display.status_line",
                "display.all"
              ]
            },
            {
              "name": "top_value",
              "desc": "Value where the gradient uses the `top_color`.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            },
            {
              "name": "bottom_value",
              "desc": "Value where the gradient uses the `bottom_color`.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            },
            {
              "name": "top_color",
              "desc": "Color of the gradient at the topmost value.",
              "default": null,
              "required": true,
              "displayType": "series color",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "possibleValues": [
                "colors"
              ]
            },
            {
              "name": "bottom_color",
              "desc": "Color of the gradient at the bottommost value.",
              "default": null,
              "required": true,
              "displayType": "series color",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "possibleValues": [
                "colors"
              ]
            }
          ],
          "syntax": "fill(plot1, plot2, color, title, editable, fillgaps, display) → void\nfill(plot1, plot2, top_value, bottom_value, top_color, bottom_color, title, display, fillgaps, editable) → void\nfill(hline1, hline2, color, title, editable, fillgaps, display) → void\nfill(hline1, hline2, top_value, bottom_value, top_color, bottom_color, title, display, fillgaps, editable) → void",
          "seeAlso": [
            "[plot](#fun_plot)",
            "[barcolor](#fun_barcolor)",
            "[bgcolor](#fun_bgcolor)",
            "[hline](#fun_hline)",
            "[color.new](#fun_color.new)"
          ],
          "returnedType": "void",
          "detailedDesc": [
            {
              "desc": "Fill between two horizontal lines",
              "examples": "//@version=5\nindicator(\"Fill between hlines\", overlay = false)\nh1 = hline(20)\nh2 = hline(10)\nfill(h1, h2, color = color.new(color.blue, 90))"
            },
            {
              "desc": "Fill between two plots",
              "examples": "//@version=5\nindicator(\"Fill between plots\", overlay = true)\np1 = plot(open)\np2 = plot(close)\nfill(p1, p2, color = color.new(color.green, 90))"
            },
            {
              "desc": "Gradient fill between two horizontal lines",
              "examples": "//@version=5\nindicator(\"Gradient Fill between hlines\", overlay = false)\ntopVal = input.int(100)\nbotVal = input.int(0)\ntopCol = input.color(color.red)\nbotCol = input.color(color.blue)\ntopLine = hline(100, color = topCol, linestyle = hline.style_solid)\nbotLine = hline(0,   color = botCol, linestyle = hline.style_solid)\nfill(topLine, botLine, topVal, botVal, topCol, botCol)"
            }
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "nz",
          "desc": "Replaces NaN values with zeros (or given value) in a series.",
          "args": [
            {
              "name": "source",
              "desc": "Series of values to process.",
              "default": null,
              "required": true,
              "displayType": "series int|float|bool|color",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float",
                "series bool",
                "simple bool",
                "input bool",
                "const bool",
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "possibleValues": null
            },
            {
              "name": "replacement",
              "desc": "Value that will replace all ‘na’ values in the `source` series.",
              "default": null,
              "required": true,
              "displayType": "series int|float|bool|color",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float",
                "series bool",
                "simple bool",
                "input bool",
                "const bool",
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "nz(source, replacement) → series type\nnz(source) → series type",
          "returns": "The value of `source` if it is not `na`. If the value of `source` is `na`, returns zero, or the `replacement` argument when one is used.",
          "seeAlso": [
            "[na](#var_na)",
            "[na](#fun_na)",
            "[fixnan](#fun_fixnan)"
          ],
          "examples": "//@version=5\nindicator(\"nz\", overlay=true)\nplot(nz(ta.sma(close, 100)))",
          "returnedType": [
            "float",
            "color",
            "int",
            "bool"
          ],
          "returnedTypes": [
            "simple int",
            "input int",
            "const int",
            "simple float",
            "input float",
            "const float",
            "simple color",
            "input color",
            "const color",
            "simple bool",
            "input bool",
            "const bool",
            "series int",
            "series float",
            "series color",
            "series bool"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "math.pow",
          "desc": "Mathematical power function.",
          "args": [
            {
              "name": "base",
              "desc": "Specify the base to use.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            },
            {
              "name": "exponent",
              "desc": "Specifies the exponent.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "math.pow(base, exponent) → series float",
          "returns": "`base` raised to the power of `exponent`. If `base` is a series, it is calculated elementwise.",
          "seeAlso": [
            "[math.sqrt](#fun_math.sqrt)",
            "[math.exp](#fun_math.exp)"
          ],
          "examples": "//@version=5\nindicator(\"math.pow\", overlay=true)\nplot(math.pow(close, 2))",
          "returnedType": "float",
          "returnedTypes": [
            "simple float",
            "input float",
            "const float",
            "series float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "math.min",
          "desc": "Returns the smallest of multiple values.",
          "args": [
            {
              "name": "arg0, arg1, ...",
              "desc": "One of x numbers to find the `min` or `smallest` of the group.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "math.min(number0, number1, ...) → series int|float",
          "returns": "The smallest of multiple given values.",
          "seeAlso": [
            "[math.max](#fun_math.max)"
          ],
          "examples": "//@version=5\nindicator(\"math.min\", overlay=true)\nplot(math.min(close, open))\nplot(math.min(close, math.min(open, 42)))",
          "returnedType": [
            "float",
            "int"
          ],
          "returnedTypes": [
            "simple int",
            "input int",
            "const int",
            "simple float",
            "input float",
            "const float",
            "series int",
            "series float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "math.max",
          "desc": "Returns the greatest of multiple values.",
          "args": [
            {
              "name": "arg0, arg1, ...",
              "desc": "One of x numbers to find the `max` or `greatest` of the group.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "math.max(number0, number1, ...) → series int|float",
          "returns": "The greatest of multiple given values.",
          "seeAlso": [
            "[math.min](#fun_math.min)"
          ],
          "examples": "//@version=5\nindicator(\"math.max\", overlay=true)\nplot(math.max(close, open))\nplot(math.max(close, math.max(open, 42)))",
          "returnedType": [
            "float",
            "int"
          ],
          "returnedTypes": [
            "simple int",
            "input int",
            "const int",
            "simple float",
            "input float",
            "const float",
            "series int",
            "series float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "math.abs",
          "desc": "Absolute value of `number` is `number` if `number` >= 0, or if `number` is < 0 `number` is `(-2 * number)`",
          "args": [
            {
              "name": "number",
              "desc": "The number to find absolute value for.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "math.abs(number) → series float",
          "returns": "The absolute value of `number`.",
          "returnedType": [
            "float",
            "int"
          ],
          "returnedTypes": [
            "simple int",
            "input int",
            "const int",
            "series int",
            "simple float",
            "input float",
            "const float",
            "series float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "math.log",
          "desc": "Natural logarithm of any `number` > 0 is the unique y such that e^y = `number`.",
          "args": [
            {
              "name": "number",
              "desc": "The number to use in the calculation.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "math.log(number) → series float",
          "returns": "The natural logarithm of `number`.",
          "seeAlso": [
            "[math.log10](#fun_math.log10)"
          ],
          "returnedType": "float",
          "returnedTypes": [
            "simple float",
            "input float",
            "const float",
            "series float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "math.log10",
          "desc": "The common (or base 10) logarithm of `number` is the power to which 10 must be raised to obtain the `number`.  \n10^y = `number`.",
          "args": [
            {
              "name": "number",
              "desc": "The number to find the `log 10 or base 10` for.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "math.log10(number) → series float",
          "returns": "The base 10 logarithm of `number`.",
          "seeAlso": [
            "[math.log](#fun_math.log)"
          ],
          "returnedType": "float",
          "returnedTypes": [
            "simple float",
            "input float",
            "const float",
            "series float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "math.sqrt",
          "desc": "Square root of any `number` >= 0 is the unique y >= 0 such that y^2 = `number`.",
          "args": [
            {
              "name": "number",
              "desc": "The number to find the Square root of.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "math.sqrt(number) → series float",
          "returns": "The square root of `number`.",
          "seeAlso": [
            "[math.pow](#fun_math.pow)"
          ],
          "returnedType": "float",
          "returnedTypes": [
            "simple float",
            "input float",
            "const float",
            "series float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "math.sign",
          "desc": "Sign (signum) of `number` is zero if `number` is zero, 1.0 if `number` is greater than zero, -1.0 if `number` is less than zero.",
          "args": [
            {
              "name": "number",
              "desc": "Number to calculate the sign of.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                -1,
                0,
                1
              ]
            }
          ],
          "syntax": "math.sign(number) → series float",
          "returns": "The sign of the argument.",
          "returnedType": "float",
          "returnedTypes": [
            "simple float",
            "input float",
            "const float",
            "series float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "math.exp",
          "desc": "The exp function of `number` is e raised to the power of `number`, where e is Euler\\`s number.",
          "args": [
            {
              "name": "number",
              "desc": "Number to calculate the exponent of.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "math.exp(number) → series float",
          "returns": "A value representing e raised to the power of `number`.",
          "seeAlso": [
            "[math.pow](#fun_math.pow)"
          ],
          "returnedType": "float",
          "returnedTypes": [
            "simple float",
            "input float",
            "const float",
            "series float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "math.sin",
          "desc": "The sin function returns the trigonometric sine of an angle.",
          "args": [
            {
              "name": "angle",
              "desc": "Angle, in radians.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "math.sin(angle) → series float",
          "returns": "The trigonometric sine of an angle.",
          "returnedType": "float",
          "returnedTypes": [
            "simple float",
            "input float",
            "const float",
            "series float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "math.cos",
          "desc": "The cos function returns the trigonometric cosine of an angle.",
          "args": [
            {
              "name": "angle",
              "desc": "Angle, in radians.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "math.cos(angle) → series float",
          "returns": "The trigonometric cosine of an angle.",
          "returnedType": "float",
          "returnedTypes": [
            "simple float",
            "input float",
            "const float",
            "series float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "math.tan",
          "desc": "The tan function returns the trigonometric tangent of an angle.",
          "args": [
            {
              "name": "angle",
              "desc": "Angle, in radians.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "math.tan(angle) → series float",
          "returns": "The trigonometric tangent of an angle.",
          "returnedType": "float",
          "returnedTypes": [
            "simple float",
            "input float",
            "const float",
            "series float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "math.asin",
          "desc": "The asin function returns the arcsine (in radians) of number such that sin(asin(y)) = y for y in range [-1, 1].",
          "args": [
            {
              "name": "angle",
              "desc": "Angle, in radians.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "math.asin(angle) → series float",
          "returns": "The arcsine of a value; the returned angle is in the range [-Pi/2, Pi/2], or [na](#var_na) if y is outside of range [-1, 1].",
          "returnedType": "float",
          "returnedTypes": [
            "simple float",
            "input float",
            "const float",
            "series float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "math.acos",
          "desc": "The acos function returns the arccosine (in radians) of number such that cos(acos(y)) = y for y in range [-1, 1].",
          "args": [
            {
              "name": "angle",
              "desc": "Angle, in radians.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "math.acos(angle) → series float",
          "returns": "The arc cosine of a value; the returned angle is in the range [0, Pi], or [na](#var_na) if y is outside of range [-1, 1].",
          "returnedType": "float",
          "returnedTypes": [
            "simple float",
            "input float",
            "const float",
            "series float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "math.atan",
          "desc": "The atan function returns the arctangent (in radians) of number such that tan(atan(y)) = y for any y.",
          "args": [
            {
              "name": "angle",
              "desc": "Angle, in radians.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "math.atan(angle) → series float",
          "returns": "The arc tangent of a value; the returned angle is in the range [-Pi/2, Pi/2].",
          "returnedType": "float",
          "returnedTypes": [
            "simple float",
            "input float",
            "const float",
            "series float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "math.ceil",
          "desc": "The ceil function returns the smallest (closest to negative infinity) integer that is greater than or equal to the argument.",
          "args": [
            {
              "name": "number",
              "desc": "Number to calculate the smallest integer greater than or equal to the argument.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "math.ceil(number) → int",
          "returns": "The smallest integer greater than or equal to the given number.",
          "seeAlso": [
            "[math.floor](#fun_math.floor)",
            "[math.round](#fun_math.round)"
          ],
          "returnedType": "int",
          "returnedTypes": [
            "simple int",
            "input int",
            "const int",
            "series int"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "math.floor",
          "desc": "The floor function returns the largest (closest to positive infinity) integer that is less than or equal to the argument.",
          "args": [
            {
              "name": "number",
              "desc": "Number to calculate the largest integer less than or equal to the argument.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "math.floor(number) → series int",
          "returns": "The largest integer less than or equal to the given number.",
          "seeAlso": [
            "[math.ceil](#fun_math.ceil)",
            "[math.round](#fun_math.round)"
          ],
          "returnedType": "int",
          "returnedTypes": [
            "simple int",
            "input int",
            "const int",
            "series int"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "math.round",
          "desc": "Returns the value of `number` rounded to the nearest integer, with ties rounding up.  \nIf the `precision` parameter is used, returns a float value rounded to that amount of decimal places.",
          "args": [
            {
              "name": "number",
              "desc": "The value to be rounded.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            },
            {
              "name": "precision",
              "desc": "Optional argument. Decimal places to which `number` will be rounded. When no argument is supplied, rounding is to the nearest integer.",
              "default": null,
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "math.round(number, precision) → series float",
          "remarks": "Note that for 'na' values function returns 'na'.",
          "returns": "The value of `number` rounded to the nearest integer, or according to precision.",
          "seeAlso": [
            "[math.ceil](#fun_math.ceil)",
            "[math.floor](#fun_math.floor)"
          ],
          "returnedType": [
            "float",
            "int"
          ],
          "returnedTypes": [
            "simple int",
            "input int",
            "const int",
            "series int",
            "simple float",
            "input float",
            "const float",
            "series float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "math.round_to_mintick",
          "desc": "Returns the value rounded to the symbol\\`s mintick, i.e. the nearest value that can be divided by [syminfo.mintick](#var_syminfo.mintick), without the remainder, with ties rounding up.",
          "args": [
            {
              "name": "number",
              "desc": "The value to be rounded.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "math.round_to_mintick(number) → series float",
          "remarks": "Note that for 'na' values function returns 'na'.",
          "returns": "The `number` rounded to tick precision.",
          "seeAlso": [
            "[math.ceil](#fun_math.ceil)",
            "[math.floor](#fun_math.floor)"
          ],
          "returnedType": "float",
          "returnedTypes": [
            "simple float",
            "input float",
            "const float",
            "series float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "ta.median",
          "desc": "Returns the median of the series.",
          "args": [
            {
              "name": "source",
              "desc": "Series of values to process.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "close",
                "open",
                "high",
                "low",
                "volume"
              ]
            },
            {
              "name": "length",
              "desc": "Number of bars (length).",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "5",
                "10",
                "14",
                "20",
                "50"
              ]
            }
          ],
          "syntax": "ta.median(source, length) → series float|int",
          "remarks": "`na` values in the `source` series are ignored; the function calculates on the `length` quantity of non-`na` values.",
          "returns": "The median of the series.",
          "returnedType": [
            "float",
            "int"
          ],
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float",
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "ta.max",
          "desc": "Returns the all-time high value of `source` from the beginning of the chart up to the current bar.",
          "args": [
            {
              "name": "source",
              "desc": "Source used for the calculation.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "open",
                "high",
                "low",
                "close",
                "volume"
              ]
            }
          ],
          "syntax": "ta.max(source) → series float",
          "remarks": "[na](#var_na) occurrences of `source` are ignored.",
          "returnedType": "float",
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "ta.min",
          "desc": "Returns the all-time low value of `source` from the beginning of the chart up to the current bar.",
          "args": [
            {
              "name": "source",
              "desc": "Source used for the calculation.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "open",
                "high",
                "low",
                "close",
                "volume"
              ]
            }
          ],
          "syntax": "ta.min(source) → series float",
          "remarks": "[na](#var_na) occurrences of `source` are ignored.",
          "returnedType": "float",
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "ta.mode",
          "desc": "Returns the [mode](https://en.wikipedia.org/wiki/Mode_(statistics)) of the series.  \nIf there are several values with the same frequency, it returns the smallest value.",
          "args": [
            {
              "name": "source",
              "desc": "Series of values to process.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            },
            {
              "name": "length",
              "desc": "Number of bars (length).",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "14",
                "20",
                "50",
                "100"
              ]
            }
          ],
          "syntax": "ta.mode(source, length) → series float|int",
          "remarks": "`na` values in the `source` series are ignored; the function calculates on the `length` quantity of non-`na` values.",
          "returns": "The most frequently occurring value from the `source`. If none exists, returns the smallest value instead.",
          "returnedType": [
            "float",
            "int"
          ],
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float",
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "ta.range",
          "desc": "Returns the difference between the min and max values in a series.",
          "args": [
            {
              "name": "source",
              "desc": "Series of values to process.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "open",
                "high",
                "low",
                "close",
                "hl2"
              ]
            },
            {
              "name": "length",
              "desc": "Number of bars (length).",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                14,
                20,
                50,
                100,
                200
              ]
            }
          ],
          "syntax": "ta.range(source, length) → series float|int",
          "remarks": "`na` values in the `source` series are ignored; the function calculates on the `length` quantity of non-`na` values.",
          "returns": "The difference between the min and max values in the series.",
          "returnedType": [
            "float",
            "int"
          ],
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float",
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "math.todegrees",
          "desc": "Returns an approximately equivalent angle in degrees from an angle measured in radians.",
          "args": [
            {
              "name": "radians",
              "desc": "Angle in radians.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "math.todegrees(radians) → series float",
          "returns": "The angle value in degrees.",
          "returnedType": "float",
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "math.toradians",
          "desc": "Returns an approximately equivalent angle in radians from an angle measured in degrees.",
          "args": [
            {
              "name": "degrees",
              "desc": "Angle in degrees.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "0",
                "90",
                "180",
                "270",
                "360"
              ]
            }
          ],
          "syntax": "math.toradians(degrees) → series float",
          "returns": "The angle value in radians.",
          "returnedType": "float",
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "math.random",
          "desc": "Returns a pseudo-random value. The function will generate a different sequence of values for each script execution. Using the same value for the optional seed argument will produce a repeatable sequence.",
          "args": [
            {
              "name": "min",
              "desc": "The lower bound of the range of random values. The value is not included in the range.  \nThe default is 0.",
              "default": "0",
              "required": false,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            },
            {
              "name": "max",
              "desc": "The upper bound of the range of random values. The value is not included in the range.  \nThe default is 1.",
              "default": 1,
              "required": false,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            },
            {
              "name": "seed",
              "desc": "Optional argument. When the same seed is used, allows successive calls to the function to produce a repeatable set of values.",
              "default": null,
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "0"
              ]
            }
          ],
          "syntax": "math.random(min, max, seed) → series float",
          "returns": "A random value.",
          "returnedType": "float",
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "math.sum",
          "desc": "The sum function returns the sliding sum of last y values of x.",
          "args": [
            {
              "name": "source",
              "desc": "Series of values to process.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "open",
                "high",
                "low",
                "close",
                "volume"
              ]
            },
            {
              "name": "length",
              "desc": "Number of bars (length).",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "14",
                "20",
                "50",
                "100",
                "200"
              ]
            }
          ],
          "syntax": "math.sum(source, length) → series float",
          "remarks": "`na` values in the `source` series are ignored; the function calculates on the `length` quantity of non-`na` values.",
          "returns": "Sum of `source` for `length` bars back.",
          "seeAlso": [
            "[ta.cum](#fun_ta.cum)",
            "[for](#kw_for)"
          ],
          "returnedType": "float",
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "ta.sma",
          "desc": "The sma function returns the moving average, that is the sum of last y values of x, divided by y.",
          "args": [
            {
              "name": "source",
              "desc": "Series of values to process.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "open",
                "high",
                "low",
                "close",
                "volume"
              ]
            },
            {
              "name": "length",
              "desc": "Number of bars (length).",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "9",
                "14",
                "20",
                "50",
                "200"
              ]
            }
          ],
          "syntax": "ta.sma(source, length) → series float",
          "remarks": "`na` values in the `source` series are ignored.",
          "returns": "Simple moving average of `source` for `length` bars back.",
          "seeAlso": [
            "[ta.ema](#fun_ta.ema)",
            "[ta.rma](#fun_ta.rma)",
            "[ta.wma](#fun_ta.wma)",
            "[ta.vwma](#fun_ta.vwma)",
            "[ta.swma](#fun_ta.swma)",
            "[ta.alma](#fun_ta.alma)"
          ],
          "examples": "//@version=5\nindicator(\"ta.sma\")\nplot(ta.sma(close, 15))\n\n// same on pine, but much less efficient\npine_sma(x, y) =>\n    sum = 0.0\n    for i = 0 to y - 1\n        sum := sum + x[i] / y\n    sum\nplot(pine_sma(close, 15))",
          "returnedType": "float",
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "ta.hma",
          "desc": "The hma function returns the Hull Moving Average.",
          "args": [
            {
              "name": "source",
              "desc": "Series of values to process.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "open",
                "high",
                "low",
                "close",
                "volume"
              ]
            },
            {
              "name": "length",
              "desc": "Number of bars.",
              "default": null,
              "required": true,
              "displayType": "simple int",
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "9",
                "14",
                "20",
                "50",
                "200"
              ]
            }
          ],
          "syntax": "ta.hma(source, length) → series float",
          "remarks": "`na` values in the `source` series are ignored.",
          "returns": "Hull moving average of 'source' for 'length' bars back.",
          "seeAlso": [
            "[ta.ema](#fun_ta.ema)",
            "[ta.rma](#fun_ta.rma)",
            "[ta.wma](#fun_ta.wma)",
            "[ta.vwma](#fun_ta.vwma)",
            "[ta.sma](#fun_ta.sma)"
          ],
          "examples": "//@version=5\nindicator(\"Hull Moving Average\")\nsrc = input(defval=close, title=\"Source\")\nlength = input(defval=9, title=\"Length\")\nhmaBuildIn = ta.hma(src, length)\nplot(hmaBuildIn, title=\"Hull MA\", color=#674EA7)",
          "returnedType": "float",
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "ta.ema",
          "desc": "The ema function returns the exponentially weighted moving average. In ema weighting factors decrease exponentially. It calculates by using a formula: EMA = alpha * source + (1 - alpha) * EMA[1], where alpha = 2 / (length + 1).",
          "args": [
            {
              "name": "source",
              "desc": "Series of values to process.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "open",
                "high",
                "low",
                "close",
                "volume"
              ]
            },
            {
              "name": "length",
              "desc": "Number of bars (length).",
              "default": null,
              "required": true,
              "displayType": "simple int",
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "5",
                "10",
                "14",
                "20",
                "50"
              ]
            }
          ],
          "syntax": "ta.ema(source, length) → series float",
          "remarks": "Please note that using this variable/function can cause [indicator repainting](https://www.tradingview.com/pine-script-docs/en/v5/concepts/Repainting.html).\n`na` values in the `source` series are ignored; the function calculates on the `length` quantity of non-`na` values.",
          "returns": "Exponential moving average of `source` with alpha = 2 / (length + 1).",
          "seeAlso": [
            "[ta.sma](#fun_ta.sma)",
            "[ta.rma](#fun_ta.rma)",
            "[ta.wma](#fun_ta.wma)",
            "[ta.vwma](#fun_ta.vwma)",
            "[ta.swma](#fun_ta.swma)",
            "[ta.alma](#fun_ta.alma)"
          ],
          "examples": "//@version=5\nindicator(\"ta.ema\")\nplot(ta.ema(close, 15))\n\n//the same on pine\npine_ema(src, length) =>\n    alpha = 2 / (length + 1)\n    sum = 0.0\n    sum := na(sum[1]) ? src : alpha * src + (1 - alpha) * nz(sum[1])\nplot(pine_ema(close, 15))",
          "returnedType": "float",
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "ta.wma",
          "desc": "The wma function returns weighted moving average of `source` for `length` bars back.  \nIn wma weighting factors decrease in arithmetical progression.",
          "args": [
            {
              "name": "source",
              "desc": "Series of values to process.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "open",
                "high",
                "low",
                "close",
                "volume"
              ]
            },
            {
              "name": "length",
              "desc": "Number of bars (length).",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "9",
                "14",
                "20",
                "50",
                "200"
              ]
            }
          ],
          "syntax": "ta.wma(source, length) → series float",
          "remarks": "`na` values in the `source` series are ignored.",
          "returns": "Weighted moving average of `source` for `length` bars back.",
          "seeAlso": [
            "[ta.sma](#fun_ta.sma)",
            "[ta.ema](#fun_ta.ema)",
            "[ta.rma](#fun_ta.rma)",
            "[ta.vwma](#fun_ta.vwma)",
            "[ta.swma](#fun_ta.swma)",
            "[ta.alma](#fun_ta.alma)"
          ],
          "examples": "//@version=5\nindicator(\"ta.wma\")\nplot(ta.wma(close, 15))\n\n// same on pine, but much less efficient\npine_wma(x, y) =>\n    norm = 0.0\n    sum = 0.0\n    for i = 0 to y - 1\n        weight = (y - i) * y\n        norm := norm + weight\n        sum := sum + x[i] * weight\n    sum / norm\nplot(pine_wma(close, 15))",
          "returnedType": "float",
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "ta.vwma",
          "desc": "The vwma function returns volume-weighted moving average of `source` for `length` bars back.  \nIt is the same as: sma(source * volume, length) / sma(volume, length).",
          "args": [
            {
              "name": "source",
              "desc": "Series of values to process.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            },
            {
              "name": "length",
              "desc": "Number of bars (length).",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            }
          ],
          "syntax": "ta.vwma(source, length) → series float",
          "remarks": "`na` values in the `source` series are ignored.",
          "returns": "Volume-weighted moving average of `source` for `length` bars back.",
          "seeAlso": [
            "[ta.sma](#fun_ta.sma)",
            "[ta.ema](#fun_ta.ema)",
            "[ta.rma](#fun_ta.rma)",
            "[ta.wma](#fun_ta.wma)",
            "[ta.swma](#fun_ta.swma)",
            "[ta.alma](#fun_ta.alma)"
          ],
          "examples": "//@version=5\nindicator(\"ta.vwma\")\nplot(ta.vwma(close, 15))\n\n// same on pine, but less efficient\npine_vwma(x, y) =>\n    ta.sma(x * volume, y) / ta.sma(volume, y)\nplot(pine_vwma(close, 15))",
          "returnedType": "float",
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "ta.supertrend",
          "desc": "The Supertrend Indicator. The Supertrend is a trend following indicator.",
          "args": [
            {
              "name": "factor",
              "desc": "The multiplier by which the ATR will get multiplied.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            },
            {
              "name": "atrPeriod",
              "desc": "Length of ATR.",
              "default": null,
              "required": true,
              "displayType": "simple int",
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "5",
                "10",
                "14",
                "20",
                "50"
              ]
            }
          ],
          "syntax": "ta.supertrend(factor, atrPeriod) → [series float, series float]",
          "returns": "[Tuple](https://www.tradingview.com/pine-script-docs/en/v5/language/Type_system.html#tuples) of two supertrend series: supertrend line and direction of trend. Possible values are 1 (down direction) and -1 (up direction).",
          "seeAlso": [
            "[ta.macd](#fun_ta.macd)"
          ],
          "examples": "//@version=5\nindicator(\"Pine Script™ Supertrend\")\n\n[supertrend, direction] = ta.supertrend(3, 10)\nplot(direction < 0 ? supertrend : na, \"Up direction\", color = color.green, style=plot.style_linebr)\nplot(direction > 0 ? supertrend : na, \"Down direction\", color = color.red, style=plot.style_linebr)\n\n// The same on Pine Script™\npine_supertrend(factor, atrPeriod) =>\n\tsrc = hl2\n\tatr = ta.atr(atrPeriod)\n\tupperBand = src + factor * atr\n\tlowerBand = src - factor * atr\n\tprevLowerBand = nz(lowerBand[1])\n\tprevUpperBand = nz(upperBand[1])\n\n\tlowerBand := lowerBand > prevLowerBand or close[1] < prevLowerBand ? lowerBand : prevLowerBand\n\tupperBand := upperBand < prevUpperBand or close[1] > prevUpperBand ? upperBand : prevUpperBand\n\tint direction = na\n\tfloat superTrend = na\n\tprevSuperTrend = superTrend[1]\n\tif na(atr[1])\n\t\tdirection := 1\n\telse if prevSuperTrend == prevUpperBand\n\t\tdirection := close > upperBand ? -1 : 1\n\telse\n\t\tdirection := close < lowerBand ? 1 : -1\n\tsuperTrend := direction == -1 ? lowerBand : upperBand\n\t[superTrend, direction]\n\n[pineSupertrend, pineDirection] = pine_supertrend(3, 10)\nplot(pineDirection < 0 ? pineSupertrend : na, \"Up direction\", color = color.green, style=plot.style_linebr)\nplot(pineDirection > 0 ? pineSupertrend : na, \"Down direction\", color = color.red, style=plot.style_linebr)",
          "returnedType": "[float, float]",
          "returnedTypes": [
            "[series float, series float]"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "ta.macd",
          "desc": "MACD (moving average convergence/divergence). It is supposed to reveal changes in the strength, direction, momentum, and duration of a trend in a stock\\`s price.",
          "args": [
            {
              "name": "source",
              "desc": "Series of values to process.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "close",
                "open",
                "high",
                "low",
                "volume"
              ]
            },
            {
              "name": "fastlen",
              "desc": "Fast Length parameter.",
              "default": null,
              "required": true,
              "displayType": "simple int",
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                12,
                9,
                26,
                14,
                7
              ]
            },
            {
              "name": "slowlen",
              "desc": "Slow Length parameter.",
              "default": null,
              "required": true,
              "displayType": "simple int",
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "26",
                "20",
                "50",
                "100",
                "200"
              ]
            },
            {
              "name": "siglen",
              "desc": "Signal Length parameter.",
              "default": null,
              "required": true,
              "displayType": "simple int",
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "9",
                "7",
                "14",
                "21",
                "5"
              ]
            }
          ],
          "syntax": "ta.macd(source, fastlen, slowlen, siglen) → [series float, series float, series float]",
          "remarks": "`na` values in the `source` series are ignored; the function calculates on the `length` quantity of non-`na` values.",
          "returns": "[Tuple](https://www.tradingview.com/pine-script-docs/en/v5/language/Type_system.html#tuples) of three MACD series: MACD line, signal line and histogram line.",
          "seeAlso": [
            "[ta.sma](#fun_ta.sma)",
            "[ta.ema](#fun_ta.ema)"
          ],
          "returnedType": "[float, float, float]",
          "detailedDesc": [
            {
              "desc": "",
              "examples": "//@version=5\nindicator(\"MACD\")\n[macdLine, signalLine, histLine] = ta.macd(close, 12, 26, 9)\nplot(macdLine, color=color.blue)\nplot(signalLine, color=color.orange)\nplot(histLine, color=color.red, style=plot.style_histogram)"
            },
            {
              "desc": "If you need only one value, use placeholders '_' like this:",
              "examples": "//@version=5\nindicator(\"MACD\")\n[_, signalLine, _] = ta.macd(close, 12, 26, 9)\nplot(signalLine, color=color.orange)"
            }
          ],
          "returnedTypes": [
            "[series float, series float, series float]"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "ta.lowest",
          "desc": "Lowest value for a given number of bars back.",
          "args": [
            {
              "name": "source",
              "desc": "Series of values to process.",
              "default": "low",
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "open",
                "high",
                "low",
                "close",
                "volume"
              ]
            },
            {
              "name": "length",
              "desc": "Number of bars (length).",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "14",
                "20",
                "50",
                "100",
                "200"
              ]
            }
          ],
          "syntax": "ta.lowest(source, length) → series float\nta.lowest(length) → series float",
          "remarks": "Two args version: `source` is a series and `length` is the number of bars back.\nOne arg version: `length` is the number of bars back.  \nAlgorithm uses low as a `source` series.\n`na` values in the `source` series are ignored.",
          "returns": "Lowest value in the series.",
          "seeAlso": [
            "[ta.highest](#fun_ta.highest)",
            "[ta.lowestbars](#fun_ta.lowestbars)",
            "[ta.highestbars](#fun_ta.highestbars)",
            "[ta.valuewhen](#fun_ta.valuewhen)",
            "[ta.barssince](#fun_ta.barssince)"
          ],
          "returnedType": "float",
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "ta.highest",
          "desc": "Highest value for a given number of bars back.",
          "args": [
            {
              "name": "source",
              "desc": "Series of values to process.",
              "default": "high",
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "open",
                "high",
                "low",
                "close",
                "volume"
              ]
            },
            {
              "name": "length",
              "desc": "Number of bars (length).",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "14",
                "20",
                "50",
                "200"
              ]
            }
          ],
          "syntax": "ta.highest(source, length) → series float",
          "remarks": "Two args version: `source` is a series and `length` is the number of bars back.\nOne arg version: `length` is the number of bars back.  \nAlgorithm uses high as a `source` series.\n`na` values in the `source` series are ignored.",
          "returns": "Highest value in the series.",
          "seeAlso": [
            "[ta.lowest](#fun_ta.lowest)",
            "[ta.lowestbars](#fun_ta.lowestbars)",
            "[ta.highestbars](#fun_ta.highestbars)",
            "[ta.valuewhen](#fun_ta.valuewhen)",
            "[ta.barssince](#fun_ta.barssince)"
          ],
          "returnedType": "float",
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "ta.lowestbars",
          "desc": "Lowest value offset for a given number of bars back.",
          "args": [
            {
              "name": "source",
              "desc": "Series of values to process.",
              "default": "low",
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "open",
                "high",
                "low",
                "close",
                "volume"
              ]
            },
            {
              "name": "length",
              "desc": "Number of bars back.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "14",
                "20",
                "50",
                "100",
                "200"
              ]
            }
          ],
          "syntax": "ta.lowestbars(source, length) → series int\nta.lowestbars(length) → series int",
          "remarks": "Two args version: `source` is a series and `length` is the number of bars back.\nOne arg version: `length` is the number of bars back.  \nAlgorithm uses low as a `source` series.\n`na` values in the `source` series are ignored.",
          "returns": "Offset to the lowest bar.",
          "seeAlso": [
            "[ta.lowest](#fun_ta.lowest)",
            "[ta.highest](#fun_ta.highest)",
            "[ta.highestbars](#fun_ta.highestbars)",
            "[ta.barssince](#fun_ta.barssince)",
            "[ta.valuewhen](#fun_ta.valuewhen)"
          ],
          "returnedType": "int",
          "returnedTypes": [
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "ta.highestbars",
          "desc": "Highest value offset for a given number of bars back.",
          "args": [
            {
              "name": "source",
              "desc": "Series of values to process.",
              "default": "high",
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "open",
                "high",
                "low",
                "close",
                "hl2"
              ]
            },
            {
              "name": "length",
              "desc": "Number of bars (length).",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "10",
                "20",
                "50",
                "100",
                "200"
              ]
            }
          ],
          "syntax": "ta.highestbars(source, length) → series int\nta.highestbars(length) → series int",
          "remarks": "Two args version: `source` is a series and `length` is the number of bars back.\nOne arg version: `length` is the number of bars back.  \nAlgorithm uses high as a `source` series.\n`na` values in the `source` series are ignored.",
          "returns": "Offset to the highest bar.",
          "seeAlso": [
            "[ta.lowest](#fun_ta.lowest)",
            "[ta.highest](#fun_ta.highest)",
            "[ta.lowestbars](#fun_ta.lowestbars)",
            "[ta.barssince](#fun_ta.barssince)",
            "[ta.valuewhen](#fun_ta.valuewhen)"
          ],
          "returnedType": "int",
          "returnedTypes": [
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "ta.barssince",
          "desc": "Counts the number of bars since the last time the condition was true.",
          "args": [
            {
              "name": "condition",
              "desc": "The condition to search for.",
              "default": null,
              "required": true,
              "displayType": "series bool",
              "allowedTypeIDs": [
                "series bool",
                "simple bool",
                "input bool",
                "const bool"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "ta.barssince(condition) → series int",
          "remarks": [
            "If the condition has never been met prior to the current bar, the function returns na.",
            "Please note that using this variable/function can cause [indicator repainting](https://www.tradingview.com/pine-script-docs/en/v5/concepts/Repainting.html)."
          ],
          "returns": "Number of bars since condition was true.",
          "seeAlso": [
            "[ta.lowestbars](#fun_ta.lowestbars)",
            "[ta.highestbars](#fun_ta.highestbars)",
            "[ta.valuewhen](#fun_ta.valuewhen)",
            "[ta.highest](#fun_ta.highest)",
            "[ta.lowest](#fun_ta.lowest)"
          ],
          "examples": "//@version=5\nindicator(\"ta.barssince\")\n// get number of bars since last color.green bar\nplot(ta.barssince(close >= open))",
          "returnedType": "int",
          "returnedTypes": [
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "ta.valuewhen",
          "desc": "Returns the value of the `source` series on the bar where the `condition` was true on the nth most recent occurrence.",
          "args": [
            {
              "name": "condition",
              "desc": "The condition to search for.",
              "default": null,
              "required": true,
              "displayType": "series bool",
              "allowedTypeIDs": [
                "series bool",
                "simple bool",
                "input bool",
                "const bool"
              ],
              "possibleValues": null
            },
            {
              "name": "source",
              "desc": "The value to be returned from the bar where the condition is met.",
              "default": null,
              "required": true,
              "displayType": "series int|float|bool|color",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float",
                "series bool",
                "simple bool",
                "input bool",
                "const bool",
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "possibleValues": null
            },
            {
              "name": "occurrence",
              "desc": "The occurrence of the condition. The numbering starts from 0 and goes back in time, so '0' is the most recent occurrence of `condition`, '1' is the second most recent and so forth.  \nMust be an integer >= 0.",
              "default": null,
              "required": true,
              "displayType": "simple int",
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "0",
                "1",
                "2",
                "3",
                "4"
              ]
            }
          ],
          "syntax": "ta.valuewhen(condition, source, occurrence) → series float|int|bool|color",
          "remarks": "This function requires execution on every bar. It is not recommended to use it inside a [for](#op_for) or [while](#op_while) loop structure, where its behavior can be unexpected.  \nPlease note that using this function can cause [indicator repainting](https://www.tradingview.com/pine-script-docs/en/v5/concepts/Repainting.html).",
          "seeAlso": [
            "[ta.lowestbars](#fun_ta.lowestbars)",
            "[ta.highestbars](#fun_ta.highestbars)",
            "[ta.barssince](#fun_ta.barssince)",
            "[ta.highest](#fun_ta.highest)",
            "[ta.lowest](#fun_ta.lowest)"
          ],
          "examples": "//@version=5\nindicator(\"ta.valuewhen\")\nslow = ta.sma(close, 7)\nfast = ta.sma(close, 14)\n// Get value of `close` on second most recent cross\nplot(ta.valuewhen(ta.cross(slow, fast), close, 1))",
          "returnedType": [
            "float",
            "color",
            "int",
            "bool"
          ],
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float",
            "series int",
            "simple int",
            "input int",
            "const int",
            "series bool",
            "simple bool",
            "input bool",
            "const bool",
            "series color",
            "simple color",
            "input color",
            "const color"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "ta.falling",
          "desc": "Test if the `source` series is now falling for `length` bars long.",
          "args": [
            {
              "name": "source",
              "desc": "Series of values to process.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "open",
                "high",
                "low",
                "close",
                "volume"
              ]
            },
            {
              "name": "length",
              "desc": "Number of bars (length).",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "5",
                "10",
                "14",
                "20",
                "50"
              ]
            }
          ],
          "syntax": "ta.falling(source, length) → series bool",
          "remarks": "`na` values in the `source` series are ignored; the function calculates on the `length` quantity of non-`na` values.",
          "returns": "true if current `source` value is less than any previous `source` value for `length` bars back, false otherwise.",
          "seeAlso": [
            "[ta.rising](#fun_ta.rising)"
          ],
          "returnedType": "bool",
          "returnedTypes": [
            "series bool",
            "simple bool",
            "input bool",
            "const bool"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "ta.rising",
          "desc": "Test if the `source` series is now rising for `length` bars long.",
          "args": [
            {
              "name": "source",
              "desc": "Series of values to process.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "open",
                "high",
                "low",
                "close",
                "hl2"
              ]
            },
            {
              "name": "length",
              "desc": "Number of bars (length).",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            }
          ],
          "syntax": "ta.rising(source, length) → series bool",
          "remarks": "`na` values in the `source` series are ignored.",
          "returns": "true if current `source` is greater than any previous `source` for `length` bars back, false otherwise.",
          "seeAlso": [
            "[ta.falling](#fun_ta.falling)"
          ],
          "returnedType": "bool",
          "returnedTypes": [
            "series bool",
            "simple bool",
            "input bool",
            "const bool"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "ta.roc",
          "desc": "Calculates the percentage of change (rate of change) between the current value of `source` and its value `length` bars ago.\nIt is calculated by the formula: 100 * change(src, length) / src[length].",
          "args": [
            {
              "name": "source",
              "desc": "Series of values to process.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "open",
                "high",
                "low",
                "close",
                "hl2"
              ]
            },
            {
              "name": "length",
              "desc": "Number of bars (length).",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                1,
                14,
                20,
                50,
                100
              ]
            }
          ],
          "syntax": "ta.roc(source, length) → series float",
          "remarks": "`na` values in the `source` series are included in calculations and will produce an `na` result.",
          "returns": "The rate of change of `source` for `length` bars back.",
          "returnedType": "float",
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "ta.cci",
          "desc": "The CCI (commodity channel index) is calculated as the difference between the typical price of a commodity and its simple moving average, divided by the mean absolute deviation of the typical price. The index is scaled by an inverse factor of 0.015 to provide more readable numbers.",
          "args": [
            {
              "name": "source",
              "desc": "Series of values to process.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "close",
                "open",
                "high",
                "low",
                "hl2"
              ]
            },
            {
              "name": "length",
              "desc": "Number of bars (length).",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                14,
                20,
                50,
                100,
                200
              ]
            }
          ],
          "syntax": "ta.cci(source, length) → series float",
          "remarks": "`na` values in the `source` series are ignored.",
          "returns": "Commodity channel index of source for length bars back.",
          "returnedType": "float",
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "ta.variance",
          "desc": "Variance is the expectation of the squared deviation of a series from its mean ([ta.sma](#fun_ta.sma)), and it informally measures how far a set of numbers are spread out from their mean.",
          "args": [
            {
              "name": "source",
              "desc": "Series of values to process.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "open",
                "high",
                "low",
                "close",
                "volume"
              ]
            },
            {
              "name": "length",
              "desc": "Number of bars (length).",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                14,
                20,
                50,
                100,
                200
              ]
            },
            {
              "name": "biased",
              "desc": "Determines which estimate should be used. Optional. The default is true.",
              "default": "true",
              "required": false,
              "displayType": "series bool",
              "allowedTypeIDs": [
                "series bool",
                "simple bool",
                "input bool",
                "const bool"
              ],
              "possibleValues": [
                "true",
                "false"
              ]
            }
          ],
          "syntax": "ta.variance(source, length, biased) → series float",
          "remarks": "If `biased` is true, function will calculate using a biased estimate of the entire population, if false - unbiased estimate of a sample.\n`na` values in the `source` series are ignored; the function calculates on the `length` quantity of non-`na` values.",
          "returns": "Variance of `source` for `length` bars back.",
          "seeAlso": [
            "[ta.dev](#fun_ta.dev)",
            "[ta.stdev](#fun_ta.stdev)"
          ],
          "returnedType": "float",
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "ta.dev",
          "desc": "Measure of difference between the series and it\\`s [ta.sma](#fun_ta.sma)",
          "args": [
            {
              "name": "source",
              "desc": "Series of values to process.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "close",
                "open",
                "high",
                "low",
                "volume"
              ]
            },
            {
              "name": "length",
              "desc": "Number of bars (length).",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "5",
                "10",
                "14",
                "20",
                "50"
              ]
            }
          ],
          "syntax": "ta.dev(source, length) → series float",
          "remarks": "`na` values in the `source` series are ignored.",
          "returns": "Deviation of `source` for `length` bars back.",
          "seeAlso": [
            "[ta.variance](#fun_ta.variance)",
            "[ta.stdev](#fun_ta.stdev)"
          ],
          "examples": "//@version=5\nindicator(\"ta.dev\")\nplot(ta.dev(close, 10))\n\n// the same on pine\npine_dev(source, length) =>\n    mean = ta.sma(source, length)\n    sum = 0.0\n    for i = 0 to length - 1\n        val = source[i]\n        sum := sum + math.abs(val - mean)\n    dev = sum/length\nplot(pine_dev(close, 10))",
          "returnedType": "float",
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "ta.stdev",
          "args": [
            {
              "name": "source",
              "desc": "Series of values to process.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "open",
                "high",
                "low",
                "close",
                "volume"
              ]
            },
            {
              "name": "length",
              "desc": "Number of bars (length).",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "5",
                "10",
                "14",
                "20",
                "50"
              ]
            },
            {
              "name": "biased",
              "desc": "Determines which estimate should be used. Optional. The default is true.",
              "default": "true",
              "required": false,
              "displayType": "series bool",
              "allowedTypeIDs": [
                "series bool",
                "simple bool",
                "input bool",
                "const bool"
              ],
              "possibleValues": [
                "true",
                "false"
              ]
            }
          ],
          "syntax": "ta.stdev(source, length, biased) → series float",
          "remarks": "If `biased` is true, function will calculate using a biased estimate of the entire population, if false - unbiased estimate of a sample.\n`na` values in the `source` series are ignored; the function calculates on the `length` quantity of non-`na` values.",
          "returns": "Standard deviation.",
          "seeAlso": [
            "[ta.dev](#fun_ta.dev)",
            "[ta.variance](#fun_ta.variance)"
          ],
          "examples": "//@version=5\nindicator(\"ta.stdev\")\nplot(ta.stdev(close, 5))\n\n//the same on pine\nisZero(val, eps) → math.abs(val) <= eps\n\nSUM(fst, snd) =>\n    EPS = 1e-10\n    res = fst + snd\n    if isZero(res, EPS)\n        res := 0\n    else\n        if not isZero(res, 1e-4)\n            res := res\n        else\n            15\n\npine_stdev(src, length) =>\n    avg = ta.sma(src, length)\n    sumOfSquareDeviations = 0.0\n    for i = 0 to length - 1\n        sum = SUM(src[i], -avg)\n        sumOfSquareDeviations := sumOfSquareDeviations + sum * sum\n\n    stdev = math.sqrt(sumOfSquareDeviations / length)\nplot(pine_stdev(close, 5))",
          "returnedType": "float",
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "ta.percentrank",
          "desc": "Percent rank is the percents of how many previous values was less than or equal to the current value of given series.",
          "args": [
            {
              "name": "source",
              "desc": "Series of values to process.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "close",
                "open",
                "high",
                "low",
                "volume"
              ]
            },
            {
              "name": "length",
              "desc": "Number of bars (length).",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                14,
                20,
                50,
                100,
                200
              ]
            }
          ],
          "syntax": "ta.percentrank(source, length) → series float",
          "remarks": "`na` values in the `source` series are included in calculations and will produce an `na` result.",
          "returns": "Percent rank of `source` for `length` bars back.",
          "returnedType": "float",
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "ta.rma",
          "desc": "Moving average used in RSI. It is the exponentially weighted moving average with alpha = 1 / length.",
          "args": [
            {
              "name": "source",
              "desc": "Series of values to process.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "open",
                "high",
                "low",
                "close",
                "volume"
              ]
            },
            {
              "name": "length",
              "desc": "Number of bars (length).",
              "default": null,
              "required": true,
              "displayType": "simple int",
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                9,
                14,
                20,
                50,
                200
              ]
            }
          ],
          "syntax": "ta.rma(source, length) → series float",
          "remarks": "`na` values in the `source` series are ignored; the function calculates on the `length` quantity of non-`na` values.",
          "returns": "Exponential moving average of `source` with alpha = 1 / `length`.",
          "seeAlso": [
            "[ta.sma](#fun_ta.sma)",
            "[ta.ema](#fun_ta.ema)",
            "[ta.wma](#fun_ta.wma)",
            "[ta.vwma](#fun_ta.vwma)",
            "[ta.swma](#fun_ta.swma)",
            "[ta.alma](#fun_ta.alma)",
            "[ta.rsi](#fun_ta.rsi)"
          ],
          "examples": "//@version=5\nindicator(\"ta.rma\")\nplot(ta.rma(close, 15))\n\n//the same on pine\npine_rma(src, length) =>\n\talpha = 1/length\n\tsum = 0.0\n\tsum := na(sum[1]) ? ta.sma(src, length) : alpha * src + (1 - alpha) * nz(sum[1])\nplot(pine_rma(close, 15))",
          "returnedType": "float",
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "ta.rsi",
          "desc": "Relative strength index. It is calculated using the `ta.rma()` of upward and downward changes of `source` over the last `length` bars.",
          "args": [
            {
              "name": "source",
              "desc": "Series of values to process.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "open",
                "high",
                "low",
                "close",
                "volume"
              ]
            },
            {
              "name": "length",
              "desc": "Number of bars (length).",
              "default": null,
              "required": true,
              "displayType": "simple int",
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                7,
                14,
                21,
                28,
                50
              ]
            }
          ],
          "syntax": "ta.rsi(source, length) → series float",
          "remarks": "`na` values in the `source` series are ignored; the function calculates on the `length` quantity of non-`na` values.",
          "returns": "Relative strength index.",
          "seeAlso": [
            "[ta.rma](#fun_ta.rma)"
          ],
          "examples": "//@version=5\nindicator(\"ta.rsi\")\nplot(ta.rsi(close, 7))\n\n// same on pine, but less efficient\npine_rsi(x, y) → \n    u = math.max(x - x[1], 0) // upward ta.change\n    d = math.max(x[1] - x, 0) // downward ta.change\n    rs = ta.rma(u, y) / ta.rma(d, y)\n    res = 100 - 100 / (1 + rs)\n    res\n\nplot(pine_rsi(close, 7))",
          "returnedType": "float",
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "name": "timeframe.from_seconds",
          "desc": "Converts a number of seconds into a valid timeframe string.  \n1m = 60, 5m = 300, 15m = 900, 30m = 1800, 1h = 3600, 4h = 14400, 1D = 86400",
          "args": [
            {
              "name": "seconds",
              "desc": "The number of seconds in the timeframe.",
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                60,
                300,
                900,
                1800,
                3600,
                14400,
                86400
              ]
            }
          ],
          "kind": "Built-in Function",
          "syntax": "timeframe.from_seconds(seconds) → series string",
          "returns": "A timeframe string compliant with [timeframe string specifications](https://www.tradingview.com/pine-script-docs/en/v5/concepts/Timeframes.html#timeframe-string-specifications).",
          "remarks": [
            "If no valid timeframe exists for the quantity of seconds supplied, the next higher valid timeframe will be returned. Accordingly, one second or less will return '1S', 2-5 seconds will return '5S', and 604,799 seconds (one second less than 7 days) will return '7D'.",
            "If the seconds exactly represent two or more valid timeframes, the one with the larger base unit will be used. Thus 604,800 seconds (7 days) returns '1W', not '7D'.",
            "All values above 31,622,400 (366 days) return '12M'."
          ],
          "seeAlso": [
            "[timeframe.in_seconds](#fun_timeframe.in_seconds)",
            "[request.security](#var_request.security)",
            "[request.security_lower_tf](#var_request.security_lower_tf)"
          ],
          "examples": "//@version=5\nindicator('HTF Close', '', true)\nint chartTf = timeframe.in_seconds()\nstring tfTimes5 = timeframe.from_seconds(chartTf * 5)\nfloat htfClose = request.security(syminfo.tickerid, tfTimes5, close)\nplot(htfClose)",
          "returnedTypes": "series string"
        },
        {
          "kind": "Built-in Function",
          "name": "timeframe.in_seconds",
          "desc": "Converts the timeframe passed to the `timeframe` argument into seconds.",
          "args": [
            {
              "name": "timeframe",
              "desc": "Timeframe. Optional. The default is [timeframe.period](#var_timeframe.period).",
              "default": "timeframe.period",
              "required": false,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "isString": true,
              "possibleValues": [
                "\"\"",
                "1",
                "5",
                "15",
                "30",
                "60",
                "240",
                "D",
                "W",
                "M"
              ]
            }
          ],
          "syntax": "timeframe.in_seconds(timeframe) → series int",
          "remarks": "For the `timeframe` >= '1M' function calculates number of seconds based on 30.4167 (365/12) days in month.",
          "returns": "An int representation of the number of seconds in one bar of a `timeframe`.",
          "seeAlso": [
            "[input.timeframe](#fun_input.timeframe)",
            "[timeframe.period](#var_timeframe.period)"
          ],
          "examples": "//@version=5\nindicator(\"timeframe_in_seconds\")\n\n// Get chart timeframe:\ni_tf = input.timeframe(\"1D\")\n\n// Convert timeframe to the int value (number of seconds in 1 Day):\ntf = timeframe.in_seconds(i_tf)\n\nplot(tf)",
          "returnedType": "int",
          "returnedTypes": [
            "simple int",
            "input int",
            "const int",
            "series int"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "ta.dmi",
          "desc": "The dmi function returns the directional movement index.",
          "args": [
            {
              "name": "diLength",
              "desc": "DI Period.",
              "default": null,
              "required": true,
              "displayType": "simple int",
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                14,
                20,
                50,
                100,
                200
              ]
            },
            {
              "name": "adxSmoothing",
              "desc": "ADX Smoothing Period.",
              "default": null,
              "required": true,
              "displayType": "simple int",
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                14,
                20,
                50,
                100,
                200
              ]
            }
          ],
          "syntax": "ta.dmi(diLength, adxSmoothing) → [series float, series float, series float]",
          "returns": "[Tuple](https://www.tradingview.com/pine-script-docs/en/v5/language/Type_system.html#tuples) of three DMI series: Positive Directional Movement (+DI), Negative Directional Movement (-DI) and Average Directional Movement Index (ADX).",
          "seeAlso": [
            "[ta.rsi](#fun_ta.rsi)",
            "[ta.tsi](#fun_ta.tsi)",
            "[ta.mfi](#fun_ta.mfi)"
          ],
          "examples": "//@version=5\nindicator(title=\"Directional Movement Index\", shorttitle=\"DMI\", format=format.price, precision=4)\nlen = input.int(17, minval=1, title=\"DI Length\")\nlensig = input.int(14, title=\"ADX Smoothing\", minval=1, maxval=50)\n[diplus, diminus, adx] = ta.dmi(len, lensig)\nplot(adx, color=color.red, title=\"ADX\")\nplot(diplus, color=color.blue, title=\"+DI\")\nplot(diminus, color=color.orange, title=\"-DI\")",
          "returnedType": "[float, float, float]",
          "returnedTypes": [
            "[series float, series float, series float]"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "ta.correlation",
          "desc": "Correlation coefficient. Describes the degree to which two series tend to deviate from their [ta.sma](#fun_ta.sma) values.",
          "args": [
            {
              "name": "source1",
              "desc": "Source series.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "open",
                "high",
                "low",
                "close",
                "volume"
              ]
            },
            {
              "name": "source2",
              "desc": "Target series.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "open",
                "high",
                "low",
                "close",
                "volume"
              ]
            },
            {
              "name": "length",
              "desc": "Length (number of bars back).",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                14,
                20,
                50,
                100,
                200
              ]
            }
          ],
          "syntax": "ta.correlation(source1, source2, length) → series float",
          "remarks": "`na` values in the `source` series are ignored; the function calculates on the `length` quantity of non-`na` values.",
          "returns": "Correlation coefficient.",
          "seeAlso": [
            "[request.security](#fun_request.security)"
          ],
          "returnedType": "float",
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "ta.tsi",
          "desc": "True strength index. It uses moving averages of the underlying momentum of a financial instrument.",
          "args": [
            {
              "name": "source",
              "desc": "Source series.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "close",
                "open",
                "high",
                "low",
                "volume"
              ]
            },
            {
              "name": "short_length",
              "desc": "Short length.",
              "default": null,
              "required": true,
              "displayType": "simple int",
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                7,
                14,
                25,
                50,
                10
              ]
            },
            {
              "name": "long_length",
              "desc": "Long length.",
              "default": null,
              "required": true,
              "displayType": "simple int",
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                25,
                50,
                100,
                200,
                14
              ]
            }
          ],
          "syntax": "ta.tsi(source, short_length, long_length) → series float",
          "remarks": "`na` values in the `source` series are ignored; the function calculates on the `length` quantity of non-`na` values.",
          "returns": "True strength index. A value in range [-1, 1].",
          "returnedType": "float",
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "ta.linreg",
          "desc": "Linear regression curve. A line that best fits the prices specified over a user-defined time period.  \nIt is calculated using the least squares method.  \nThe result of this function is calculated using the formula: linreg = intercept + slope * (length - 1 - offset), where intercept and slope are the values calculated with the least squares method on `source` series.",
          "args": [
            {
              "name": "source",
              "desc": "Source series.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "open",
                "high",
                "low",
                "close",
                "volume"
              ]
            },
            {
              "name": "length",
              "desc": "Number of bars (length).",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                9,
                14,
                20,
                50,
                200
              ]
            },
            {
              "name": "offset",
              "desc": "Offset.",
              "default": null,
              "required": true,
              "displayType": "simple int",
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "ta.linreg(source, length, offset) → series float",
          "remarks": "`na` values in the `source` series are included in calculations and will produce an `na` result.",
          "returns": "Linear regression curve.",
          "returnedType": "float",
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "ta.stoch",
          "desc": "Stochastic. It is calculated by a formula: 100 * (close - lowest(low, length)) / (highest(high, length) - lowest(low, length)).",
          "args": [
            {
              "name": "source",
              "desc": "Source series.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "close",
                "open",
                "high",
                "low",
                "volume"
              ]
            },
            {
              "name": "high",
              "desc": "Series of high.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "high"
              ]
            },
            {
              "name": "low",
              "desc": "Series of low.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "low"
              ]
            },
            {
              "name": "length",
              "desc": "Length (number of bars back).",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                5,
                9,
                14,
                20,
                50
              ]
            }
          ],
          "syntax": "ta.stoch(source, high, low, length) → series float",
          "remarks": "`na` values in the `source` series are ignored.",
          "returns": "Stochastic.",
          "seeAlso": [
            "[ta.cog](#fun_ta.cog)"
          ],
          "returnedType": "float",
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "ta.atr",
          "desc": "Function atr (average true range) returns the RMA of true range. True range is max(high - low, abs(high - close[1]), abs(low - close[1])).",
          "args": [
            {
              "name": "length",
              "desc": "Length (number of bars back).",
              "default": null,
              "required": true,
              "displayType": "simple int",
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                14,
                20,
                50,
                100,
                200
              ]
            }
          ],
          "syntax": "ta.atr(length) → series float",
          "remarks": "`na` values in the `source` series are ignored; the function calculates on the `length` quantity of non-`na` values.",
          "returns": "Average true range.",
          "seeAlso": [
            "[ta.tr](#fun_ta.tr)",
            "[ta.rma](#fun_ta.rma)"
          ],
          "examples": "//@version=5\nindicator(\"ta.atr\")\nplot(ta.atr(14))\n\n//the same on pine\npine_atr(length) =>\n    trueRange = na(high[1])? high-low : math.max(math.max(high - low, math.abs(high - close[1])), math.abs(low - close[1]))\n    //true range can be also calculated with ta.tr(true)\n    ta.rma(trueRange, length)\n\nplot(pine_atr(14))",
          "returnedType": "float",
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "fixnan",
          "desc": "For a given series replaces NaN values with previous nearest non-NaN value.",
          "args": [
            {
              "name": "source",
              "desc": "Source used for the calculation.",
              "default": null,
              "required": true,
              "displayType": "series int|float|bool|color",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float",
                "series bool",
                "simple bool",
                "input bool",
                "const bool",
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "fixnan(source) → series float|int|bool|color",
          "returns": "Series without na gaps.",
          "seeAlso": [
            "[na](#fun_na)",
            "[na](#var_na)",
            "[nz](#fun_nz)"
          ],
          "returnedType": [
            "float",
            "color",
            "int",
            "bool"
          ],
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float",
            "series int",
            "simple int",
            "input int",
            "const int",
            "series bool",
            "simple bool",
            "input bool",
            "const bool",
            "series color",
            "simple color",
            "input color",
            "const color"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "ta.cum",
          "desc": "Cumulative (total) sum of `source`. In other words it\\`s a sum of all elements of `source`.",
          "args": [
            {
              "name": "source",
              "desc": "Source used for the calculation.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "open",
                "high",
                "low",
                "close",
                "volume"
              ]
            }
          ],
          "syntax": "ta.cum(source) → series float",
          "returns": "Total sum series.",
          "seeAlso": [
            "[math.sum](#fun_math.sum)"
          ],
          "returnedType": "float",
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "ta.change",
          "desc": "Compares the current `source` value to its value `length` bars ago and returns the difference.",
          "args": [
            {
              "name": "source",
              "desc": "Source series.",
              "default": null,
              "required": true,
              "displayType": "series int|float|bool",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float",
                "series bool",
                "simple bool",
                "input bool",
                "const bool"
              ],
              "possibleValues": [
                "open",
                "high",
                "low",
                "close",
                "volume"
              ]
            },
            {
              "name": "length",
              "desc": "How far the past `source` value is offset from the current one, in bars. Optional. The default is 1.",
              "default": "1",
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            }
          ],
          "syntax": "ta.change(source) → float|bool|int|float\nta.change(source, length) → bool|int",
          "remarks": "`na` values in the `source` series are included in calculations and will produce an `na` result.",
          "returns": "The difference between the values when they are numerical. When a 'bool' source is used, returns `true` when the current source is different from the previous source.",
          "seeAlso": [
            "[ta.mom](#fun_ta.mom)",
            "[ta.cross](#fun_ta.cross)"
          ],
          "examples": "//@version=5\nindicator('Day and Direction Change', overlay = true)\ndailyBarTime = time('1D')\nisNewDay = ta.change(dailyBarTime)\nbgcolor(isNewDay ? color.new(color.green, 80) : na)\n\nisGreenBar = close >= open\ncolorChange = ta.change(isGreenBar)\nplotshape(colorChange, 'Direction Change')",
          "returnedType": [
            "float",
            "int",
            "bool"
          ],
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float",
            "series bool",
            "simple bool",
            "input bool",
            "const bool",
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "ta.mom",
          "desc": "Momentum of `source` price and `source` price `length` bars ago. This is simply a difference: source - source[length].",
          "args": [
            {
              "name": "source",
              "desc": "Series of values to process.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "open",
                "high",
                "low",
                "close",
                "volume"
              ]
            },
            {
              "name": "length",
              "desc": "Offset from the current bar to the previous bar.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                1,
                14,
                20,
                50,
                200
              ]
            }
          ],
          "syntax": "ta.mom(source, length) → series float",
          "remarks": "`na` values in the `source` series are included in calculations and will produce an `na` result.",
          "returns": "Momentum of `source` price and `source` price `length` bars ago.",
          "seeAlso": [
            "[ta.change](#fun_ta.change)"
          ],
          "returnedType": "float",
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "ta.pivot_point_levels",
          "desc": "Calculates the pivot point levels using the specified `type` and `anchor`.",
          "args": [
            {
              "name": "displayType",
              "desc": "The type of pivot point levels.  \nPossible values: \"Traditional\", \"Fibonacci\", \"Woodie\", \"Classic\", \"DM\", \"Camarilla\".",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "isString": true,
              "possibleValues": [
                "Traditional",
                "Fibonacci",
                "Woodie",
                "Classic",
                "DM",
                "Camarilla"
              ]
            },
            {
              "name": "anchor",
              "desc": "The condition that triggers the reset of the pivot point calculations. When [true](#op_true), calculations reset; when [false](#op_false), results calculated at the last reset persist.",
              "default": null,
              "required": true,
              "displayType": "series bool",
              "allowedTypeIDs": [
                "series bool",
                "simple bool",
                "input bool",
                "const bool"
              ],
              "possibleValues": [
                "true",
                "false"
              ]
            },
            {
              "name": "developing",
              "desc": "If [false](#op_false), the values are those calculated the last time the anchor condition was [true](#op_true).  \nThey remain constant until the anchor condition becomes [true](#op_true) again.  \nIf [true](#op_true), the pivots are developing, i.e., they constantly recalculate on the data developing between the point of the last anchor (or bar zero if the anchor condition was never [true](#op_true)) and the current bar.  \nOptional. The default is [false](#op_false).",
              "default": "false",
              "required": false,
              "displayType": "series bool",
              "allowedTypeIDs": [
                "series bool",
                "simple bool",
                "input bool",
                "const bool"
              ],
              "possibleValues": [
                "true",
                "false"
              ]
            }
          ],
          "syntax": "ta.pivot_point_levels(type, anchor, developing) → array<float>",
          "remarks": "The `developing` parameter cannot be `true` when `type` is set to \"Woodie\", because the Woodie calculation for a period depends on that period\\`s open, which means that the pivot value is either available or unavailable, but never developing.  \nIf used together, the indicator will return a runtime error.",
          "returns": "A array<float> array with numerical values representing 11 pivot point levels: [P, R1, S1, R2, S2, R3, S3, R4, S4, R5, S5]. Levels absent from the specified `type` return [na](#var_na) values (e.g., \"DM\" only calculates P, R1, and S1).",
          "examples": "//@version=5\nindicator(\"Weekly Pivots\", max_lines_count=500, overlay=true)\ntimeframe = \"1W\"\ntypeInput = input.string(\"Traditional\", \"Type\", options=[\"Traditional\", \"Fibonacci\", \"Woodie\", \"Classic\", \"DM\", \"Camarilla\"])\nweekChange = timeframe.change(timeframe)\npivotPointsArray = ta.pivot_point_levels(typeInput, weekChange)\nif weekChange\n    for pivotLevel in pivotPointsArray\n        line.new(time, pivotLevel, time + timeframe.in_seconds(timeframe) * 1000, pivotLevel, xloc=xloc.bar_time)",
          "returnedType": "array<float>",
          "returnedTypes": [
            "array<float>"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "ta.swma",
          "desc": "Symmetrically weighted moving average with fixed length: 4. Weights: [1/6, 2/6, 2/6, 1/6].",
          "args": [
            {
              "name": "source",
              "desc": "Source series.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "close",
                "open",
                "high",
                "low",
                "volume"
              ]
            }
          ],
          "syntax": "ta.swma(source) → series float",
          "remarks": "`na` values in the `source` series are included in calculations and will produce an `na` result.",
          "returns": "Symmetrically weighted moving average.",
          "seeAlso": [
            "[ta.sma](#fun_ta.sma)",
            "[ta.ema](#fun_ta.ema)",
            "[ta.rma](#fun_ta.rma)",
            "[ta.wma](#fun_ta.wma)",
            "[ta.vwma](#fun_ta.vwma)",
            "[ta.alma](#fun_ta.alma)"
          ],
          "examples": "//@version=5\nindicator(\"ta.swma\")\nplot(ta.swma(close))\n\n// same on pine, but less efficient\npine_swma(x) =>\n    x[3] * 1 / 6 + x[2] * 2 / 6 + x[1] * 2 / 6 + x[0] * 1 / 6\nplot(pine_swma(close))",
          "returnedType": "float",
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "ta.sar",
          "desc": "Parabolic SAR (parabolic stop and reverse) is a method devised by J. Welles Wilder, Jr., to find potential reversals in the market price direction of traded goods.",
          "args": [
            {
              "name": "start",
              "desc": "Start.",
              "default": null,
              "required": true,
              "displayType": "simple int|float",
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            },
            {
              "name": "inc",
              "desc": "Increment.",
              "default": null,
              "required": true,
              "displayType": "simple int|float",
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            },
            {
              "name": "max",
              "desc": "Maximum.",
              "default": null,
              "required": true,
              "displayType": "simple int|float",
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "ta.sar(start, inc, max) → series float",
          "returns": "Parabolic SAR.",
          "examples": "//@version=5\nindicator(\"ta.sar\")\nplot(ta.sar(0.02, 0.02, 0.2), style=plot.style_cross, linewidth=3)\n\n// The same on Pine Script™\npine_sar(start, inc, max) =>\n\tvar float result = na\n\tvar float maxMin = na\n\tvar float acceleration = na\n\tvar bool isBelow = na\n\tbool isFirstTrendBar = false\n\t\n\tif bar_index == 1\n\t\tif close > close[1]\n\t\t\tisBelow := true\n\t\t\tmaxMin := high\n\t\t\tresult := low[1]\n\t\telse\n\t\t\tisBelow := false\n\t\t\tmaxMin := low\n\t\t\tresult := high[1]\n\t\tisFirstTrendBar := true\n\t\tacceleration := start\n\t\n\tresult := result + acceleration * (maxMin - result)\n\t\n\tif isBelow\n\t\tif result > low\n\t\t\tisFirstTrendBar := true\n\t\t\tisBelow := false\n\t\t\tresult := math.max(high, maxMin)\n\t\t\tmaxMin := low\n\t\t\tacceleration := start\n\telse\n\t\tif result < high\n\t\t\tisFirstTrendBar := true\n\t\t\tisBelow := true\n\t\t\tresult := math.min(low, maxMin)\n\t\t\tmaxMin := high\n\t\t\tacceleration := start\n\t\t\t\n\tif not isFirstTrendBar\n\t\tif isBelow\n\t\t\tif high > maxMin\n\t\t\t\tmaxMin := high\n\t\t\t\tacceleration := math.min(acceleration + inc, max)\n\t\telse\n\t\t\tif low < maxMin\n\t\t\t\tmaxMin := low\n\t\t\t\tacceleration := math.min(acceleration + inc, max)\n\t\n\tif isBelow\n\t\tresult := math.min(result, low[1])\n\t\tif bar_index > 1\n\t\t\tresult := math.min(result, low[2])\n\t\t\n\telse\n\t\tresult := math.max(result, high[1])\n\t\tif bar_index > 1\n\t\t\tresult := math.max(result, high[2])\n\t\n\tresult\n\t\nplot(pine_sar(0.02, 0.02, 0.2), style=plot.style_cross, linewidth=3)",
          "returnedType": "float",
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "timeframe.change",
          "desc": "Detects changes in the specified `timeframe`.",
          "args": [
            {
              "name": "timeframe",
              "desc": "String formatted according to the [User manual\\`s timeframe string specifications](https://www.tradingview.com/pine-script-docs/en/v5/concepts/Timeframes.html#timeframe-string-specifications).",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "isString": true,
              "possibleValues": [
                "\"\"",
                "1D",
                "1W",
                "1M",
                "240",
                "60",
                "15",
                "5"
              ]
            }
          ],
          "syntax": "timeframe.change(timeframe) → series bool",
          "returns": "Returns [true](#op_true) on the first bar of a new `timeframe`, [false](#op_false) otherwise.",
          "examples": "//@version=5\n// Run this script on an intraday chart.\nindicator(\"New day started\", overlay = true)\n// Highlights the first bar of the new day.\nisNewDay = timeframe.change(\"1D\")\nbgcolor(isNewDay ? color.new(color.green, 80) : na)",
          "returnedType": "bool",
          "returnedTypes": [
            "series bool",
            "simple bool",
            "input bool",
            "const bool"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "math.avg",
          "desc": "Calculates average of all given series (elementwise).",
          "syntax": "math.avg(number0, number1, ...) → series float",
          "returns": "Average.",
          "seeAlso": [
            "[math.sum](#fun_math.sum)",
            "[ta.cum](#fun_ta.cum)",
            "[ta.sma](#fun_ta.sma)"
          ],
          "returnedType": "float",
          "returnedTypes": [
            "simple float",
            "input float",
            "const float",
            "series float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "request.currency_rate",
          "desc": "Provides a daily rate that can be used to convert a value expressed in the `from` currency to another in the `to` currency.",
          "args": [
            {
              "name": "from",
              "desc": "The currency in which the value to be converted is expressed.  \nPossible values: a three-letter string with the [currency code in the ISO 4217 format](https://en.wikipedia.org/wiki/ISO_4217#Active_codes) (e.g. \"USD\"), or one of the built-in variables that return currency codes, like [syminfo.currency](#var_syminfo.currency) or [currency.USD](#var_currency.USD).",
              "default": null,
              "required": true,
              "displayType": "simple string",
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "currency.USD",
                "currency.EUR",
                "currency.JPY",
                "currency.GBP",
                "currency.AUD"
              ]
            },
            {
              "name": "to",
              "desc": "The currency in which the value is to be converted.  \nPossible values: a three-letter string with the [currency code in the ISO 4217 format](https://en.wikipedia.org/wiki/ISO_4217#Active_codes) (e.g. \"USD\"), or one of the built-in variables that return currency codes, like [syminfo.currency](#var_syminfo.currency) or [currency.USD](#var_currency.USD).",
              "default": null,
              "required": true,
              "displayType": "simple string",
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "currency.USD",
                "currency.EUR",
                "currency.JPY",
                "currency.GBP",
                "currency.AUD"
              ]
            },
            {
              "name": "ignore_invalid_currency",
              "desc": "Determines the behavior of the function if a conversion rate between the two currencies cannot be calculated: if [false](#op_false), the script will halt and return a runtime error; if [true](#op_true), the function will return [na](#var_na) and execution will continue.  \nOptional. The default is [false](#op_false).",
              "default": "false",
              "required": false,
              "displayType": "simple bool",
              "allowedTypeIDs": [
                "simple bool",
                "input bool",
                "const bool"
              ],
              "possibleValues": [
                "false",
                "true"
              ]
            }
          ],
          "syntax": "request.currency_rate(from, to, ignore_invalid_currency) → series float",
          "remarks": "If `from` and `to` arguments are equal, function returns 1. Please note that using this variable/function can cause [indicator repainting](https://www.tradingview.com/pine-script-docs/en/v5/concepts/Repainting.html).",
          "examples": "//@version=5\nindicator(\"Close in British Pounds\")\nrate = request.currency_rate(syminfo.currency, \"GBP\")\nplot(close * rate)",
          "returnedType": "float",
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "request.security",
          "desc": "Requests data from another symbol and/or timeframe.",
          "args": [
            {
              "name": "symbol",
              "desc": "Symbol to request the data from. Use [syminfo.tickerid](#var_syminfo.tickerid) to request data from the chart\\`s symbol.  \nTo request data with additional parameters (extended sessions, dividend adjustments, or a non-standard chart type like Heikin Ashi or Renko), a custom ticker identifier must first be created using functions in the `ticker.*` namespace.",
              "default": null,
              "required": true,
              "displayType": "simple string",
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "syminfo.tickerid",
                "syminfo.ticker"
              ]
            },
            {
              "name": "timeframe",
              "desc": "Timeframe of the requested data. To use the chart\\`s timeframe, use an empty string or the [timeframe.period](#var_timeframe.period) variable.  \nValid timeframe strings are documented in the User Manual\\`s [Timeframes](https://www.tradingview.com/pine-script-docs/en/v5/concepts/Timeframes.html#timeframe-string-specifications) page.",
              "default": null,
              "required": true,
              "displayType": "simple string",
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "isString": true,
              "possibleValues": [
                "\"\"",
                "1",
                "5",
                "15",
                "D",
                "W"
              ]
            },
            {
              "name": "expression",
              "desc": "An expression to be calculated and returned from the [request.security](#fun_request.security) call\\`s context.  \nIt can be a built-in variable like [close](#var_close), an expression such as `ta.sma(close, 100)`, a non-mutable user-defined variable previously calculated in the script, a function call that does not use PineScript™ drawings, an array, a matrix, or a tuple.  \nMutable variables are not allowed, unless they are enclosed in the body of a function used in the expression.",
              "default": null,
              "required": true,
              "displayType": "<variable>|<object>|<function>|array|matrix|int|float|bool|string|color|tuple[...]",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float",
                "series bool",
                "simple bool",
                "input bool",
                "const bool",
                "series color",
                "simple color",
                "input color",
                "const color",
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "gaps",
              "desc": "Specifies how the returned values are merged on chart bars.  \nPossible values: [barmerge.gaps_on](#var_barmerge.gaps_on), [barmerge.gaps_off](#var_barmerge.gaps_off).  \nWith [barmerge.gaps_on](#var_barmerge.gaps_on) a value only appears on the current chart bar when it first becomes available from the function\\`s context, otherwise [na](#var_na) is returned (thus a \"gap\" occurs).  \nWith [barmerge.gaps_off](#var_barmerge.gaps_off) what would otherwise be gaps are filled with the latest known value returned, avoiding [na](#var_na) values.  \nOptional. The default is [barmerge.gaps_off](#var_barmerge.gaps_off).",
              "default": "barmerge.gaps_off",
              "required": false,
              "displayType": "simple barmerge_gaps",
              "allowedTypeIDs": [
                "simple barmerge_gaps"
              ],
              "possibleValues": [
                "barmerge.gaps_on",
                "barmerge.gaps_off"
              ]
            },
            {
              "name": "lookahead",
              "desc": "On historical bars only, returns data from the timeframe before it elapses.  \nPossible values: [barmerge.lookahead_on](#var_barmerge.lookahead_on), [barmerge.lookahead_off](#var_barmerge.lookahead_off).  \nHas no effect on realtime values.  \nOptional. The default is [barmerge.lookahead_off](#var_barmerge.lookahead_off) starting from Pine Script™ v3.  \nThe default is [barmerge.lookahead_on](#var_barmerge.lookahead_on) in v1 and v2.  \nWARNING: Using [barmerge.lookahead_on](#var_barmerge.lookahead_on) at timeframes higher than the chart\\`s without offsetting the `expression` argument like in `close[1]` will introduce future leak in scripts, as the function will then return the `close` price before it is actually known in the current context.  \nAs is explained in the User Manual\\`s page on [Repainting](https://www.tradingview.com/pine-script-docs/en/v5/concepts/Repainting.html#future-leak-with-request-security) this will produce misleading results.",
              "default": "barmerge.lookahead_off",
              "required": false,
              "displayType": "simple barmerge_lookahead",
              "allowedTypeIDs": [
                "simple barmerge_lookahead"
              ],
              "possibleValues": [
                "barmerge.lookahead_on",
                "barmerge.lookahead_off"
              ]
            },
            {
              "name": "ignore_invalid_symbol",
              "desc": "Determines the behavior of the function if the specified symbol is not found: if [false](#op_false), the script will halt and throw a runtime error; if [true](#op_true), the function will return [na](#var_na) and execution will continue.  \nOptional. The default is [false](#op_false).",
              "default": "false",
              "required": false,
              "displayType": "input bool",
              "allowedTypeIDs": [
                "input bool",
                "const bool"
              ],
              "possibleValues": [
                "true",
                "false"
              ]
            },
            {
              "name": "currency",
              "desc": "Currency into which values expressed in currency units ([open](#var_open), [high](#var_high), [low](#var_low), [close](#var_close), etc.) or expressions using such values are to be converted.  \nThe conversion rates used are based on the FX_IDC pairs' daily rates of the previous day (relative to the bar where the calculation is done). \nPossible values: a three-letter string with the [currency code in the ISO 4217 format](https://en.wikipedia.org/wiki/ISO_4217#Active_codes) (e.g. \"USD\") or one of the constants in the currency.\\* namespace, e.g. [currency.USD](#var_currency.USD).  \nNote that literal values such as `200` are not converted.  \nOptional. The default is [syminfo.currency](#var_syminfo.currency).",
              "default": "syminfo.currency",
              "required": false,
              "displayType": "simple string",
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "currency.USD",
                "currency.EUR",
                "currency.JPY",
                "currency.GBP",
                "currency.AUD"
              ]
            }
          ],
          "syntax": "request.security(symbol, timeframe, expression, gaps, lookahead, ignore_invalid_symbol, currency) → series type",
          "remarks": "Pine Script™ code using this function may calculate differently on historical and realtime bars, leading to [repainting](https://www.tradingview.com/pine-script-docs/en/v5/concepts/Repainting.html).\nA single script can have no more than 40 calls to `request.*()` functions.",
          "returns": "A result determined by `expression`.",
          "seeAlso": [
            "[syminfo.ticker](#var_syminfo.ticker)",
            "[syminfo.tickerid](#var_syminfo.tickerid)",
            "[timeframe.period](#var_timeframe.period)",
            "[ticker.new](#fun_ticker.new)",
            "[ticker.modify](#fun_ticker.modify)",
            "[request.security_lower_tf](#fun_request.security_lower_tf)",
            "[request.dividends](#fun_request.dividends)",
            "[request.earnings](#fun_request.earnings)",
            "[request.splits](#fun_request.splits)",
            "[request.financial](#fun_request.financial)",
            "[request.quandl](#fun_request.quandl)"
          ],
          "detailedDesc": [
            {
              "desc": "",
              "examples": "//@version=5\nindicator(\"Simple `request.security()` calls\")\n// Returns 1D close of the current symbol.\ndailyClose = request.security(syminfo.tickerid, \"1D\", close)\nplot(dailyClose)\n\n// Returns the close of \"AAPL\" from the same timeframe as currently open on the chart.\naaplClose = request.security(\"AAPL\", timeframe.period, close)\nplot(aaplClose)"
            },
            {
              "desc": "",
              "examples": "//@version=5\nindicator(\"Advanced `request.security()` calls\")\n// This calculates a 10-period moving average on the active chart.\nsma = ta.sma(close, 10)\n// This sends the `sma` calculation for execution in the context of the \"AAPL\" symbol at a \"240\" (4 hours) timeframe.\naaplSma = request.security(\"AAPL\", \"240\", sma)\nplot(aaplSma)\n\n// To avoid differences on historical and realtime bars, you can use this technique, which only returns a value from the higher timeframe on the bar after it completes:\nindexHighTF = barstate.isrealtime ? 1 : 0\nindexCurrTF = barstate.isrealtime ? 0 : 1\nnonRepaintingClose = request.security(syminfo.tickerid, \"1D\", close[indexHighTF])[indexCurrTF]\nplot(nonRepaintingClose, \"Non-repainting close\")\n\n// Returns the 1H close of \"AAPL\", extended session included. The value is dividend-adjusted.\nextendedTicker = ticker.modify(\"NASDAQ:AAPL\", session = session.extended, adjustment = adjustment.dividends)\naaplExtAdj = request.security(extendedTicker, \"60\", close)\nplot(aaplExtAdj)\n\n// Returns the result of a user-defined function.\n// The `max` variable is mutable, but we can pass it to `request.security()` because it is wrapped in a function.\nallTimeHigh(source) =>\n\tvar max = source\n\tmax := math.max(max, source)\nallTimeHigh1D = request.security(syminfo.tickerid, \"1D\", allTimeHigh(high))\n\n// By using a tuple `expression`, we obtain several values with only one `request.security()` call.\n[open1D, high1D, low1D, close1D, ema1D] = request.security(syminfo.tickerid, \"1D\", [open, high, low, close, ta.ema(close, 10)])\nplotcandle(open1D, high1D, low1D, close1D)\nplot(ema1D)\n\n// Returns an array containing the OHLC values of the chart\\`s symbol from the 1D timeframe.\nohlcArray = request.security(syminfo.tickerid, \"1D\", array.from(open, high, low, close))\nplotcandle(array.get(ohlcArray, 0), array.get(ohlcArray, 1), array.get(ohlcArray, 2), array.get(ohlcArray, 3))"
            }
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "request.security_lower_tf",
          "desc": "Requests data from a specified symbol from a lower timeframe than the chart\\`s. The function returns an array containing one element for each closed lower timeframe intrabar inside the current chart\\`s bar.  \nOn a 5-minute chart using a `timeframe` argument of \"1\", the size of the array will usually be 5, with each array element representing the value of `expression` on a 1-minute intrabar, ordered sequentially in time.",
          "args": [
            {
              "name": "symbol",
              "desc": "Symbol to request the data from. Use [syminfo.tickerid](#var_syminfo.tickerid) to request data from the chart\\`s symbol.  \nTo request data with additional parameters (extended sessions, dividend adjustments, or a non-standard chart type like Heikin Ashi or Renko), a custom ticker identifier must first be created using functions in the `ticker.*` namespace.",
              "default": null,
              "required": true,
              "displayType": "simple string",
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "syminfo.tickerid",
                "syminfo.ticker"
              ]
            },
            {
              "name": "timeframe",
              "desc": "Timeframe of the requested data. To use the chart\\`s timeframe, use an empty string or the [timeframe.period](#var_timeframe.period) variable.  \nValid timeframe strings are documented in the User Manual\\`s [Timeframes](https://www.tradingview.com/pine-script-docs/en/v5/concepts/Timeframes.html#timeframe-string-specifications) page.",
              "default": null,
              "required": true,
              "displayType": "simple string",
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "isString": true,
              "possibleValues": [
                "\"\"",
                "1",
                "3",
                "5",
                "15",
                "30",
                "60",
                "D",
                "W"
              ]
            },
            {
              "name": "expression",
              "desc": "An expression to be calculated and returned from the function call\\`s context. It can be a built-in variable like [close](#var_close), an expression such as `ta.sma(close, 100)`, a non-mutable user-defined variable previously calculated in the script, a function call that does not use PineScript™ drawings, arrays or matrices, or a tuple.  \nMutable variables are not allowed, unless they are enclosed in the body of a function used in the expression.",
              "default": null,
              "required": true,
              "displayType": "<variable>|<object>|<function>|array|matrix|int|float|bool|string|color|tuple[...]",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float",
                "series bool",
                "simple bool",
                "input bool",
                "const bool",
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "possibleValues": null
            },
            {
              "name": "ignore_invalid_symbol",
              "desc": "Determines the behavior of the function if the specified symbol is not found: if [false](#op_false), the script will halt and throw a runtime error; if [true](#op_true), the function will return [na](#var_na) and execution will continue.  \nOptional. The default is [false](#op_false).",
              "default": "false",
              "required": false,
              "displayType": "const bool",
              "allowedTypeIDs": [
                "const bool"
              ],
              "possibleValues": [
                "true",
                "false"
              ]
            },
            {
              "name": "currency",
              "desc": "Currency into which values expressed in currency units ([open](#var_open), [high](#var_high), [low](#var_low), [close](#var_close), etc.) or expressions using such values are to be converted.  \nThe conversion rates used are based on the FX_IDC pairs' daily rates of the previous day (relative to the bar where the calculation is done). \nPossible values: a three-letter string with the [currency code in the ISO 4217 format](https://en.wikipedia.org/wiki/ISO_4217#Active_codes) (e.g. \"USD\") or one of the constants in the currency.\\* namespace, e.g. [currency.USD](#var_currency.USD).  \nNote that literal values such as `200` are not converted.  \nOptional. The default is [syminfo.currency](#var_syminfo.currency).",
              "default": "syminfo.currency",
              "required": false,
              "displayType": "simple string",
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "currency.USD",
                "currency.EUR",
                "currency.JPY",
                "currency.GBP",
                "currency.AUD"
              ]
            }
          ],
          "syntax": "request.security_lower_tf(symbol, timeframe, expression, ignore_invalid_symbol, currency) → type[]",
          "remarks": "Pine Script™ code using this function may calculate differently on historical and real-time bars, leading to [repainting](https://www.tradingview.com/pine-script-docs/en/v5/concepts/Repainting.html).\nPlease note that spreads (e.g., “AAPL+MSFT*TSLA”) will not always return reliable data with this function.\nA single script can have no more than 40 calls to `request.*()` functions.\nA maximum of 100, 000 lower timeframe bars can be accessed by this function.  \nThe number of chart bars for which lower timeframe data is available will thus vary with the requested lower timeframe.",
          "returns": "An array of a type determined by `expression`, or a tuple of these.",
          "seeAlso": [
            "[request.security](#fun_request.security)",
            "[syminfo.ticker](#var_syminfo.ticker)",
            "[syminfo.tickerid](#var_syminfo.tickerid)",
            "[timeframe.period](#var_timeframe.period)",
            "[ticker.new](#fun_ticker.new)",
            "[request.dividends](#fun_request.dividends)",
            "[request.earnings](#fun_request.earnings)",
            "[request.splits](#fun_request.splits)",
            "[request.financial](#fun_request.financial)",
            "[request.quandl](#fun_request.quandl)"
          ],
          "examples": "//@version=5\nindicator(\"`request.security_lower_tf()` Example\", overlay = true)\n\n// If the current chart timeframe is set to 120 minutes, then the `arrayClose` array will contain two 'close' values from the 60 minute timeframe for each bar.\narrClose = request.security_lower_tf(syminfo.tickerid, \"60\", close)\n\nif bar_index == last_bar_index - 1\n    label.new(bar_index, high, str.tostring(arrClose))"
        },
        {
          "kind": "Built-in Function",
          "name": "request.financial",
          "desc": "Requests financial series for symbol.",
          "args": [
            {
              "name": "symbol",
              "desc": "Symbol. Note that the symbol should be passed with a prefix. For example: \"NASDAQ:AAPL\" instead of \"AAPL\".",
              "default": null,
              "required": true,
              "displayType": "simple string",
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "financial_id",
              "desc": "Financial identifier. You can find the list of available ids via our [Help Center](https://www.tradingview.com/?solution=43000564727).",
              "default": null,
              "required": true,
              "displayType": "simple string",
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "period",
              "desc": "Reporting period. Possible values are \"TTM\", \"FY\", \"FQ\".",
              "default": null,
              "required": true,
              "displayType": "simple string",
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "isString": true,
              "possibleValues": [
                "TTM",
                "FY",
                "FQ"
              ]
            },
            {
              "name": "gaps",
              "desc": "Merge strategy for the requested data (requested data automatically merges with the main series: OHLC data).  \nPossible values include: [barmerge.gaps_on](#var_barmerge.gaps_on), [barmerge.gaps_off](#var_barmerge.gaps_off). [barmerge.gaps_on](#var_barmerge.gaps_on) - requested data is merged with possible gaps ([na](#var_na) values). [barmerge.gaps_off](#var_barmerge.gaps_off) - requested data is merged continuously without gaps, all the gaps are filled with the previous, nearest existing values.  \nDefault value is [barmerge.gaps_off](#var_barmerge.gaps_off).",
              "default": "barmerge.gaps_off",
              "required": true,
              "displayType": "simple barmerge_gaps",
              "allowedTypeIDs": [
                "simple barmerge_gaps"
              ],
              "possibleValues": [
                "barmerge.gaps_off",
                "barmerge.gaps_on"
              ]
            },
            {
              "name": "ignore_invalid_symbol",
              "desc": "An optional parameter. Determines the behavior of the function if the specified symbol is not found: if false, the script will halt and return a runtime error; if true, the function will return na and execution will continue.  \nThe default value is false.",
              "default": "false",
              "required": false,
              "displayType": "input bool",
              "allowedTypeIDs": [
                "input bool",
                "const bool"
              ],
              "possibleValues": [
                "true",
                "false"
              ]
            },
            {
              "name": "currency",
              "desc": "Currency into which the symbol\\`s financial metrics (e.g. Net Income) are to be converted.  \nThe conversion rates used are based on the FX_IDC pairs' daily rates of the previous day (relative to the bar where the calculation is done).  \nOptional. The default is [syminfo.currency](#var_syminfo.currency). \nPossible values: a three-letter string with the [currency code in the ISO 4217 format](https://en.wikipedia.org/wiki/ISO_4217#Active_codes) (e.g. \"USD\") or one of the constants in the currency.\\* namespace, e.g. [currency.USD](#var_currency.USD).",
              "default": "syminfo.currency",
              "required": false,
              "displayType": "simple string",
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "currency.USD",
                "currency.EUR",
                "currency.JPY",
                "currency.GBP",
                "currency.AUD"
              ]
            }
          ],
          "syntax": "request.financial(symbol, financial_id, period, gaps, ignore_invalid_symbol, currency) → series float",
          "returns": "Requested series.",
          "seeAlso": [
            "[request.security](#fun_request.security)",
            "[syminfo.tickerid](#var_syminfo.tickerid)"
          ],
          "examples": "//@version=5\nindicator(\"request.financial\")\nf = request.financial(\"NASDAQ:MSFT\", \"ACCOUNTS_PAYABLE\", \"FY\")\nplot(f)",
          "returnedType": "float",
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "request.quandl",
          "desc": "Requests [Nasdaq Data Link](https://data.nasdaq.com/) (formerly Quandl) data for a symbol.",
          "args": [
            {
              "name": "ticker",
              "desc": "Symbol. Note that the name of a time series and Quandl data feed should be divided by a forward slash.  \nFor example: \"CFTC/SB_FO_ALL\".",
              "default": null,
              "required": true,
              "displayType": "simple string",
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "gaps",
              "desc": "Merge strategy for the requested data (requested data automatically merges with the main series: OHLC data).  \nPossible values include: [barmerge.gaps_on](#var_barmerge.gaps_on), [barmerge.gaps_off](#var_barmerge.gaps_off). [barmerge.gaps_on](#var_barmerge.gaps_on) - requested data is merged with possible gaps ([na](#var_na) values). [barmerge.gaps_off](#var_barmerge.gaps_off) - requested data is merged continuously without gaps, all the gaps are filled with the previous, nearest existing values.  \nDefault value is [barmerge.gaps_off](#var_barmerge.gaps_off).",
              "default": "barmerge.gaps_off",
              "required": true,
              "displayType": "simple barmerge_gaps",
              "allowedTypeIDs": [
                "simple barmerge_gaps"
              ],
              "possibleValues": [
                "barmerge.gaps_on",
                "barmerge.gaps_off"
              ]
            },
            {
              "name": "index",
              "desc": "A Quandl time-series column index.",
              "default": null,
              "required": true,
              "displayType": "simple int",
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "ignore_invalid_symbol",
              "desc": "An optional parameter. Determines the behavior of the function if the specified symbol is not found: if false, the script will halt and return a runtime error; if true, the function will return na and execution will continue.  \nThe default value is false.",
              "default": "false",
              "required": false,
              "displayType": "input bool",
              "allowedTypeIDs": [
                "input bool",
                "const bool"
              ],
              "possibleValues": [
                "true",
                "false"
              ]
            }
          ],
          "syntax": "request.quandl(ticker, gaps, index, ignore_invalid_symbol) → series float",
          "remarks": "You can learn more about how to find ticker and index values in our [Help Center](https://www.tradingview.com/chart/?solution=43000568613).",
          "returns": "Requested series.",
          "seeAlso": [
            "[request.security](#fun_request.security)",
            "[syminfo.tickerid](#var_syminfo.tickerid)"
          ],
          "examples": "//@version=5\nindicator(\"request.quandl\")\nf = request.quandl(\"CFTC/SB_FO_ALL\", barmerge.gaps_off, 0)\nplot(f)",
          "returnedType": "float",
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "ticker.new",
          "desc": "Creates a ticker identifier for requesting additional data for the script.",
          "args": [
            {
              "name": "prefix",
              "desc": "Exchange prefix. For example: 'BATS', 'NYSE', 'NASDAQ'. Exchange prefix of main series is [syminfo.prefix](#var_syminfo.prefix).",
              "default": null,
              "required": true,
              "displayType": "simple string",
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "ticker",
              "desc": "Ticker name. For example 'AAPL', 'MSFT', 'EURUSD'. Ticker name of the main series is [syminfo.ticker](#var_syminfo.ticker).",
              "default": null,
              "required": true,
              "displayType": "simple string",
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "session",
              "desc": "Session type. Optional argument.  \nPossible values: [session.regular](#const_session.regular), [session.extended](#const_session.extended).  \nSession type of the current chart is [syminfo.session](#const_syminfo.session).  \nIf session is not given, then [syminfo.session](#const_syminfo.session) value is used.",
              "default": "syminfo.session",
              "required": false,
              "displayType": "simple string",
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "session.regular",
                "session.extended",
                "syminfo.session"
              ]
            },
            {
              "name": "adjustment",
              "desc": "Adjustment type. Optional argument.  \nPossible values: [adjustment.none](#var_adjustment.none), [adjustment.splits](#var_adjustment.splits), [adjustment.dividends](#var_adjustment.dividends).  \nIf adjustment is not given, then default adjustment value is used (can be different depending on particular instrument).",
              "default": "adjustment.none",
              "required": false,
              "displayType": "simple string",
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "adjustment.none",
                "adjustment.splits",
                "adjustment.dividends"
              ]
            }
          ],
          "syntax": "ticker.new(prefix, ticker, session, adjustment) → simple string",
          "remarks": "You may use return value of [ticker.new](#fun_ticker.new) function as input argument for [ticker.heikinashi](#fun_ticker.heikinashi), [ticker.renko](#fun_ticker.renko), [ticker.linebreak](#fun_ticker.linebreak), [ticker.kagi](#fun_ticker.kagi), [ticker.pointfigure](#fun_ticker.pointfigure) functions.",
          "returns": "String value of ticker id, that can be supplied to [request.security](#fun_request.security) function.",
          "seeAlso": [
            "[syminfo.tickerid](#var_syminfo.tickerid)",
            "[syminfo.ticker](#var_syminfo.ticker)",
            "[syminfo.session](#const_syminfo.session)",
            "[session.extended](#const_session.extended)",
            "[session.regular](#const_session.regular)",
            "[ticker.heikinashi](#fun_ticker.heikinashi)",
            "[adjustment.none](#const_adjustment.none)",
            "[adjustment.splits](#const_adjustment.splits)",
            "[adjustment.dividends](#const_adjustment.dividends)"
          ],
          "examples": "//@version=5\nindicator(\"ticker.new\", overlay=true) \nt = ticker.new(syminfo.prefix, syminfo.ticker, session.regular, adjustment.splits)\nt2 = ticker.heikinashi(t)\nc = request.security(t2, timeframe.period, low, barmerge.gaps_on)\nplot(c, style=plot.style_linebr)",
          "returnedType": "string",
          "returnedTypes": [
            "simple string",
            "input string",
            "const string"
          ]
        },
        {
          "name": "ticker.inherit",
          "desc": "Constructs a ticker ID for the specified `symbol` with additional parameters inherited from the ticker ID passed into the function call, allowing the script to request a symbol's data using the same modifiers that the `from_tickerid` has, including extended session, dividend adjustment, currency conversion, non-standard chart types, back-adjustment, settlement-as-close, etc.",
          "args": [
            {
              "name": "from_tickerid",
              "desc": "The ticker ID to inherit modifiers from.",
              "required": true,
              "displayType": "simple string",
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "symbol",
              "desc": "The symbol to construct the new ticker ID for. ",
              "required": true,
              "displayType": "simple string",
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            }
          ],
          "kind": "Built-in Function",
          "syntax": "ticker.inherit(from_tickerid, symbol) → simple string",
          "remarks": "If the constructed ticker ID inherits a modifier that doesn't apply to the symbol (e.g., if the `from_tickerid` has Extended Hours enabled, but no such option is available for the `symbol`), the script will ignore the modifier when requesting data using the ID.",
          "examples": "//@version=5\nindicator('ticker.inherit')\n\n//@variable A 'NASDAQ:AAPL' ticker ID with Extender Hours enabled.\ntickerExtHours = ticker.new('NASDAQ', 'AAPL', session.extended)\n//@variable A Heikin Ashi ticker ID for 'NASDAQ:AAPL' with Extended Hours enabled.\nHAtickerExtHours = ticker.heikinashi(tickerExtHours)\n//@variable The 'NASDAQ:MSFT' symbol with no modifiers.\ntestSymbol = 'NASDAQ:MSFT'\n//@variable A ticker ID for 'NASDAQ:MSFT' with inherited Heikin Ashi and Extended Hours modifiers.\ntestSymbolHAtickerExtHours = ticker.inherit(HAtickerExtHours, testSymbol)\n\n//@variable The `close` price requested using 'NASDAQ:MSFT' with inherited modifiers. \nsecData = request.security(testSymbolHAtickerExtHours, '60', close, ignore_invalid_symbol = true)\n//@variable The `close` price requested using 'NASDAQ:MSFT' without modifiers. \ncompareData = request.security(testSymbol, '60', close, ignore_invalid_symbol = true)\n\nplot(secData, color = color.green)\nplot(compareData)",
          "returnedTypes": "simple string"
        },
        {
          "kind": "Built-in Function",
          "name": "ticker.standard",
          "desc": "Creates a ticker to request data from a standard chart that is unaffected by modifiers like extended session, dividend adjustment, currency conversion, and the calculations of non-standard chart types: Heikin Ashi, Renko, etc. Among other things, this makes it possible to retrieve standard chart values when the script is running on a non-standard chart.",
          "args": [
            {
              "name": "symbol",
              "desc": "A ticker ID to be converted into its standard form. Optional. The default is [syminfo.tickerid](#var_syminfo.tickerid).",
              "default": "syminfo.tickerid",
              "required": false,
              "displayType": "simple string",
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "ticker.standard(symbol) → simple string",
          "returns": "A string representing the ticker of a standard chart in the \"prefix:ticker\" format. If the `symbol` argument does not contain the prefix and ticker information, the function returns the supplied argument as is.",
          "seeAlso": [
            "[request.security](#fun_request.security)"
          ],
          "examples": "//@version=5\nindicator(\"ticker.standard\", overlay = true)\n// This script should be run on a non-standard chart such as HA, Renko...\n\n// Requests data from the chart type the script is running on.\nchartTypeValue = request.security(syminfo.tickerid, \"1D\", close)\n\n// Request data from the standard chart type, regardless of the chart type the script is running on.\nstandardChartValue = request.security(ticker.standard(syminfo.tickerid), \"1D\", close)\n\n// This will not use a standard ticker ID because the `symbol` argument contains only the ticker — not the prefix (exchange).\nstandardChartValue2 = request.security(ticker.standard(syminfo.ticker), \"1D\", close)\n\nplot(chartTypeValue)\nplot(standardChartValue, color = color.green)",
          "returnedType": "string",
          "returnedTypes": [
            "simple string",
            "input string",
            "const string"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "ticker.modify",
          "desc": "Creates a ticker identifier for requesting additional data for the script.",
          "args": [
            {
              "name": "tickerid",
              "desc": "Symbol name with exchange prefix, e.g. 'BATS:MSFT', 'NASDAQ:MSFT' or tickerid with session and adjustment from the [ticker.new](#fun_ticker.new) function.",
              "default": null,
              "required": true,
              "displayType": "simple string",
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "session",
              "desc": "Session type. Optional argument.  \nPossible values: [session.regular](#const_session.regular), [session.extended](#const_session.extended).  \nSession type of the current chart is [syminfo.session](#const_syminfo.session).  \nIf session is not given, then [syminfo.session](#const_syminfo.session) value is used.",
              "default": "syminfo.session",
              "required": false,
              "displayType": "simple string",
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "session.regular",
                "session.extended"
              ]
            },
            {
              "name": "adjustment",
              "desc": "Adjustment type. Optional argument.  \nPossible values: [adjustment.none](#var_adjustment.none), [adjustment.splits](#var_adjustment.splits), [adjustment.dividends](#var_adjustment.dividends).  \nIf adjustment is not given, then default adjustment value is used (can be different depending on particular instrument).",
              "default": "adjustment.none",
              "required": false,
              "displayType": "simple string",
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "adjustment.none",
                "adjustment.splits",
                "adjustment.dividends"
              ]
            }
          ],
          "syntax": "ticker.modify(tickerid, session, adjustment) → simple string",
          "returns": "String value of ticker id, that can be supplied to [request.security](#fun_request.security) function.",
          "seeAlso": [
            "[syminfo.tickerid](#var_syminfo.tickerid)",
            "[syminfo.ticker](#var_syminfo.ticker)",
            "[syminfo.session](#const_syminfo.session)",
            "[session.extended](#const_session.extended)",
            "[session.regular](#const_session.regular)",
            "[ticker.heikinashi](#fun_ticker.heikinashi)",
            "[adjustment.none](#const_adjustment.none)",
            "[adjustment.splits](#const_adjustment.splits)",
            "[adjustment.dividends](#const_adjustment.dividends)"
          ],
          "examples": "//@version=5\nindicator(\"ticker_modify\", overlay=true)\nt1 = ticker.new(syminfo.prefix, syminfo.ticker, session.regular, adjustment.splits)\nc1 = request.security(t1, \"D\", close)\nt2 = ticker.modify(t1, session.extended)\nc2 = request.security(t2, \"2D\", close)\nplot(c1)\nplot(c2)",
          "returnedType": "string",
          "returnedTypes": [
            "simple string",
            "input string",
            "const string"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "ticker.heikinashi",
          "desc": "Creates a ticker identifier for requesting Heikin Ashi bar values.",
          "args": [
            {
              "name": "symbol",
              "desc": "Symbol ticker identifier.",
              "default": null,
              "required": true,
              "displayType": "simple string",
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "syminfo.tickerid"
              ]
            }
          ],
          "syntax": "ticker.heikinashi(symbol) → simple string",
          "returns": "String value of ticker id, that can be supplied to [request.security](#fun_request.security) function.",
          "seeAlso": [
            "[syminfo.tickerid](#var_syminfo.tickerid)",
            "[syminfo.ticker](#var_syminfo.ticker)",
            "[request.security](#fun_request.security)",
            "[ticker.renko](#fun_ticker.renko)",
            "[ticker.linebreak](#fun_ticker.linebreak)",
            "[ticker.kagi](#fun_ticker.kagi)",
            "[ticker.pointfigure](#fun_ticker.pointfigure)"
          ],
          "examples": "//@version=5\nindicator(\"ticker.heikinashi\", overlay=true) \nheikinashi_close = request.security(ticker.heikinashi(syminfo.tickerid), timeframe.period, close)\n\nheikinashi_aapl_60_close = request.security(ticker.heikinashi(\"AAPL\"), \"60\", close)\nplot(heikinashi_close)\nplot(heikinashi_aapl_60_close)",
          "returnedType": "string",
          "returnedTypes": [
            "simple string",
            "input string",
            "const string"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "ticker.renko",
          "desc": "Creates a ticker identifier for requesting Renko values.",
          "args": [
            {
              "name": "symbol",
              "desc": "Symbol ticker identifier.",
              "default": null,
              "required": true,
              "displayType": "simple string",
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "style",
              "desc": "Box Size Assignment Method: 'ATR', 'Traditional'.",
              "default": null,
              "required": true,
              "displayType": "simple string",
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "isString": true,
              "possibleValues": [
                "ATR",
                "Traditional"
              ]
            },
            {
              "name": "param",
              "desc": "ATR Length if `style` is equal to 'ATR', or Box Size if `style` is equal to 'Traditional'.",
              "default": null,
              "required": true,
              "displayType": "simple int|float",
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            },
            {
              "name": "request_wicks",
              "desc": "Specifies if wick values are returned for Renko bricks. When \" + addInternalLineNotTr(\"op\", \"true\", \"true\") + \", \" + addInternalLineNotTr(\"var\", \"high\", \"high\") + \" and \" + addInternalLineNotTr(\"var\", \"low\", \"low\") + \" values requested from a symbol using the ticker formed by this function will include wick values when they are present.  \nWhen \" + addInternalLineNotTr(\"op\", \"false\", \"false\") + \", \" + addInternalLineNotTr(\"var\", \"high\", \"high\") + \" and \" + addInternalLineNotTr(\"var\", \"low\", \"low\") + \" will always be equal to either \" + addInternalLineNotTr(\"var\", \"open\", \"open\") + \" or \" + addInternalLineNotTr(\"var\", \"close\", \"close\") + \".  \nOptional. The default is \" + addInternalLineNotTr(\"op\", \"false\", \"false\") + \".  \nA detailed explanation of how Renko wicks are calculated can be found in our [Help Center](https://www.tradingview.com/support/solutions/43000481040-what-do-renko-wicks-mean/).",
              "default": "false",
              "required": false,
              "displayType": "simple bool",
              "allowedTypeIDs": [
                "simple bool",
                "input bool",
                "const bool"
              ],
              "possibleValues": [
                "true",
                "false"
              ]
            },
            {
              "name": "source",
              "desc": "The source used to calculate bricks. Optional.  \nPossible values: \"Close\", \"OHLC\".  \nThe default is \"Close\".",
              "default": "Close",
              "required": false,
              "displayType": "simple string",
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "isString": true,
              "possibleValues": [
                "Close",
                "OHLC"
              ]
            }
          ],
          "syntax": "ticker.renko(symbol, style, param, request_wicks, source) → simple string",
          "returns": "String value of ticker id, that can be supplied to [request.security](#fun_request.security) function.",
          "seeAlso": [
            "[syminfo.tickerid](#var_syminfo.tickerid)",
            "[syminfo.ticker](#var_syminfo.ticker)",
            "[request.security](#fun_request.security)",
            "[ticker.heikinashi](#fun_ticker.heikinashi)",
            "[ticker.linebreak](#fun_ticker.linebreak)",
            "[ticker.kagi](#fun_ticker.kagi)",
            "[ticker.pointfigure](#fun_ticker.pointfigure)"
          ],
          "examples": "//@version=5\nindicator(\"ticker.renko\", overlay=true) \nrenko_tickerid = ticker.renko(syminfo.tickerid, \"ATR\", 10)\nrenko_close = request.security(renko_tickerid, timeframe.period, close)\nplot(renko_close)",
          "returnedType": "string",
          "detailedDesc": [
            {
              "desc": "",
              "examples": "//@version=5\nindicator(\"Renko candles\", overlay=false)\nrenko_tickerid = ticker.renko(syminfo.tickerid, \"ATR\", 10)\n[renko_open, renko_high, renko_low, renko_close] = request.security(renko_tickerid, timeframe.period, [open, high, low, close])\nplotcandle(renko_open, renko_high, renko_low, renko_close, color = renko_close > renko_open ? color.green : color.red)"
            }
          ],
          "returnedTypes": [
            "simple string",
            "input string",
            "const string"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "ticker.linebreak",
          "desc": "Creates a ticker identifier for requesting Line Break values.",
          "args": [
            {
              "name": "symbol",
              "desc": "Symbol ticker identifier.",
              "default": null,
              "required": true,
              "displayType": "simple string",
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "number_of_lines",
              "desc": "Number of line.",
              "default": null,
              "required": true,
              "displayType": "simple int",
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "ticker.linebreak(symbol, number_of_lines) → simple string",
          "returns": "String value of ticker id, that can be supplied to [request.security](#fun_request.security) function.",
          "seeAlso": [
            "[syminfo.tickerid](#var_syminfo.tickerid)",
            "[syminfo.ticker](#var_syminfo.ticker)",
            "[request.security](#fun_request.security)",
            "[ticker.heikinashi](#fun_ticker.heikinashi)",
            "[ticker.renko](#fun_ticker.renko)",
            "[ticker.kagi](#fun_ticker.kagi)",
            "[ticker.pointfigure](#fun_ticker.pointfigure)"
          ],
          "examples": "//@version=5\nindicator(\"ticker.linebreak\", overlay=true) \nlinebreak_tickerid = ticker.linebreak(syminfo.tickerid, 3)\nlinebreak_close = request.security(linebreak_tickerid, timeframe.period, close)\nplot(linebreak_close)",
          "returnedType": "string",
          "returnedTypes": [
            "simple string",
            "input string",
            "const string"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "ticker.kagi",
          "desc": "Creates a ticker identifier for requesting Kagi values.",
          "args": [
            {
              "name": "symbol",
              "desc": "Symbol ticker identifier.",
              "default": null,
              "required": true,
              "displayType": "simple string",
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "syminfo.tickerid",
                "syminfo.ticker"
              ]
            },
            {
              "name": "reversal",
              "desc": "Reversal amount (absolute price value).",
              "default": null,
              "required": true,
              "displayType": "simple int|float",
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "ticker.kagi(symbol, reversal) → simple string",
          "returns": "String value of ticker id, that can be supplied to [request.security](#fun_request.security) function.",
          "seeAlso": [
            "[syminfo.tickerid](#var_syminfo.tickerid)",
            "[syminfo.ticker](#var_syminfo.ticker)",
            "[request.security](#fun_request.security)",
            "[ticker.heikinashi](#fun_ticker.heikinashi)",
            "[ticker.renko](#fun_ticker.renko)",
            "[ticker.linebreak](#fun_ticker.linebreak)",
            "[ticker.pointfigure](#fun_ticker.pointfigure)"
          ],
          "examples": "//@version=5\nindicator(\"ticker.kagi\", overlay=true) \nkagi_tickerid = ticker.kagi(syminfo.tickerid, 3)\nkagi_close = request.security(kagi_tickerid, timeframe.period, close)\nplot(kagi_close)",
          "returnedType": "string",
          "returnedTypes": [
            "simple string",
            "input string",
            "const string"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "ticker.pointfigure",
          "desc": "Creates a ticker identifier for requesting Point & Figure values.",
          "args": [
            {
              "name": "symbol",
              "desc": "Symbol ticker identifier.",
              "default": null,
              "required": true,
              "displayType": "simple string",
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "source",
              "desc": "The source for calculating Point & Figure. Possible values are: 'hl', 'close'.",
              "default": null,
              "required": true,
              "displayType": "simple string",
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "isString": true,
              "possibleValues": [
                "\"hl\"",
                "\"close\""
              ]
            },
            {
              "name": "style",
              "desc": "Box Size Assignment Method: 'ATR', 'Traditional'.",
              "default": null,
              "required": true,
              "displayType": "simple string",
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "isString": true,
              "possibleValues": [
                "ATR",
                "Traditional"
              ]
            },
            {
              "name": "param",
              "desc": "ATR Length if `style` is equal to 'ATR', or Box Size if `style` is equal to 'Traditional'.",
              "default": null,
              "required": true,
              "displayType": "simple int|float",
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            },
            {
              "name": "reversal",
              "desc": "Reversal amount.",
              "default": null,
              "required": true,
              "displayType": "simple int",
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "ticker.pointfigure(symbol, source, style, param, reversal) → simple string",
          "returns": "String value of ticker id, that can be supplied to [request.security](#fun_request.security) function.",
          "seeAlso": [
            "[syminfo.tickerid](#var_syminfo.tickerid)",
            "[syminfo.ticker](#var_syminfo.ticker)",
            "[request.security](#fun_request.security)",
            "[ticker.heikinashi](#fun_ticker.heikinashi)",
            "[ticker.renko](#fun_ticker.renko)",
            "[ticker.linebreak](#fun_ticker.linebreak)",
            "[ticker.kagi](#fun_ticker.kagi)"
          ],
          "examples": "//@version=5\nindicator(\"ticker.pointfigure\", overlay=true) \npnf_tickerid = ticker.pointfigure(syminfo.tickerid, \"hl\", \"Traditional\", 1, 3)\npnf_close = request.security(pnf_tickerid, timeframe.period, close)\nplot(pnf_close)",
          "returnedType": "string",
          "returnedTypes": [
            "simple string",
            "input string",
            "const string"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "timestamp",
          "desc": "Function timestamp returns UNIX time of specified date and time.",
          "args": [
            {
              "name": "timezone",
              "desc": "Allows adjusting the returned value to a time zone specified in either UTC/GMT notation (e.g., \"UTC-5\", \"GMT+0530\") or as an IANA time zone database name (e.g., \"America/New_York\").  \nOptional. The default is [syminfo.timezone](#var_syminfo.timezone).",
              "default": "syminfo.timezone",
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "isString": true,
              "possibleValues": [
                "UTC",
                "GMT",
                "America/New_York",
                "Europe/London",
                "Asia/Tokyo"
              ]
            },
            {
              "name": "year",
              "desc": "Year.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "month",
              "desc": "Month.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "day",
              "desc": "Day.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "hour",
              "desc": "(Optional argument) Hour. Default is 0.",
              "default": "0",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "minute",
              "desc": "(Optional argument) Minute. Default is 0.",
              "default": "0",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                0,
                15,
                30,
                45,
                59
              ]
            },
            {
              "name": "second",
              "desc": "(Optional argument) Second. Default is 0.",
              "default": "0",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                0,
                15,
                30,
                45,
                59
              ]
            },
            {
              "name": "dateString",
              "desc": "A string containing the date and, optionally, the time and time zone. Its format must comply with either the [IETF RFC 2822](https://tools.ietf.org/html/rfc2822#section-3.3) or [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) standards (\"DD MMM YYYY hh:mm:ss ±hhmm\" or \"YYYY-MM-DDThh:mm:ss±hh:mm\", so \"20 Feb 2020\" or \"2020-02-20\").  \nIf no time is supplied, \"00:00\" is used.  \nIf no time zone is supplied, GMT+0 will be used.  \nNote that this diverges from the usual behavior of the function where it returns time in the exchange\\`s timezone.",
              "default": null,
              "required": true,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "timestamp(dateString) → const int\ntimestamp(timezone, year, month, day, hour, minute, second) → series int",
          "remarks": "UNIX time is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970.",
          "returns": "UNIX time.",
          "seeAlso": [
            "[time](#fun_time) (function) [time](#var_time) (variable) [timenow](#var_timenow) (variable) [syminfo.timezone](#var_syminfo.timezone) (variable)"
          ],
          "examples": "//@version=5\nindicator(\"timestamp\")\nplot(timestamp(2016, 01, 19, 09, 30), linewidth=3, color=color.green)\nplot(timestamp(syminfo.timezone, 2016, 01, 19, 09, 30), color=color.blue)\nplot(timestamp(2016, 01, 19, 09, 30), color=color.yellow)\nplot(timestamp(\"GMT+6\", 2016, 01, 19, 09, 30))\nplot(timestamp(2019, 06, 19, 09, 30, 15), color=color.lime)\nplot(timestamp(\"GMT+3\", 2019, 06, 19, 09, 30, 15), color=color.fuchsia)\nplot(timestamp(\"Feb 01 2020 22:10:05\"))\nplot(timestamp(\"2011-10-10T14:48:00\"))\nplot(timestamp(\"04 Dec 1995 00:12:00 GMT+5\"))",
          "returnedType": "int",
          "returnedTypes": [
            "const int",
            "simple int",
            "input int",
            "series int"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "ta.cross",
          "args": [
            {
              "name": "source1",
              "desc": "First data series.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            },
            {
              "name": "source2",
              "desc": "Second data series.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "ta.cross(source1, source2) → series bool",
          "returns": "true if two series have crossed each other, otherwise false.",
          "seeAlso": [
            "[ta.change](#fun_ta.change)"
          ],
          "returnedType": "bool",
          "returnedTypes": [
            "series bool",
            "simple bool",
            "input bool",
            "const bool"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "ta.cog",
          "desc": "The cog (center of gravity) is an indicator based on statistics and the Fibonacci golden ratio.",
          "args": [
            {
              "name": "source",
              "desc": "Series of values to process.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "open",
                "high",
                "low",
                "close",
                "hl2",
                "hlc3",
                "ohlc4"
              ]
            },
            {
              "name": "length",
              "desc": "Number of bars (length).",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "5",
                "10",
                "14",
                "20",
                "50"
              ]
            }
          ],
          "syntax": "ta.cog(source, length) → series float",
          "remarks": "`na` values in the `source` series are ignored.",
          "returns": "Center of Gravity.",
          "seeAlso": [
            "[ta.stoch](#fun_ta.stoch)"
          ],
          "examples": "//@version=5\nindicator(\"ta.cog\", overlay=true) \nplot(ta.cog(close, 10))\n\n// the same on pine\npine_cog(source, length) =>\n    sum = math.sum(source, length)\n    num = 0.0\n    for i = 0 to length - 1\n        price = source[i]\n        num := num + price * (i + 1)\n    -num / sum\n\nplot(pine_cog(close, 10))",
          "returnedType": "float",
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "ta.alma",
          "desc": "Arnaud Legoux Moving Average. It uses Gaussian distribution as weights for moving average.",
          "args": [
            {
              "name": "series",
              "desc": "Series of values to process.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "open",
                "high",
                "low",
                "close",
                "volume"
              ]
            },
            {
              "name": "length",
              "desc": "Number of bars (length).",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                9,
                14,
                20,
                50,
                200
              ]
            },
            {
              "name": "offset",
              "desc": "Controls tradeoff between smoothness (closer to 1) and responsiveness (closer to 0).",
              "default": null,
              "required": true,
              "displayType": "simple int|float",
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            },
            {
              "name": "sigma",
              "desc": "Changes the smoothness of ALMA. The larger sigma the smoother ALMA.",
              "default": null,
              "required": true,
              "displayType": "simple int|float",
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            },
            {
              "name": "floor",
              "desc": "An optional parameter. Specifies whether the offset calculation is floored before ALMA is calculated.  \nDefault value is false.",
              "default": "false",
              "required": true,
              "displayType": "simple bool",
              "allowedTypeIDs": [
                "simple bool",
                "input bool",
                "const bool"
              ],
              "possibleValues": [
                "true",
                "false"
              ]
            }
          ],
          "syntax": "ta.alma(series, length, offset, sigma, floor) → series float",
          "remarks": "`na` values in the `source` series are included in calculations and will produce an `na` result.",
          "returns": "Arnaud Legoux Moving Average.",
          "seeAlso": [
            "[ta.sma](#fun_ta.sma)",
            "[ta.ema](#fun_ta.ema)",
            "[ta.rma](#fun_ta.rma)",
            "[ta.wma](#fun_ta.wma)",
            "[ta.vwma](#fun_ta.vwma)",
            "[ta.swma](#fun_ta.swma)"
          ],
          "examples": "//@version=5\nindicator(\"ta.alma\", overlay=true) \nplot(ta.alma(close, 9, 0.85, 6))\n\n// same on pine, but much less efficient\npine_alma(series, windowsize, offset, sigma) =>\n    m = offset * (windowsize - 1)\n    //m = math.floor(offset * (windowsize - 1)) // Used as m when math.floor=true\n    s = windowsize / sigma\n    norm = 0.0\n    sum = 0.0\n    for i = 0 to windowsize - 1\n        weight = math.exp(-1 * math.pow(i - m, 2) / (2 * math.pow(s, 2)))\n        norm := norm + weight\n        sum := sum + series[windowsize - i - 1] * weight\n    sum / norm\nplot(pine_alma(close, 9, 0.85, 6))",
          "returnedType": "float",
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "ta.cmo",
          "desc": "Chande Momentum Oscillator. Calculates the difference between the sum of recent gains and the sum of recent losses and then divides the result by the sum of all price movement over the same period.",
          "args": [
            {
              "name": "series",
              "desc": "Series of values to process.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "open",
                "high",
                "low",
                "close",
                "volume"
              ]
            },
            {
              "name": "length",
              "desc": "Number of bars (length).",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                5,
                10,
                14,
                20,
                30
              ]
            }
          ],
          "syntax": "ta.cmo(series, length) → series float",
          "remarks": "`na` values in the `source` series are ignored.",
          "returns": "Chande Momentum Oscillator.",
          "seeAlso": [
            "[ta.rsi](#fun_ta.rsi)",
            "[ta.stoch](#fun_ta.stoch)",
            "[math.sum](#fun_math.sum)"
          ],
          "examples": "//@version=5\nindicator(\"ta.cmo\")\nplot(ta.cmo(close, 5), color=color.yellow)\n\n// the same on pine\nf_cmo(src, length) =>\n    float mom = ta.change(src)\n    float sm1 = math.sum((mom >= 0) ? mom : 0.0, length)\n    float sm2 = math.sum((mom >= 0) ? 0.0 : -mom, length)\n    100 * (sm1 - sm2) / (sm1 + sm2)\n\nplot(f_cmo(close, 5))",
          "returnedType": "float",
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "ta.mfi",
          "desc": "Money Flow Index. The Money Flow Index (MFI) is a technical oscillator that uses price and volume for identifying overbought or oversold conditions in an asset.",
          "args": [
            {
              "name": "series",
              "desc": "Series of values to process.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            },
            {
              "name": "length",
              "desc": "Number of bars (length).",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                7,
                14,
                20,
                50,
                100
              ]
            }
          ],
          "syntax": "ta.mfi(series, length) → series float",
          "remarks": "`na` values in the `source` series are ignored; the function calculates on the `length` quantity of non-`na` values.",
          "returns": "Money Flow Index.",
          "seeAlso": [
            "[ta.rsi](#fun_ta.rsi)",
            "[math.sum](#fun_math.sum)"
          ],
          "examples": "//@version=5\nindicator(\"Money Flow Index\")\n\nplot(ta.mfi(hlc3, 14), color=color.yellow)\n\n// the same on pine\npine_mfi(src, length) =>\n    float upper = math.sum(volume * (ta.change(src) <= 0.0 ? 0.0 : src), length)\n    float lower = math.sum(volume * (ta.change(src) >= 0.0 ? 0.0 : src), length)\n    mfi = 100.0 - (100.0 / (1.0 + upper / lower))\n    mfi\n\nplot(pine_mfi(hlc3, 14))",
          "returnedType": "float",
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "ta.wpr",
          "desc": "Williams %R. The oscillator shows the current closing price in relation to the high and low of the past 'length' bars.",
          "args": [
            {
              "name": "length",
              "desc": "Number of bars.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "5",
                "10",
                "14",
                "20",
                "50"
              ]
            }
          ],
          "syntax": "ta.wpr(length) → series float",
          "remarks": "`na` values in the `source` series are ignored.",
          "returns": "Williams %R.",
          "seeAlso": [
            "[ta.mfi](#fun_ta.mfi)",
            "[ta.cmo](#fun_ta.cmo)"
          ],
          "examples": "//@version=5\nindicator(\"Williams %R\", shorttitle=\"%R\", format=format.price, precision=2)\nplot(ta.wpr(14), title=\"%R\", color=color.new(#ff6d00, 0))",
          "returnedType": "float",
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "ta.bb",
          "desc": "Bollinger Bands. A Bollinger Band is a technical analysis tool defined by a set of lines plotted two standard deviations (positively and negatively) away from a simple moving average (SMA) of the security\\`s price, but can be adjusted to user preferences.",
          "args": [
            {
              "name": "series",
              "desc": "Series of values to process.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "open",
                "high",
                "low",
                "close",
                "hl2",
                "hlc3",
                "ohlc4"
              ]
            },
            {
              "name": "length",
              "desc": "Number of bars (length).",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                14,
                20,
                50,
                100,
                200
              ]
            },
            {
              "name": "mult",
              "desc": "Standard deviation factor.",
              "default": null,
              "required": true,
              "displayType": "simple int|float",
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                1.0,
                2.0,
                2.5,
                3.0,
                3.5
              ]
            }
          ],
          "syntax": "ta.bb(series, length, mult) → [series float, series float, series float]",
          "remarks": "`na` values in the `source` series are ignored; the function calculates on the `length` quantity of non-`na` values.",
          "returns": "Bollinger Bands.",
          "seeAlso": [
            "[ta.sma](#fun_ta.sma)",
            "[ta.stdev](#fun_ta.stdev)",
            "[ta.kc](#fun_ta.kc)"
          ],
          "examples": "//@version=5\nindicator(\"ta.bb\")\n\n[middle, upper, lower] = ta.bb(close, 5, 4)\nplot(middle, color=color.yellow)\nplot(upper, color=color.yellow)\nplot(lower, color=color.yellow)\n\n// the same on pine\nf_bb(src, length, mult) =>\n    float basis = ta.sma(src, length)\n    float dev = mult * ta.stdev(src, length)\n    [basis, basis + dev, basis - dev]\n\n[pineMiddle, pineUpper, pineLower] = f_bb(close, 5, 4)\n\nplot(pineMiddle)\nplot(pineUpper)\nplot(pineLower)",
          "returnedType": "[float, float, float]",
          "returnedTypes": [
            "[series float, series float, series float]"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "ta.bbw",
          "desc": "Bollinger Bands Width. The Bollinger Band Width is the difference between the upper and the lower Bollinger Bands divided by the middle band.",
          "args": [
            {
              "name": "series",
              "desc": "Series of values to process.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "close",
                "open",
                "high",
                "low",
                "hl2",
                "hlc3",
                "ohlc4"
              ]
            },
            {
              "name": "length",
              "desc": "Number of bars (length).",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                9,
                14,
                20,
                50,
                200
              ]
            },
            {
              "name": "mult",
              "desc": "Standard deviation factor.",
              "default": null,
              "required": true,
              "displayType": "simple int|float",
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                1.0,
                2.0,
                2.5,
                3.0,
                3.5
              ]
            }
          ],
          "syntax": "ta.bbw(series, length, mult) → series float",
          "remarks": "`na` values in the `source` series are ignored; the function calculates on the `length` quantity of non-`na` values.",
          "returns": "Bollinger Bands Width.",
          "seeAlso": [
            "[ta.bb](#fun_ta.bb)",
            "[ta.sma](#fun_ta.sma)",
            "[ta.stdev](#fun_ta.stdev)"
          ],
          "examples": "//@version=5\nindicator(\"ta.bbw\")\n\nplot(ta.bbw(close, 5, 4), color=color.yellow)\n\n// the same on pine\nf_bbw(src, length, mult) =>\n    float basis = ta.sma(src, length)\n    float dev = mult * ta.stdev(src, length)\n    ((basis + dev) - (basis - dev)) / basis\n\nplot(f_bbw(close, 5, 4))",
          "returnedType": "float",
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "ta.kc",
          "desc": "Keltner Channels. Keltner channel is a technical analysis indicator showing a central moving average line plus channel lines at a distance above and below.",
          "args": [
            {
              "name": "series",
              "desc": "Series of values to process.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "close",
                "open",
                "high",
                "low",
                "volume"
              ]
            },
            {
              "name": "length",
              "desc": "Number of bars (length).",
              "default": null,
              "required": true,
              "displayType": "simple int",
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "5",
                "10",
                "14",
                "20",
                "50"
              ]
            },
            {
              "name": "mult",
              "desc": "Standard deviation factor.",
              "default": null,
              "required": true,
              "displayType": "simple int|float",
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "1.0",
                "1.5",
                "2.0",
                "2.5",
                "3.0"
              ]
            },
            {
              "name": "useTrueRange",
              "desc": "An optional parameter. Specifies if True Range is used; default is true. If the value is false, the range will be calculated with the expression (high - low).",
              "default": "true",
              "required": true,
              "displayType": "simple bool",
              "allowedTypeIDs": [
                "simple bool",
                "input bool",
                "const bool"
              ],
              "possibleValues": [
                "true",
                "false"
              ]
            }
          ],
          "syntax": "ta.kc(series, length, mult, useTrueRange) → [series float, series float, series float]",
          "remarks": "`na` values in the `source` series are ignored; the function calculates on the `length` quantity of non-`na` values.",
          "returns": "Keltner Channels.",
          "seeAlso": [
            "[ta.ema](#fun_ta.ema)",
            "[ta.atr](#fun_ta.atr)",
            "[ta.bb](#fun_ta.bb)"
          ],
          "examples": "//@version=5\nindicator(\"ta.kc\")\n\n[middle, upper, lower] = ta.kc(close, 5, 4)\nplot(middle, color=color.yellow)\nplot(upper, color=color.yellow)\nplot(lower, color=color.yellow)\n\n\n// the same on pine\nf_kc(src, length, mult, useTrueRange) =>\n    float basis = ta.ema(src, length)\n    float span = (useTrueRange) ? ta.tr : (high - low)\n    float rangeEma = ta.ema(span, length)\n    [basis, basis + rangeEma * mult, basis - rangeEma * mult]\n    \n[pineMiddle, pineUpper, pineLower] = f_kc(close, 5, 4, true)\n\nplot(pineMiddle)\nplot(pineUpper)\nplot(pineLower)",
          "returnedType": "[float, float, float]",
          "returnedTypes": [
            "[series float, series float, series float]"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "ta.kcw",
          "desc": "Keltner Channels Width. The Keltner Channels Width is the difference between the upper and the lower Keltner Channels divided by the middle channel.",
          "args": [
            {
              "name": "series",
              "desc": "Series of values to process.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "close",
                "open",
                "high",
                "low",
                "volume"
              ]
            },
            {
              "name": "length",
              "desc": "Number of bars (length).",
              "default": null,
              "required": true,
              "displayType": "simple int",
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                14,
                20,
                50,
                100,
                200
              ]
            },
            {
              "name": "mult",
              "desc": "Standard deviation factor.",
              "default": null,
              "required": true,
              "displayType": "simple int|float",
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "1.0",
                "1.5",
                "2.0",
                "2.5",
                "3.0"
              ]
            },
            {
              "name": "useTrueRange",
              "desc": "An optional parameter. Specifies if True Range is used; default is true. If the value is false, the range will be calculated with the expression (high - low).",
              "default": "false",
              "required": true,
              "displayType": "simple bool",
              "allowedTypeIDs": [
                "simple bool",
                "input bool",
                "const bool"
              ],
              "possibleValues": [
                "true",
                "false"
              ]
            }
          ],
          "syntax": "ta.kcw(series, length, mult, useTrueRange) → series float",
          "remarks": "`na` values in the `source` series are ignored; the function calculates on the `length` quantity of non-`na` values.",
          "returns": "Keltner Channels Width.",
          "seeAlso": [
            "[ta.kc](#fun_ta.kc)",
            "[ta.ema](#fun_ta.ema)",
            "[ta.atr](#fun_ta.atr)",
            "[ta.bb](#fun_ta.bb)"
          ],
          "examples": "//@version=5\nindicator(\"ta.kcw\")\n\nplot(ta.kcw(close, 5, 4), color=color.yellow)\n\n// the same on pine\nf_kcw(src, length, mult, useTrueRange) =>\n    float basis = ta.ema(src, length)\n    float span = (useTrueRange) ? ta.tr : (high - low)\n    float rangeEma = ta.ema(span, length)\n    \n    ((basis + rangeEma * mult) - (basis - rangeEma * mult)) / basis\n\nplot(f_kcw(close, 5, 4, true))",
          "returnedType": "float",
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "str.format",
          "desc": "Converts the formatting string and value(s) into a formatted string. The formatting string can contain literal text and one placeholder in curly braces {} for each value to be formatted. Each placeholder consists of the index of the required argument (beginning at 0) that will replace it, and an optional format specifier. The index represents the position of that argument in the str.format argument list.",
          "args": [
            {
              "name": "formatString",
              "desc": "Format string.",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "arg0, arg1, ...",
              "desc": "Values to format.",
              "required": true,
              "displayType": "array<[int|float|bool|string]>|na ",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float",
                "series bool",
                "simple bool",
                "input bool",
                "const bool",
                "series string",
                "simple string",
                "input string",
                "const string",
                "array<int>",
                "array<float>",
                "array<bool>",
                "array<string>"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "str.format(formatString, arg0, arg1, ...) → series string",
          "remarks": "Any curly braces within an unquoted pattern must be balanced. For example, \"ab {0} de\" and \"ab '}' de\" are valid patterns, but \"ab {0'}' de\", \"ab } de\" and \"''{''\" are not.",
          "returns": "The formatted string.",
          "examples": "//@version=5\nindicator(\"str.format\", overlay=true)\n// The format specifier inside the curly braces accepts certain modifiers:\n// - Specify the number of decimals to display:\ns1 = str.format(\"{0, number, #.#}\", 1.34) // returns: 1.3\nlabel.new(bar_index, close, text=s1)\n// - Round a float value to an integer:\ns2 = str.format(\"{0, number, integer}\", 1.34) // returns: 1\nlabel.new(bar_index - 1, close, text=s2)\n// - Display a number in currency:\ns3 = str.format(\"{0, number, currency}\", 1.34) // returns: $1.34\nlabel.new(bar_index - 2, close, text=s3)\n// - Display a number as a percentage:\ns4 = str.format(\"{0, number, percent}\", 0.5) // returns: 50%\nlabel.new(bar_index - 3, close, text=s4)\n// EXAMPLES WITH SEVERAL ARGUMENTS\n// returns: Number 1 is not equal to 4\ns5 = str.format(\"Number {0} is not {1} to {2}\", 1, \"equal\", 4)\nlabel.new(bar_index - 4, close, text=s5)\n// returns: 1.34 != 1.3\ns6 = str.format(\"{0} != {0, number, #.#}\", 1.34)\nlabel.new(bar_index - 5, close, text=s6)\n// returns: 1 is equal to 1, but 2 is equal to 2\ns7 = str.format(\"{0, number, integer} is equal to 1, but {1, number, integer} is equal to 2\", 1.34, 1.52)\nlabel.new(bar_index - 6, close, text=s7)\n// returns: The cash turnover amounted to $1, 340, 000.00\ns8 = str.format(\"The cash turnover amounted to {0, number, currency}\", 1340000)\nlabel.new(bar_index - 7, close, text=s8)\n// returns: Expected return is 10% - 20%\ns9 = str.format(\"Expected return is {0, number, percent} - {1, number, percent}\", 0.1, 0.2)\nlabel.new(bar_index - 8, close, text=s9)",
          "returnedType": "string",
          "returnedTypes": [
            "simple string",
            "input string",
            "const string",
            "series string"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "str.format_time",
          "desc": "Converts the `time` timestamp into a string formatted according to `format` and `timezone`.",
          "args": [
            {
              "name": "time",
              "desc": "UNIX time, in milliseconds.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "format",
              "desc": "A format string specifying the date/time representation of the `time` in the returned string.  \nAll letters used in the string, except those escaped by single quotation marks `'`, are considered formatting tokens and will be used as a formatting instruction.  \nRefer to the Remarks section for a list of the most useful tokens.  \nOptional. The default is \"yyyy-MM-dd'T'HH:mm:ssZ\", which represents the ISO 8601 standard.",
              "default": "\"yyyy-MM-dd'T'HH:mm:ssZ\"",
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "isString": true,
              "possibleValues": [
                "yyyy-MM-dd HH:mm",
                "MM/dd/yyyy HH:mm:ss",
                "dd-MM-yyyy",
                "HH:mm:ss",
                "yyyy-MM-ddHH:mm:ssZ"
              ]
            },
            {
              "name": "timezone",
              "desc": "Allows adjusting the returned value to a time zone specified in either UTC/GMT notation (e.g., \"UTC-5\", \"GMT+0530\") or as an [IANA time zone database name](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones) (e.g., \"America/New_York\").  \nOptional. The default is [syminfo.timezone](#var_syminfo.timezone).",
              "default": "syminfo.timezone",
              "required": false,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "isString": true,
              "possibleValues": [
                "UTC",
                "GMT",
                "America/New_York",
                "Europe/London",
                "Asia/Tokyo"
              ]
            }
          ],
          "syntax": "str.format_time(time, format, timezone) → series string",
          "remarks": "The `M`, `d`, `h`, `H`, `m` and `s` tokens can all be doubled to generate leading zeroes.  \nFor example, the month of January will display as `1` with `M`, or `01` with `MM`.\n\nThe most frequently used formatting tokens are:\n\ny - Year.  \nUse `yy` to output the last two digits of the year or `yyyy` to output all four.  \nYear 2000 will be `00` with `yy` or `2000` with `yyyy`.\nM - Month.  \nNot to be confused with lowercase `m`, which stands for minute.\nd - Day of the month.\na - AM/PM postfix.\nh - Hour in the 12-hour format.  \nThe last hour of the day will be `11` in this format.\nH - Hour in the 24-hour format.  \nThe last hour of the day will be `23` in this format.\nm - Minute.\ns - Second.\nS - Fractions of a second.\nZ - Timezone, the HHmm offset from UTC, preceded by either `+` or `-`.",
          "returns": "The formatted string.",
          "examples": "//@version=5\nindicator(\"str.format_time\")\nif timeframe.change(\"1D\")\n\tformattedTime = str.format_time(time, \"yyyy-MM-dd HH:mm\", syminfo.timezone)\n\tlabel.new(bar_index, high, formattedTime)",
          "returnedType": "string",
          "returnedTypes": [
            "series string",
            "simple string",
            "input string",
            "const string"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "str.tostring",
          "args": [
            {
              "name": "value",
              "desc": "Value or array ID whose elements are converted to a string.",
              "default": null,
              "required": true,
              "displayType": "series matrix|array<int|float|bool|string>",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float",
                "series bool",
                "simple bool",
                "input bool",
                "const bool",
                "series string",
                "simple string",
                "input string",
                "const string",
                "matrix<float>",
                "matrix<int>",
                "matrix<string>",
                "matrix<bool>",
                "array<int>",
                "array<float>",
                "array<bool>",
                "array<string>"
              ],
              "possibleValues": null
            },
            {
              "name": "format",
              "desc": "Format string. Accepts these format.* constants: [format.mintick](#var_format.mintick), [format.percent](#var_format.percent), [format.volume](#var_format.volume).  \nOptional. The default value is '#.##########'.",
              "default": "'#.##########'",
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "format.mintick",
                "format.percent",
                "format.volume"
              ]
            }
          ],
          "syntax": "str.tostring(value, format) → series string",
          "remarks": [
            "The formatting of float values will also round those values when necessary, e.g. str.tostring(3.99, '#') will return \"4\".",
            "To display trailing zeros, use '0' instead of '#'. For example, '#.000'.",
            "When using [format.mintick](#var_format.mintick), the value will be rounded to the nearest number that can be divided by [syminfo.mintick](#var_syminfo.mintick) without the remainder. The string is returned with trailing zeroes.",
            "If the x argument is a string, the same string value will be returned.",
            "Bool type arguments return \"true\" or \"false\".",
            "When x is na, the function returns \"NaN\"."
          ],
          "returns": "The string representation of the `value` argument.\nIf the `value` argument is a string, it is returned as is.\nWhen the `value` is na, the function returns the string \"NaN\".",
          "returnedType": "string",
          "returnedTypes": [
            "series string",
            "simple string",
            "input string",
            "const string"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "str.tonumber",
          "desc": "Converts a value represented in `string` to its \"float\" equivalent.",
          "args": [
            {
              "name": "string",
              "desc": "String containing the representation of an integer or floating point value.",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "str.tonumber(string) → series float",
          "returns": "A \"float\" equivalent of the value in `string`. If the value is not a properly formed integer or floating point value, the function returns [na](#var_na).",
          "returnedType": "float",
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "str.replace_all",
          "desc": "Replaces each occurrence of the target string in the source string with the replacement string.",
          "args": [
            {
              "name": "source",
              "desc": "Source string.",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "target",
              "desc": "String to be replaced.",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "replacement",
              "desc": "String to be substituted for each occurrence of target string.",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "str.replace_all(source, target, replacement) → series string",
          "returns": "Processed string.",
          "returnedType": "string",
          "returnedTypes": [
            "simple string",
            "input string",
            "const string",
            "series string"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "str.contains",
          "desc": "Returns true if the `source` string contains the `str` substring, false otherwise.",
          "args": [
            {
              "name": "source",
              "desc": "Source string.",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "str",
              "desc": "The substring to search for.",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "str.contains(source, str) → series bool",
          "returns": "True if the `str` was found in the `source` string, false otherwise.",
          "seeAlso": [
            "[str.pos](#fun_str.pos)",
            "[str.match](#fun_str.match)"
          ],
          "examples": "//@version=5\nindicator(\"str.contains\")\n// If the current chart is a continuous futures chart, e.g “BTC1!”, then the function will return true, false otherwise.\nvar isFutures = str.contains(syminfo.tickerid, \"!\")\nplot(isFutures ? 1 : 0)",
          "returnedType": "bool",
          "returnedTypes": [
            "const bool",
            "simple bool",
            "input bool",
            "series bool"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "str.substring",
          "desc": "Returns a new string that is a substring of the `source` string. The substring begins with the character at the index specified by `begin_pos` and extends to 'end_pos - 1' of the `source` string.",
          "args": [
            {
              "name": "source",
              "desc": "Source string from which to extract the substring.",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "begin_pos",
              "desc": "The beginning position of the extracted substring. It is inclusive (the extracted substring includes the character at that position).",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "end_pos",
              "desc": "The ending position. It is exclusive (the extracted string does NOT include that position\\`s character).  \nOptional. The default is the length of the `source` string.",
              "default": "str.length(source)",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "str.substring(source, begin_pos, end_pos) → series string",
          "remarks": "Strings indexing starts from 0. If `begin_pos` is equal to `end_pos`, the function returns an empty string.",
          "returns": "The substring extracted from the source string.",
          "seeAlso": [
            "[str.contains](#fun_str.contains)",
            "[str.pos](#fun_str.pos)",
            "[str.match](#fun_str.match)"
          ],
          "examples": "//@version=5\nindicator(\"str.substring\", overlay = true)\nsym= input.symbol(\"NASDAQ:AAPL\")\npos = str.pos(sym, \":\")  // Get position of \":\" character\ntkr= str.substring(sym, pos+1) // \"AAPL\"\nif barstate.islastconfirmedhistory\n\tlabel.new(bar_index, high, text = tkr)",
          "returnedType": "string",
          "returnedTypes": [
            "const string",
            "simple string",
            "input string",
            "series string"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "str.replace",
          "desc": "Returns a new string with the Nth occurrence of the `target` string replaced by the `replacement` string, where N is specified in `occurrence`.",
          "args": [
            {
              "name": "source",
              "desc": "Source string.",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "target",
              "desc": "String to be replaced.",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "replacement",
              "desc": "String to be inserted instead of the target string.",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "occurrence",
              "desc": "N-th occurrence of the target string to replace. Indexing starts at 0 for the first match.  \nOptional. Default value is 0.",
              "default": "0",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "str.replace(source, target, replacement, occurrence) → series string",
          "returns": "Processed string.",
          "seeAlso": [
            "[str.replace_all](#fun_str.replace_all)",
            "[str.match](#fun_str.match)"
          ],
          "examples": "//@version=5\nindicator(\"str.replace\")\nvar source = \"FTX:BTCUSD / FTX:BTCEUR\"\n\n// Replace first occurrence of \"FTX\" with \"BINANCE\" replacement string\nvar newSource = str.replace(source, \"FTX\",  \"BINANCE\", 0)\n\nif barstate.islastconfirmedhistory\n\t// Display \"BINANCE:BTCUSD / FTX:BTCEUR\"\n\tlabel.new(bar_index, high, text = newSource)",
          "returnedType": "string",
          "returnedTypes": [
            "const string",
            "simple string",
            "input string",
            "series string"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "str.lower",
          "desc": "Returns a new string with all letters converted to lowercase.",
          "args": [
            {
              "name": "source",
              "desc": "String to be converted.",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "str.lower(source) → series string",
          "returns": "A new string with all letters converted to lowercase.",
          "seeAlso": [
            "[str.upper](#fun_str.upper)"
          ],
          "returnedType": "string",
          "returnedTypes": [
            "const string",
            "simple string",
            "input string",
            "series string"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "str.upper",
          "desc": "Returns a new string with all letters converted to uppercase.",
          "args": [
            {
              "name": "source",
              "desc": "String to be converted.",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "str.upper(source) → series string",
          "returns": "A new string with all letters converted to uppercase.",
          "seeAlso": [
            "[str.lower](#fun_str.lower)"
          ],
          "returnedType": "string",
          "returnedTypes": [
            "const string",
            "simple string",
            "input string",
            "series string"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "str.startswith",
          "desc": "Returns true if the `source` string starts with the substring specified in `str`, false otherwise.",
          "args": [
            {
              "name": "source",
              "desc": "Source string.",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "str",
              "desc": "The substring to search for.",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "str.startswith(source, str) → series bool",
          "returns": "True if the `source` string starts with the substring specified in `str`, false otherwise.",
          "seeAlso": [
            "[str.endswith](#fun_str.endswith)"
          ],
          "returnedType": "bool",
          "returnedTypes": [
            "const bool",
            "simple bool",
            "input bool",
            "series bool"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "str.endswith",
          "desc": "Returns true if the `source` string ends with the substring specified in `str`, false otherwise.",
          "args": [
            {
              "name": "source",
              "desc": "Source string.",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "str",
              "desc": "The substring to search for.",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "str.endswith(source, str) → series bool",
          "returns": "True if the `source` string ends with the substring specified in `str`, false otherwise.",
          "seeAlso": [
            "[str.startswith](#fun_str.startswith)"
          ],
          "returnedType": "bool",
          "returnedTypes": [
            "const bool",
            "simple bool",
            "input bool",
            "series bool"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "str.match",
          "desc": "Returns the new substring of the `source` string if it matches a `regex` regular expression, an empty string otherwise.",
          "args": [
            {
              "name": "source",
              "desc": "Source string.",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "regex",
              "desc": "The regular expression to which this string is to be matched.",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "str.match(source, regex) → series string",
          "remarks": "Function returns first occurrence of the [regular expression](https://en.wikipedia.org/wiki/Regular_expression#Perl_and_PCRE) in the `source` string.\nThe backslash \"\" symbol in the`regex` string needs to be escaped with additional backslash, e.g. \"\\\\d\" stands for regular expression \"\\d\".",
          "returns": "The new substring of the `source` string if it matches a `regex` regular expression, an empty string otherwise.",
          "seeAlso": [
            "[str.contains](#fun_str.contains)",
            "[str.substring](#fun_str.substring)"
          ],
          "examples": "//@version=5\nindicator(\"str.match\")\n\ns = input.string(\"It\\`s time to sell some NASDAQ:AAPL!\")\n\n// finding first substring that matches regular expression \"[\\w]+:[\\w]+\"\nvar string tickerid = str.match(s, \"[\\\\w]+:[\\\\w]+\")\n\nif barstate.islastconfirmedhistory\n\tlabel.new(bar_index, high, text = tickerid) // \"NASDAQ:AAPL\"",
          "returnedType": "string",
          "returnedTypes": [
            "simple string",
            "input string",
            "const string",
            "series string"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "str.pos",
          "desc": "Returns the position of the first occurrence of the `str` string in the `source` string, 'na' otherwise.",
          "args": [
            {
              "name": "source",
              "desc": "Source string.",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "str",
              "desc": "The substring to search for.",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "str.pos(source, str) → series int",
          "remarks": "Strings indexing starts at 0.",
          "returns": "Position of the `str` string in the `source` string.",
          "seeAlso": [
            "[str.contains](#fun_str.contains)",
            "[str.match](#fun_str.match)",
            "[str.substring](#fun_str.substring)"
          ],
          "returnedType": "int",
          "returnedTypes": [
            "const int",
            "simple int",
            "input int",
            "series int"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "str.split",
          "desc": "Divides a string into an array of substrings and returns its array id.",
          "args": [
            {
              "name": "string",
              "desc": "Source string.",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "separator",
              "desc": "The string separating each substring.",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "isString": true,
              "possibleValues": [
                "\\n",
                ",",
                ";",
                "|",
                "-",
                "_"
              ]
            }
          ],
          "syntax": "str.split(string, separator) → array<string>",
          "returns": "The id of an array of strings.",
          "returnedType": "array<string>",
          "returnedTypes": [
            "array<string>"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "str.length",
          "desc": "Returns an integer corresponding to the amount of chars in that string.",
          "args": [
            {
              "name": "string",
              "desc": "Source string.",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "str.length(string) → int",
          "returns": "The number of chars in source string.",
          "returnedType": "int",
          "returnedTypes": [
            "const int",
            "simple int",
            "input int",
            "series int"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "ta.percentile_nearest_rank",
          "desc": "Calculates percentile using method of Nearest Rank.",
          "args": [
            {
              "name": "source",
              "desc": "Series of values to process (source).",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "close",
                "open",
                "high",
                "low",
                "volume"
              ]
            },
            {
              "name": "length",
              "desc": "Number of bars back (length).",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "14",
                "50",
                "100",
                "200"
              ]
            },
            {
              "name": "percentage",
              "desc": "Percentage, a number from range 0..100.",
              "default": null,
              "required": true,
              "displayType": "simple int|float",
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "0",
                "25",
                "50",
                "75",
                "100"
              ]
            }
          ],
          "syntax": "ta.percentile_nearest_rank(source, length, percentage) → series float",
          "remarks": [
            "Using the Nearest Rank method on lengths less than 100 bars back can result in the same number being used for more than one percentile.",
            "A percentile calculated using the Nearest Rank method will always be a member of the input data set.",
            "The 100th percentile is defined to be the largest value in the input data set.",
            "`na` values in the `source` series are ignored."
          ],
          "returns": "P-th percentile of `source` series for `length` bars back.",
          "seeAlso": [
            "[ta.percentile_linear_interpolation](#fun_ta.percentile_linear_interpolation)",
            "http://en.wikipedia.org/wiki/Percentile#The_Nearest_Rank_method"
          ],
          "returnedType": "float",
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "ta.percentile_linear_interpolation",
          "desc": "Calculates percentile using method of linear interpolation between the two nearest ranks.",
          "args": [
            {
              "name": "source",
              "desc": "Series of values to process (source).",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "open",
                "high",
                "low",
                "close",
                "volume"
              ]
            },
            {
              "name": "length",
              "desc": "Number of bars back (length).",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "10",
                "20",
                "50",
                "100",
                "200"
              ]
            },
            {
              "name": "percentage",
              "desc": "Percentage, a number from range 0..100.",
              "default": null,
              "required": true,
              "displayType": "simple int|float",
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "10.0",
                "25.0",
                "50.0",
                "75.0",
                "90.0"
              ]
            }
          ],
          "syntax": "ta.percentile_linear_interpolation(source, length, percentage) → series float",
          "remarks": [
            "Note that a percentile calculated using this method will NOT always be a member of the input data set.",
            "`na` values in the `source` series are included in calculations and will produce an `na` result."
          ],
          "returns": "P-th percentile of `source` series for `length` bars back.",
          "seeAlso": [
            "[ta.percentile_nearest_rank](#fun_ta.percentile_nearest_rank)"
          ],
          "returnedType": "float",
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "ta.crossover",
          "desc": "The `source1`-series is defined as having crossed over `source2`-series if, on the current bar, the value of `source1` is greater than the value of `source2`, and on the previous bar, the value of `source1` was less than or equal to the value of `source2`.",
          "args": [
            {
              "name": "source1",
              "desc": "First data series.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "close",
                "open",
                "high",
                "low",
                "volume"
              ]
            },
            {
              "name": "source2",
              "desc": "Second data series.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "close",
                "open",
                "high",
                "low",
                "volume"
              ]
            }
          ],
          "syntax": "ta.crossover(source1, source2) → series bool",
          "returns": "true if `source1` crossed over `source2` otherwise false.",
          "returnedType": "bool",
          "returnedTypes": [
            "series bool",
            "simple bool",
            "input bool",
            "const bool"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "ta.crossunder",
          "desc": "The `source1`-series is defined as having crossed under `source2`-series if, on the current bar, the value of `source1` is less than the value of `source2`, and on the previous bar, the value of `source1` was greater than or equal to the value of `source2`.",
          "args": [
            {
              "name": "source1",
              "desc": "First data series.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "close",
                "open",
                "high",
                "low",
                "volume"
              ]
            },
            {
              "name": "source2",
              "desc": "Second data series.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "ta.crossunder(source1, source2) → series bool",
          "returns": "true if `source1` crossed under `source2` otherwise false.",
          "returnedType": "bool",
          "returnedTypes": [
            "series bool",
            "simple bool",
            "input bool",
            "const bool"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "strategy",
          "desc": "This declaration statement designates the script as a strategy and sets a number of strategy-related properties.",
          "args": [
            {
              "name": "title",
              "desc": "The title of the script. It is displayed on the chart when no `shorttitle` argument is used, and becomes the publication\\`s default title when publishing the script.",
              "default": null,
              "required": true,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "shorttitle",
              "desc": "The script\\`s display name on charts. If specified, it will replace the `title` argument in most chart-related windows.  \nOptional. The default is the argument used for `title`.",
              "default": "'title'",
              "required": false,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "overlay",
              "desc": "If [true](#op_true), the strategy will be displayed over the chart.  \nIf [false](#op_false), it will be added in a separate pane.  \nStrategy-specific labels that display entries and exits will be displayed over the main chart regardless of this setting.  \nOptional. The default is [false](#op_false).",
              "default": "false",
              "required": false,
              "displayType": "const bool",
              "allowedTypeIDs": [
                "const bool"
              ],
              "possibleValues": [
                "true",
                "false"
              ]
            },
            {
              "name": "format",
              "desc": "Specifies the formatting of the script\\`s displayed values.  \nPossible values: [format.inherit](#var_format.inherit), [format.price](#var_format.price), [format.volume](#var_format.volume), [format.percent](#var_format.percent).  \nOptional. The default is [format.inherit](#var_format.inherit).",
              "default": "format.inherit",
              "required": false,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": [
                "format.inherit",
                "format.price",
                "format.volume",
                "format.percent"
              ]
            },
            {
              "name": "precision",
              "desc": "Specifies the number of digits after the floating point of the script\\`s displayed values.  \nMust be a non-negative integer no greater than 16.  \nIf `format` is set to [format.inherit](#var_format.inherit) and `precision` is specified, the format will instead be set to [format.price](#var_format.price).  \nOptional. The default is inherited from the precision of the chart\\`s symbol.",
              "default": "syminfo.pricescale",
              "required": false,
              "displayType": "const int",
              "allowedTypeIDs": [
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "scale",
              "desc": "The price scale used.  \nPossible values: [scale.right](#var_scale.right), [scale.left](#var_scale.left), [scale.none](#var_scale.none).  \nThe [scale.none](#var_scale.none) value can only be applied in combination with `overlay = true`.  \nOptional. By default, the script uses the same scale as the chart.",
              "default": "scale.right",
              "required": false,
              "displayType": "const scale_type",
              "allowedTypeIDs": [
                "const scale_type"
              ],
              "possibleValues": [
                "scale.right",
                "scale.left",
                "scale.none"
              ]
            },
            {
              "name": "pyramiding",
              "desc": "The maximum number of entries allowed in the same direction. If the value is 0, only one entry order in the same direction can be opened, and additional entry orders are rejected.  \nThis setting can also be changed in the strategy\\`s \"Settings/Properties\" tab.  \nOptional. The default is 0.",
              "default": "0",
              "required": false,
              "displayType": "const int",
              "allowedTypeIDs": [
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "calc_on_order_fills",
              "desc": "Specifies whether the strategy should be recalculated after an order is filled.  \nIf [true](#op_true), the strategy recalculates after an order is filled, as opposed to recalculating only when the bar closes.  \nThis setting can also be changed in the strategy\\`s \"Settings/Properties\" tab.  \nOptional. The default is [false](#op_false).",
              "default": "false",
              "required": false,
              "displayType": "const bool",
              "allowedTypeIDs": [
                "const bool"
              ],
              "possibleValues": [
                "true",
                "false"
              ]
            },
            {
              "name": "calc_on_every_tick",
              "desc": "Specifies whether the strategy should be recalculated on each realtime tick. If [true](#op_true), when the strategy is running on a realtime bar, it will recalculate on each chart update.  \nIf [false](#op_false), the strategy only calculates when the realtime bar closes.  \nThe argument used does not affect strategy calculation on historical data.  \nThis setting can also be changed in the strategy\\`s \"Settings/Properties\" tab.  \nOptional. The default is [false](#op_false).",
              "default": "false",
              "required": false,
              "displayType": "const bool",
              "allowedTypeIDs": [
                "const bool"
              ],
              "possibleValues": [
                "true",
                "false"
              ]
            },
            {
              "name": "max_bars_back",
              "desc": "The length of the historical buffer the script keeps for every variable and function, which determines how many past values can be referenced using the `[]` history-referencing operator.  \nThe required buffer size is automatically detected by the Pine Script™ runtime.  \nUsing this parameter is only necessary when a runtime error occurs because automatic detection fails.  \nMore information on the underlying mechanics of the historical buffer can be found [in our Help Center](https://www.tradingview.com/chart/?solution=43000587849).  \nOptional. The default is 0.",
              "default": "0",
              "required": false,
              "displayType": "const int",
              "allowedTypeIDs": [
                "const int"
              ],
              "possibleValues": [
                "0",
                "10",
                "50",
                "100",
                "200"
              ]
            },
            {
              "name": "backtest_fill_limits_assumption",
              "desc": "Limit order execution threshold in ticks. When it is used, limit orders are only filled if the market price exceeds the order\\`s limit level by the specified number of ticks.  \nOptional. The default is 0.",
              "default": "0",
              "required": false,
              "displayType": "const int",
              "allowedTypeIDs": [
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "default_qty_type",
              "desc": "Specifies the units used for `default_qty_value`. Possible values are: [strategy.fixed](#var_strategy.fixed) for contracts/shares/lots, [strategy.cash](#var_strategy.cash) for currency amounts, or [strategy.percent_of_equity](#var_strategy.percent_of_equity) for a percentage of available equity.  \nThis setting can also be changed in the strategy\\`s \"Settings/Properties\" tab.  \nOptional. The default is [strategy.fixed](#var_strategy.fixed).",
              "default": "strategy.fixed",
              "required": false,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": [
                "strategy.fixed",
                "strategy.cash",
                "strategy.percent_of_equity"
              ]
            },
            {
              "name": "default_qty_value",
              "desc": "The default quantity to trade, in units determined by the argument used with the `default_qty_type` parameter.  \nThis setting can also be changed in the strategy\\`s \"Settings/Properties\" tab.  \nOptional. The default is 1.",
              "default": 1,
              "required": false,
              "displayType": "const int|float",
              "allowedTypeIDs": [
                "const int",
                "const float"
              ],
              "possibleValues": null
            },
            {
              "name": "initial_capital",
              "desc": "The amount of funds initially available for the strategy to trade, in units of `currency`.  \nOptional. The default is 1000000.",
              "default": "1000000",
              "required": false,
              "displayType": "const int|float",
              "allowedTypeIDs": [
                "const int",
                "const float"
              ],
              "possibleValues": [
                "1000",
                "10000",
                "100000",
                "1000000",
                "10000000"
              ]
            },
            {
              "name": "currency",
              "desc": "Currency used by the strategy in currency-related calculations. Market positions are still opened by converting `currency` into the chart symbol\\`s currency.  \nThe conversion rates used are based on the FX_IDC pairs' daily rates of the previous day (relative to the bar where the calculation is done).  \nThis setting can also be changed in the strategy\\`s \"Settings/Properties\" tab.  \nOptional. The default is [currency.NONE](#var_currency.NONE), in which case the chart\\`s currency is used. \nPossible values: one of the constants in the `currency.\\*` namespace, e.g. [currency.USD](#var_currency.USD).",
              "default": "syminfo.currency",
              "required": false,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": [
                "currency.NONE",
                "currency.USD",
                "currency.EUR",
                "currency.GBP",
                "currency.AUD"
              ]
            },
            {
              "name": "slippage",
              "desc": "Slippage expressed in ticks. This value is added to or subtracted from the fill price of market/stop orders to make the fill price less favorable for the strategy.  \nE.g., if [syminfo.mintick](#var_syminfo.mintick) is 0.01 and `slippage` is set to 5, a long market order will enter at 5 * 0.01 = 0.05 points above the actual price.  \nThis setting can also be changed in the strategy\\`s \"Settings/Properties\" tab.  \nOptional. The default is 0.",
              "default": "0",
              "required": false,
              "displayType": "const int",
              "allowedTypeIDs": [
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "commission_type",
              "desc": "Determines what the number passed to the `commission_value` expresses: [strategy.commission.percent](#var_strategy.commission.percent) for a percentage of the cash volume of the order, [strategy.commission.cash_per_contract](#var_strategy.commission.cash_per_contract) for currency per contract, [strategy.commission.cash_per_order](#var_strategy.commission.cash_per_order) for currency per order.  \nThis setting can also be changed in the strategy\\`s \"Settings/Properties\" tab.  \nOptional. The default is [strategy.commission.percent](#var_strategy.commission.percent).",
              "default": "strategy.commission.percent",
              "required": false,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": [
                "strategy.commission.percent",
                "strategy.commission.cash_per_contract",
                "strategy.commission.cash_per_order"
              ]
            },
            {
              "name": "commission_value",
              "desc": "Commission applied to the strategy\\`s orders in units determined by the argument passed to the `commission_type` parameter.  \nThis setting can also be changed in the strategy\\`s \"Settings/Properties\" tab.  \nOptional. The default is 0.",
              "default": "0",
              "required": false,
              "displayType": "const int|float",
              "allowedTypeIDs": [
                "const int",
                "const float"
              ],
              "possibleValues": [
                0,
                0.5,
                1,
                1.5,
                2
              ]
            },
            {
              "name": "process_orders_on_close",
              "desc": "When set to [true](#op_true), generates an additional attempt to execute orders after a bar closes and strategy calculations are completed.  \nIf the orders are market orders, the broker emulator executes them before the next bar\\`s open.  \nIf the orders are price-dependent, they will only be filled if the price conditions are met.  \nThis option is useful if you wish to close positions on the current bar.  \nThis setting can also be changed in the strategy\\`s \"Settings/Properties\" tab.  \nOptional. The default is [false](#op_false).",
              "default": "false",
              "required": false,
              "displayType": "const bool",
              "allowedTypeIDs": [
                "const bool"
              ],
              "possibleValues": [
                "true",
                "false"
              ]
            },
            {
              "name": "close_entries_rule",
              "desc": "Determines the order in which trades are closed. Possible values are: \"FIFO\" (First-In, First-Out) if the earliest exit order must close the earliest entry order, or \"ANY\" if the orders are closed based on the `from_entry` parameter of the [strategy.exit](#fun_strategy.exit) function. \"FIFO\" can only be used with stocks, futures and US forex (NFA Compliance Rule 2-43b), while \"ANY\" is allowed in non-US forex.  \nOptional. The default is \"FIFO\".",
              "default": "\"FIFO\"",
              "required": false,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "isString": true,
              "possibleValues": [
                "FIFO",
                "ANY"
              ]
            },
            {
              "name": "margin_long",
              "desc": "Margin long is the percentage of the purchase price of a security that must be covered by cash or collateral for long positions.  \nMust be a non-negative number.  \nThe logic used to simulate margin calls is explained in the [Help Center](https://www.tradingview.com/chart/?solution=43000628599).  \nThis setting can also be changed in the strategy\\`s \"Settings/Properties\" tab.  \nOptional. The default is 0, in which case the strategy does not enforce any limits on position size.",
              "default": "0",
              "required": false,
              "displayType": "const int|float",
              "allowedTypeIDs": [
                "const int",
                "const float"
              ],
              "possibleValues": [
                0,
                10,
                20,
                30,
                40
              ]
            },
            {
              "name": "margin_short",
              "desc": "Margin short is the percentage of the purchase price of a security that must be covered by cash or collateral for short positions.  \nMust be a non-negative number.  \nThe logic used to simulate margin calls is explained in the [Help Center](https://www.tradingview.com/chart/?solution=43000628599).  \nThis setting can also be changed in the strategy\\`s \"Settings/Properties\" tab.  \nOptional. The default is 0, in which case the strategy does not enforce any limits on position size.",
              "default": "0",
              "required": false,
              "displayType": "const int|float",
              "allowedTypeIDs": [
                "const int",
                "const float"
              ],
              "possibleValues": [
                0,
                10,
                20,
                30,
                40
              ]
            },
            {
              "name": "explicit_plot_zorder",
              "desc": "Specifies the order in which the script\\`s plots, fills, and hlines are rendered.  \nIf [true](#op_true), plots are drawn in the order in which they appear in the script\\`s code, each newer plot being drawn above the previous ones.  \nThis only applies to `plot*()` functions, [fill](#fun_fill), and [hline](#fun_hline).  \nOptional. The default is [false](#op_false).",
              "default": "false",
              "required": false,
              "displayType": "const bool",
              "allowedTypeIDs": [
                "const bool"
              ],
              "possibleValues": [
                "true",
                "false"
              ]
            },
            {
              "name": "max_lines_count",
              "desc": "The number of last [line](#op_line) drawings displayed. \nPossible values: 1-500.  \nOptional. The default is 50.",
              "default": 50,
              "required": false,
              "displayType": "const int",
              "allowedTypeIDs": [
                "const int"
              ],
              "possibleValues": [
                50,
                100,
                200,
                500
              ]
            },
            {
              "name": "max_labels_count",
              "desc": "The number of last [label](#op_label) drawings displayed. \nPossible values: 1-500.  \nOptional. The default is 50.",
              "default": 50,
              "required": false,
              "displayType": "const int",
              "allowedTypeIDs": [
                "const int"
              ],
              "possibleValues": [
                50,
                100,
                200,
                500
              ]
            },
            {
              "name": "max_boxes_count",
              "desc": "The number of last [box](#op_box) drawings displayed. \nPossible values: 1-500.  \nOptional. The default is 50.",
              "default": 50,
              "required": false,
              "displayType": "const int",
              "allowedTypeIDs": [
                "const int"
              ],
              "possibleValues": [
                50,
                100,
                200,
                500
              ]
            },
            {
              "name": "risk_free_rate",
              "desc": "The risk-free rate of return is the annual percentage change in the value of an investment with minimal or zero risk.  \nIt is used to calculate the [Sharpe and Sortino ratios](https://www.tradingview.com/chart/?solution=43000561856).  \nOptional. The default is 2.",
              "default": 2,
              "required": false,
              "displayType": "const int|float",
              "allowedTypeIDs": [
                "const int",
                "const float"
              ],
              "possibleValues": null
            },
            {
              "name": "use_bar_magnifier",
              "desc": "When true, the [Broker Emulator](https://www.tradingview.com/pine-script-docs/en/v5/concepts/Strategies.html#broker-emulator) uses lower timeframe data during history backtesting to achieve more realistic results.  \nOptional. The default is [false](#op_false).  \nOnly [Premium](https://www.tradingview.com/gopro/) accounts have access to this feature.",
              "default": "false",
              "required": false,
              "displayType": "const bool",
              "allowedTypeIDs": [
                "const bool"
              ],
              "possibleValues": [
                "true",
                "false"
              ]
            },
            {
              "name": "fill_orders_on_standard_ohlc",
              "desc": "When true, forces the strategy to fill orders on Heikin Ashi charts using actual OHLC values.  \nOptional. The default is [false](#op_false).",
              "default": "false",
              "required": false,
              "possibleValues": [
                "true",
                "false"
              ]
            },
            {
              "name": "max_polylines_count",
              "desc": "The number of last [polyline](#op_polyline) drawings displayed.  \nPossible values: 1-100. The count is approximate; more drawings than the specified count may be displayed. Optional. The default is 50.",
              "default": 50,
              "required": false,
              "displayType": "const int",
              "allowedTypeIDs": [
                "const int"
              ],
              "possibleValues": [
                1,
                10,
                20,
                50,
                100
              ]
            }
          ],
          "syntax": "strategy(title, shorttitle, overlay, format, precision, scale, pyramiding, calc_on_order_fills, calc_on_every_tick, max_bars_back, backtest_fill_limits_assumption, default_qty_type, default_qty_value, initial_capital, currency, slippage, commission_type, commission_value, process_orders_on_close, close_entries_rule, margin_long, margin_short, explicit_plot_zorder, max_lines_count, max_labels_count, max_boxes_count, max_polylines_count, risk_free_rate, use_bar_magnifier) → void",
          "remarks": "You can learn more about strategies in our [User Manual](https://www.tradingview.com/pine-script-docs/en/v5/concepts/Strategies.html).\nEvery strategy script must have one [strategy](#fun_strategy) call.\nStrategies using `calc_on_every_tick = true` parameter may calculate differently on historical and realtime bars, which causes [repainting](https://www.tradingview.com/pine-script-docs/en/v5/concepts/Repainting.html).\nStrategies always use the chart\\`s prices to enter and exit positions.  \nUsing them on non-standard chart types (Heikin Ashi, Renko, etc.) will produce misleading results, as their prices are synthetic.  \nBacktesting on non-standard charts is thus not recommended.",
          "seeAlso": [
            "[indicator](#fun_indicator)",
            "[library](#fun_library)"
          ],
          "examples": "//@version=5\nstrategy(\"My strategy\", overlay = true, margin_long = 100, margin_short = 100)\n\n// Enter long by market if current open is greater than previous high.\nif open > high[1]\n\tstrategy.entry(\"Long\", strategy.long, 1)\n// Generate a full exit bracket (profit 10 points, loss 5 points per contract) from the entry named \"Long\".\nstrategy.exit(\"Exit\", \"Long\", profit = 10, loss = 5)",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "strategy.entry",
          "desc": "It is a command to enter market position. If an order with the same ID is already pending, it is possible to modify the order.  \nIf there is no order with the specified ID, a new order is placed.  \nTo deactivate an entry order, the command [strategy.cancel](#fun_strategy.cancel) or [strategy.cancel_all](#fun_strategy.cancel_all) should be used.  \nIn comparison to the function [strategy.order](#fun_strategy.order), the function [strategy.entry](#fun_strategy.entry) is affected by pyramiding and it can reverse market position correctly.  \nIf both 'limit' and 'stop' parameters are 'NaN', the order type is market order.",
          "args": [
            {
              "name": "id",
              "desc": "A required parameter. The order identifier. It is possible to cancel or modify an order by referencing its identifier.",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "direction",
              "desc": "A required parameter. Market position direction: 'strategy.long' is for long, 'strategy.short' is for short.",
              "default": null,
              "required": true,
              "displayType": "series strategy_direction",
              "allowedTypeIDs": [
                "series strategy_direction"
              ],
              "possibleValues": [
                "strategy.long",
                "strategy.short"
              ]
            },
            {
              "name": "qty",
              "desc": "An optional parameter. Number of contracts/shares/lots/units to trade. The default value is 'NaN'.",
              "default": "na",
              "required": false,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            },
            {
              "name": "limit",
              "desc": "An optional parameter. Limit price of the order. If it is specified, the order type is either 'limit', or 'stop-limit'. 'NaN' should be specified for any other order type.",
              "default": 1,
              "required": false,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            },
            {
              "name": "stop",
              "desc": "An optional parameter. Stop price of the order. If it is specified, the order type is either 'stop', or 'stop-limit'. 'NaN' should be specified for any other order type.",
              "default": "na",
              "required": false,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            },
            {
              "name": "oca_name",
              "desc": "An optional parameter. Name of the OCA group the order belongs to. If the order should not belong to any particular OCA group, there should be an empty string.",
              "default": "\"\"",
              "required": false,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "oca_type",
              "desc": "An optional parameter. Type of the OCA group. The allowed values are: [strategy.oca.none](#var_strategy.oca.none) - the order should not belong to any particular OCA group; [strategy.oca.cancel](#var_strategy.oca.cancel) - the order should belong to an OCA group, where as soon as an order is filled, all other orders of the same group are cancelled; [strategy.oca.reduce](#var_strategy.oca.reduce) - the order should belong to an OCA group, where if X number of contracts of an order is filled, number of contracts for each other order of the same OCA group is decreased by X.",
              "default": null,
              "required": false,
              "displayType": "input string",
              "allowedTypeIDs": [
                "input string",
                "const string"
              ],
              "possibleValues": [
                "strategy.oca.none",
                "strategy.oca.cancel",
                "strategy.oca.reduce"
              ]
            },
            {
              "name": "comment",
              "desc": "An optional parameter. Additional notes on the order.",
              "default": null,
              "required": false,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "alert_message",
              "desc": "An optional parameter which replaces the {{strategy.order.alert_message}} placeholder when it is used in the \"Create Alert\" dialog box\\`s \"Message\" field.",
              "default": null,
              "required": false,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "disable_alert",
              "desc": "If [true](#op_true) when the function creates an order, the strategy alert will not fire upon the execution of that order.  \nThe parameter accepts a 'series bool' argument, allowing users to control which orders will trigger alerts when they fill.  \nOptional. The default is [false](#op_false).",
              "default": "false",
              "required": false,
              "displayType": "series bool",
              "allowedTypeIDs": [
                "series bool",
                "simple bool",
                "input bool",
                "const bool"
              ],
              "possibleValues": [
                "true",
                "false"
              ]
            }
          ],
          "syntax": "strategy.entry(id, direction, qty, limit, stop, oca_name, oca_type, comment, alert_message, disable_alert) → void",
          "seeAlso": [
            "[strategy.entry](#fun_strategy.entry)",
            "[strategy.exit](#fun_strategy.exit)",
            "[strategy.order](#fun_strategy.order)"
          ],
          "examples": "//@version=5\nstrategy(title = \"simple strategy entry example\")\nif open > high[1]\n\tstrategy.entry(\"enter long\", strategy.long, 1) // enter long by market if current open great then previous high\nif open < low[1]\n\tstrategy.entry(\"enter short\", strategy.short, 1) // enter short by market if current open less then previous low",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "strategy.order",
          "desc": "It is a command to place order. If an order with the same ID is already pending, it is possible to modify the order.  \nIf there is no order with the specified ID, a new order is placed.  \nTo deactivate order, the command [strategy.cancel](#fun_strategy.cancel) or [strategy.cancel_all](#fun_strategy.cancel_all) should be used.  \nIn comparison to the function [strategy.entry](#fun_strategy.entry), the function [strategy.order](#fun_strategy.order) is not affected by pyramiding.  \nIf both 'limit' and 'stop' parameters are 'NaN', the order type is market order.",
          "args": [
            {
              "name": "id",
              "desc": "A required parameter. The order identifier. It is possible to cancel or modify an order by referencing its identifier.",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "direction",
              "desc": "A required parameter. Order direction: 'strategy.long' is for buy, 'strategy.short' is for sell.",
              "default": null,
              "required": true,
              "displayType": "series strategy_direction",
              "allowedTypeIDs": [
                "series strategy_direction"
              ],
              "possibleValues": [
                "strategy.long",
                "strategy.short"
              ]
            },
            {
              "name": "qty",
              "desc": "An optional parameter. Number of contracts/shares/lots/units to trade. The default value is 'NaN'.",
              "default": 1,
              "required": false,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            },
            {
              "name": "limit",
              "desc": "An optional parameter. Limit price of the order. If it is specified, the order type is either 'limit', or 'stop-limit'. 'NaN' should be specified for any other order type.",
              "default": null,
              "required": false,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            },
            {
              "name": "stop",
              "desc": "An optional parameter. Stop price of the order. If it is specified, the order type is either 'stop', or 'stop-limit'. 'NaN' should be specified for any other order type.",
              "default": null,
              "required": false,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            },
            {
              "name": "oca_name",
              "desc": "An optional parameter. Name of the OCA group the order belongs to. If the order should not belong to any particular OCA group, there should be an empty string.",
              "default": null,
              "required": false,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "oca_type",
              "desc": "An optional parameter. Type of the OCA group. The allowed values are: [strategy.oca.none](#var_strategy.oca.none) - the order should not belong to any particular OCA group; [strategy.oca.cancel](#var_strategy.oca.cancel) - the order should belong to an OCA group, where as soon as an order is filled, all other orders of the same group are cancelled; [strategy.oca.reduce](#var_strategy.oca.reduce) - the order should belong to an OCA group, where if X number of contracts of an order is filled, number of contracts for each other order of the same OCA group is decreased by X.",
              "default": null,
              "required": false,
              "displayType": "input string",
              "allowedTypeIDs": [
                "input string",
                "const string"
              ],
              "possibleValues": [
                "strategy.oca.none",
                "strategy.oca.cancel",
                "strategy.oca.reduce"
              ]
            },
            {
              "name": "comment",
              "desc": "An optional parameter. Additional notes on the order.",
              "default": null,
              "required": false,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "alert_message",
              "desc": "An optional parameter which replaces the {{strategy.order.alert_message}} placeholder when it is used in the \"Create Alert\" dialog box\\`s \"Message\" field.",
              "default": null,
              "required": false,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "disable_alert",
              "desc": "If [true](#op_true) when the function creates an order, the strategy alert will not fire upon the execution of that order.  \nThe parameter accepts a 'series bool' argument, allowing users to control which orders will trigger alerts when they fill.  \nOptional. The default is [false](#op_false).",
              "default": "false",
              "required": false,
              "displayType": "series bool",
              "allowedTypeIDs": [
                "series bool",
                "simple bool",
                "input bool",
                "const bool"
              ],
              "possibleValues": [
                "true",
                "false"
              ]
            }
          ],
          "syntax": "strategy.order(id, direction, qty, limit, stop, oca_name, oca_type, comment, alert_message, disable_alert) → void",
          "seeAlso": [
            "[strategy.entry](#fun_strategy.entry)",
            "[strategy.exit](#fun_strategy.exit)",
            "[strategy.order](#fun_strategy.order)"
          ],
          "examples": "//@version=5\nstrategy(title = \"simple strategy order example\")\nif open > high[1]\n\tstrategy.order(\"buy\", strategy.long, 1) // buy by market if current open great then previous high\nif open < low[1]\n\tstrategy.order(\"sell\", strategy.short, 1) // sell by market if current open less then previous low",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "strategy.exit",
          "desc": "It is a command to exit either a specific entry, or whole market position. If an order with the same ID is already pending, it is possible to modify the order.  \nIf an entry order was not filled, but an exit order is generated, the exit order will wait till entry order is filled and then the exit order is placed.  \nTo deactivate an exit order, the command [strategy.cancel](#fun_strategy.cancel) or [strategy.cancel_all](#fun_strategy.cancel_all) should be used.  \nIf the function [strategy.exit](#fun_strategy.exit) is called once, it exits a position only once.  \nIf you want to exit multiple times, the command [strategy.exit](#fun_strategy.exit) should be called multiple times.  \nIf you use a stop loss and a trailing stop, their order type is 'stop', so only one of them is placed (the one that is supposed to be filled first).  \nIf all the following parameters 'profit', 'limit', 'loss', 'stop', 'trail_points', 'trail_offset' are 'NaN', the command will fail.  \nTo use market order to exit, the command [strategy.close](#fun_strategy.close) or [strategy.close_all](#fun_strategy.close_all) should be used.",
          "args": [
            {
              "name": "id",
              "desc": "A required parameter. The order identifier. It is possible to cancel or modify an order by referencing its identifier.",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "from_entry",
              "desc": "An optional parameter. The identifier of a specific entry order to exit from it.  \nTo exit all entries an empty string should be used.  \nThe default values is empty string.",
              "default": null,
              "required": false,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "qty",
              "desc": "An optional parameter. Number of contracts/shares/lots/units to exit a trade with.  \nThe default value is 'NaN'.",
              "default": null,
              "required": false,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            },
            {
              "name": "qty_percent",
              "desc": "Defines the percentage of (0-100) the position to close. Its priority is lower than that of the 'qty' parameter.  \nOptional. The default is 100.",
              "default": 100,
              "required": false,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                0,
                25,
                50,
                75,
                100
              ]
            },
            {
              "name": "profit",
              "desc": "An optional parameter. Profit target (specified in ticks). If it is specified, a limit order is placed to exit market position when the specified amount of profit (in ticks) is reached.  \nThe default value is 'NaN'.",
              "default": null,
              "required": false,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            },
            {
              "name": "limit",
              "desc": "An optional parameter. Profit target (requires a specific price). If it is specified, a limit order is placed to exit market position at the specified price (or better).  \nPriority of the parameter 'limit' is higher than priority of the parameter 'profit' ('limit' is used instead of 'profit', if its value is not 'NaN').  \nThe default value is 'NaN'.",
              "default": "na",
              "required": false,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            },
            {
              "name": "loss",
              "desc": "An optional parameter. Stop loss (specified in ticks). If it is specified, a stop order is placed to exit market position when the specified amount of loss (in ticks) is reached.  \nThe default value is 'NaN'.",
              "default": "na",
              "required": false,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            },
            {
              "name": "stop",
              "desc": "An optional parameter. Stop loss (requires a specific price). If it is specified, a stop order is placed to exit market position at the specified price (or worse).  \nPriority of the parameter 'stop' is higher than priority of the parameter 'loss' ('stop' is used instead of 'loss', if its value is not 'NaN').  \nThe default value is 'NaN'.",
              "default": "na",
              "required": false,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            },
            {
              "name": "trail_price",
              "desc": "An optional parameter. Trailing stop activation level (requires a specific price).  \nIf it is specified, a trailing stop order will be placed when the specified price level is reached.  \nThe offset (in ticks) to determine initial price of the trailing stop order is specified in the 'trail_offset' parameter: X ticks lower than activation level to exit long position; X ticks higher than activation level to exit short position.  \nThe default value is 'NaN'.",
              "default": "na",
              "required": false,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            },
            {
              "name": "trail_points",
              "desc": "An optional parameter. Trailing stop activation level (profit specified in ticks).  \nIf it is specified, a trailing stop order will be placed when the calculated price level (specified amount of profit) is reached.  \nThe offset (in ticks) to determine initial price of the trailing stop order is specified in the 'trail_offset' parameter: X ticks lower than activation level to exit long position; X ticks higher than activation level to exit short position.  \nThe default value is 'NaN'.",
              "default": "na",
              "required": false,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            },
            {
              "name": "trail_offset",
              "desc": "An optional parameter. Trailing stop price (specified in ticks). The offset in ticks to determine initial price of the trailing stop order: X ticks lower than 'trail_price' or 'trail_points' to exit long position; X ticks higher than 'trail_price' or 'trail_points' to exit short position.  \nThe default value is 'NaN'.",
              "default": "na",
              "required": false,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            },
            {
              "name": "oca_name",
              "desc": "An optional parameter. Name of the OCA group (oca_type = [strategy.oca.reduce](#var_strategy.oca.reduce)) the profit target, the stop loss / the trailing stop orders belong to.  \nIf the name is not specified, it will be generated automatically.",
              "default": null,
              "required": false,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "comment",
              "desc": "Additional notes on the order. If specified, displays near the order marker on the chart.  \nOptional. The default is [na](#var_na).",
              "default": "na",
              "required": false,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "comment_profit",
              "desc": "Additional notes on the order if the exit was triggered by crossing `profit` or `limit` specifically.  \nIf specified, supercedes the `comment` parameter and displays near the order marker on the chart.  \nOptional. The default is [na](#var_na).",
              "default": "na",
              "required": false,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "comment_loss",
              "desc": "Additional notes on the order if the exit was triggered by crossing `stop` or `loss` specifically.  \nIf specified, supercedes the `comment` parameter and displays near the order marker on the chart.  \nOptional. The default is [na](#var_na).",
              "default": "na",
              "required": false,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "comment_trailing",
              "desc": "Additional notes on the order if the exit was triggered by crossing `trail_offset` specifically.  \nIf specified, supercedes the `comment` parameter and displays near the order marker on the chart.  \nOptional. The default is [na](#var_na).",
              "default": "na",
              "required": false,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "alert_message",
              "desc": "Text that will replace the '{{strategy.order.alert_message}}' placeholder when one is used in the \"Message\" field of the \"Create Alert\" dialog.  \nOptional. The default is [na](#var_na).",
              "default": "na",
              "required": false,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "alert_profit",
              "desc": "Text that will replace the '{{strategy.order.alert_message}}' placeholder when one is used in the \"Message\" field of the \"Create Alert\" dialog.  \nOnly replaces the text if the exit was triggered by crossing `profit` or `limit` specifically.  \nOptional. The default is [na](#var_na).",
              "default": "na",
              "required": false,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "alert_loss",
              "desc": "Text that will replace the '{{strategy.order.alert_message}}' placeholder when one is used in the \"Message\" field of the \"Create Alert\" dialog.  \nOnly replaces the text if the exit was triggered by crossing `stop` or `loss` specifically.  \nOptional. The default is [na](#var_na).",
              "default": "na",
              "required": false,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "alert_trailing",
              "desc": "Text that will replace the '{{strategy.order.alert_message}}' placeholder when one is used in the \"Message\" field of the \"Create Alert\" dialog.  \nOnly replaces the text if the exit was triggered by crossing `trail_offset` specifically.  \nOptional. The default is [na](#var_na).",
              "default": "na",
              "required": false,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "disable_alert",
              "desc": "If [true](#op_true) when the function creates an order, the strategy alert will not fire upon the execution of that order.  \nThe parameter accepts a 'series bool' argument, allowing users to control which orders will trigger alerts when they fill.  \nOptional. The default is [false](#op_false).",
              "default": "false",
              "required": false,
              "displayType": "series bool",
              "allowedTypeIDs": [
                "series bool",
                "simple bool",
                "input bool",
                "const bool"
              ],
              "possibleValues": [
                "true",
                "false"
              ]
            }
          ],
          "syntax": "strategy.exit(id, from_entry, qty, qty_percent, profit, limit, loss, stop, trail_price, trail_points, trail_offset, oca_name, comment, comment_profit, comment_loss, comment_trailing, alert_message, alert_profit, alert_loss, alert_trailing, disable_alert) → void",
          "seeAlso": [
            "[strategy.entry](#fun_strategy.entry)",
            "[strategy.exit](#fun_strategy.exit)",
            "[strategy.order](#fun_strategy.order)"
          ],
          "examples": "//@version=5\nstrategy(title = \"simple strategy exit example\")\nif open > high[1]\n\tstrategy.entry(\"long\", strategy.long, 1) // enter long by market if current open great then previous high\nstrategy.exit(\"exit\", \"long\", profit = 10, loss = 5) // generate full exit bracket (profit 10 points, loss 5 points per contract) from entry with name \"long\"",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "strategy.cancel",
          "desc": "It is a command to cancel/deactivate pending orders by referencing their names, which were generated by the functions: [strategy.order](#fun_strategy.order), [strategy.entry](#fun_strategy.entry) and [strategy.exit](#fun_strategy.exit).",
          "args": [
            {
              "name": "id",
              "desc": "A required parameter. The order identifier. It is possible to cancel an order by referencing its identifier.",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "strategy.cancel(id) → void",
          "seeAlso": [
            "[strategy.entry](#fun_strategy.entry)",
            "[strategy.exit](#fun_strategy.exit)",
            "[strategy.order](#fun_strategy.order)"
          ],
          "examples": "//@version=5\nstrategy(title = \"simple order cancellation example\")\nconditionForBuy = open > high[1]\nif conditionForBuy\n\tstrategy.entry(\"long\", strategy.long, 1, limit = low) // enter long using limit order at low price of current bar if conditionForBuy is true\nif not conditionForBuy\n\tstrategy.cancel(\"long\") // cancel the entry order with name \"long\" if conditionForBuy is false",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "strategy.cancel_all",
          "desc": "It is a command to cancel/deactivate all pending orders, which were generated by the functions: [strategy.order](#fun_strategy.order), [strategy.entry](#fun_strategy.entry) and [strategy.exit](#fun_strategy.exit).",
          "syntax": "strategy.cancel_all() → void",
          "seeAlso": [
            "[strategy.entry](#fun_strategy.entry)",
            "[strategy.exit](#fun_strategy.exit)",
            "[strategy.order](#fun_strategy.order)"
          ],
          "examples": "//@version=5\nstrategy(title = \"simple all orders cancellation example\")\nconditionForBuy1 = open > high[1]\nif conditionForBuy1\n\tstrategy.entry(\"long entry 1\", strategy.long, 1, limit = low) // enter long by limit if conditionForBuy1 is true\nconditionForBuy2 = conditionForBuy1 and open[1] > high[2]\nif conditionForBuy2\n\tstrategy.entry(\"long entry 2\", strategy.long, 1, limit = ta.lowest(low, 2)) // enter long by limit if conditionForBuy2 is true\nconditionForStopTrading = open < ta.lowest(low, 2)\nif conditionForStopTrading\n\tstrategy.cancel_all() // cancel both limit orders if the conditon conditionForStopTrading is true",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "ta.pivothigh",
          "desc": "This function returns price of the pivot high point. It returns 'NaN', if there was no pivot high point.",
          "args": [
            {
              "name": "source",
              "desc": "An optional parameter. Data series to calculate the value. 'High' by default.",
              "default": "High",
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "high",
                "low",
                "open",
                "close",
                "hl2",
                "hlc3",
                "ohlc4"
              ]
            },
            {
              "name": "leftbars",
              "desc": "Left strength.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            },
            {
              "name": "rightbars",
              "desc": "Right strength.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "ta.pivothigh(source, leftbars, rightbars) → series float\nta.pivothigh(leftbars, rightbars) → series float",
          "remarks": "If parameters 'leftbars' or 'rightbars' are series you should use [max_bars_back](#fun_max_bars_back) function for the 'source' variable.",
          "returns": "Price of the point or 'NaN'.",
          "examples": "//@version=5\nindicator(\"PivotHigh\", overlay=true)\nleftBars = input(2)\nrightBars=input(2)\nph = ta.pivothigh(leftBars, rightBars)\nplot(ph, style=plot.style_cross, linewidth=3, color= color.red, offset=-rightBars)",
          "returnedType": "float",
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "ta.pivotlow",
          "desc": "This function returns price of the pivot low point. It returns 'NaN', if there was no pivot low point.",
          "args": [
            {
              "name": "source",
              "desc": "An optional parameter. Data series to calculate the value. 'Low' by default.",
              "default": "low",
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "low",
                "high",
                "open",
                "close",
                "hl2"
              ]
            },
            {
              "name": "leftbars",
              "desc": "Left strength.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            },
            {
              "name": "rightbars",
              "desc": "Right strength.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "ta.pivotlow(source, leftbars, rightbars) → series float\nta.pivotlow(leftbars, rightbars) → series float",
          "remarks": "If parameters 'leftbars' or 'rightbars' are series you should use [max_bars_back](#fun_max_bars_back) function for the 'source' variable.",
          "returns": "Price of the point or 'NaN'.",
          "examples": "//@version=5\nindicator(\"PivotLow\", overlay=true)\nleftBars = input(2)\nrightBars=input(2)\npl = ta.pivotlow(close, leftBars, rightBars)\nplot(pl, style=plot.style_cross, linewidth=3, color= color.blue, offset=-rightBars)",
          "returnedType": "float",
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "strategy.close_all",
          "desc": "Exits the current market position, making it flat.",
          "args": [
            {
              "name": "comment",
              "desc": "An optional parameter. Additional notes on the order.",
              "default": null,
              "required": false,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "alert_message",
              "desc": "An optional parameter which replaces the {{strategy.order.alert_message}} placeholder when it is used in the \"Create Alert\" dialog box\\`s \"Message\" field.",
              "default": null,
              "required": false,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "immediately",
              "desc": "An optional parameter. If [true](#op_true), the closing order will be executed on the tick where it has been placed, ignoring the strategy parameters that restrict the order execution to the open of the next bar.  \nThe default is [false](#op_false).",
              "default": "false",
              "required": false,
              "displayType": "series bool",
              "allowedTypeIDs": [
                "series bool",
                "simple bool",
                "input bool",
                "const bool"
              ],
              "possibleValues": [
                "true",
                "false"
              ]
            },
            {
              "name": "disable_alert",
              "desc": "If [true](#op_true) when the function creates an order, the strategy alert will not fire upon the execution of that order.  \nThe parameter accepts a 'series bool' argument, allowing users to control which orders will trigger alerts when they fill.  \nOptional. The default is [false](#op_false).",
              "default": "false",
              "required": false,
              "displayType": "series bool",
              "allowedTypeIDs": [
                "series bool",
                "simple bool",
                "input bool",
                "const bool"
              ],
              "possibleValues": [
                "true",
                "false"
              ]
            }
          ],
          "syntax": "strategy.close_all(comment, alert_message, immediately) → void",
          "seeAlso": [
            "[strategy.entry](#fun_strategy.entry)",
            "[strategy.exit](#fun_strategy.exit)",
            "[strategy.order](#fun_strategy.order)"
          ],
          "examples": "//@version=5\nstrategy(\"closeAll Demo\", overlay=false)\nif open > close\n\tstrategy.entry(\"buy\", strategy.long)\nif open < close\n\tstrategy.close_all(comment = \"close all entries\")\nplot(strategy.position_size)",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "strategy.close",
          "desc": "It is a command to exit from the entry with the specified ID. If there were multiple entry orders with the same ID, all of them are exited at once. If there are no open entries with the specified ID by the moment the command is triggered, the command will not come into effect. The command uses market order. Every entry is closed by a separate market order.",
          "args": [
            {
              "name": "id",
              "desc": "A required parameter. The order identifier. It is possible to close an order by referencing its identifier.",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "comment",
              "desc": "An optional parameter. Additional notes on the order.",
              "default": null,
              "required": false,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "qty",
              "desc": "An optional parameter. Number of contracts/shares/lots/units to exit a trade with.  \nThe default value is 'NaN'.",
              "default": "na",
              "required": false,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            },
            {
              "name": "qty_percent",
              "desc": "Defines the percentage (0-100) of the position to close. Its priority is lower than that of the 'qty' parameter.  \nOptional. The default is 100.",
              "default": "100",
              "required": false,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                0,
                25,
                50,
                75,
                100
              ]
            },
            {
              "name": "alert_message",
              "desc": "An optional parameter which replaces the {{strategy.order.alert_message}} placeholder when it is used in the \"Create Alert\" dialog box\\`s \"Message\" field.",
              "default": null,
              "required": false,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "immediately",
              "desc": "An optional parameter. If [true](#op_true), the closing order will be executed on the tick where it has been placed, ignoring the strategy parameters that restrict the order execution to the open of the next bar.  \nThe default is [false](#op_false).",
              "default": "false",
              "required": false,
              "displayType": "series bool",
              "allowedTypeIDs": [
                "series bool",
                "simple bool",
                "input bool",
                "const bool"
              ],
              "possibleValues": [
                "true",
                "false"
              ]
            },
            {
              "name": "disable_alert",
              "desc": "If [true](#op_true) when the function creates an order, the strategy alert will not fire upon the execution of that order.  \nThe parameter accepts a 'series bool' argument, allowing users to control which orders will trigger alerts when they fill.  \nOptional. The default is [false](#op_false).",
              "default": "false",
              "required": false,
              "displayType": "series bool",
              "allowedTypeIDs": [
                "series bool",
                "simple bool",
                "input bool",
                "const bool"
              ],
              "possibleValues": [
                "true",
                "false"
              ]
            }
          ],
          "syntax": "strategy.close(id, comment, qty, qty_percent, alert_message, immediately) → void",
          "seeAlso": [
            "[strategy.entry](#fun_strategy.entry)",
            "[strategy.exit](#fun_strategy.exit)",
            "[strategy.order](#fun_strategy.order)"
          ],
          "examples": "//@version=5\nstrategy(\"closeEntry Demo\", overlay=false)\nif open > close\n\tstrategy.entry(\"buy\", strategy.long)\nif open < close\n\tstrategy.close(\"buy\", qty_percent = 50, comment = \"close buy entry for 50%\")\nplot(strategy.position_size)",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "strategy.risk.max_position_size",
          "desc": "The purpose of this rule is to determine maximum size of a market position. The rule affects the following function: [strategy.entry](#fun_strategy.entry).  \nThe 'entry' quantity can be reduced (if needed) to such number of contracts/shares/lots/units, so the total position size doesn't exceed the value specified in 'strategy.risk.max_position_size'.  \nIf minimum possible quantity still violates the rule, the order will not be placed.",
          "args": [
            {
              "name": "contracts",
              "desc": "A required parameter. Maximum number of contracts/shares/lots/units in a position.",
              "default": null,
              "required": true,
              "displayType": "simple int|float",
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "strategy.risk.max_position_size(contracts) → void",
          "examples": "//@version=5\nstrategy(\"risk.max_position_size Demo\", default_qty_value = 100)\nstrategy.risk.max_position_size(10)\nif open > close\n\tstrategy.entry(\"buy\", strategy.long)\nplot(strategy.position_size)  // max plot value will be 10",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "strategy.risk.max_intraday_loss",
          "desc": "The maximum loss value allowed during a day. It is specified either in money (base currency), or in percentage of maximum intraday equity (0 -100).",
          "args": [
            {
              "name": "value",
              "desc": "A required parameter. The maximum loss value. It is specified either in money (base currency), or in percentage of maximum intraday equity.  \nFor % of equity the range of allowed values is from 0 to 100.",
              "default": null,
              "required": true,
              "displayType": "simple int|float",
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            },
            {
              "name": "displayType",
              "desc": "A required parameter. The type of the value. Please specify one of the following values: [strategy.percent_of_equity](#var_strategy.percent_of_equity) or [strategy.cash](#var_strategy.cash).  \nNote: if equity drops down to zero or to a negative and the [strategy.percent_of_equity](#var_strategy.percent_of_equity) is specified, all pending orders are cancelled, all open positions are closed and no new orders can be placed for good.",
              "default": null,
              "required": true,
              "displayType": "simple string",
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "strategy.percent_of_equity",
                "strategy.cash"
              ]
            },
            {
              "name": "alert_message",
              "desc": "An optional parameter which replaces the {{strategy.order.alert_message}} placeholder when it is used in the \"Create Alert\" dialog box\\`s \"Message\" field.",
              "default": null,
              "required": false,
              "displayType": "simple string",
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "strategy.risk.max_intraday_loss(value, type, alert_message) → void",
          "seeAlso": [
            "[strategy](#fun_strategy)",
            "[strategy.percent_of_equity](#const_strategy.percent_of_equity)",
            "[strategy.cash](#const_strategy.cash)"
          ],
          "returnedType": "void",
          "detailedDesc": [
            {
              "desc": "",
              "examples": "// Sets the maximum intraday loss using the strategy\\`s equity value.\n//@version=5\nstrategy(\"strategy.risk.max_intraday_loss Example 1\", overlay = false, default_qty_type = strategy.percent_of_equity, default_qty_value = 100)\n\n// Input for maximum intraday loss %. \nlossPct = input.float(10)\n\n// Set maximum intraday loss to our lossPct input\nstrategy.risk.max_intraday_loss(lossPct, strategy.percent_of_equity)\n\n// Enter Short at bar_index zero.\nif bar_index == 0\n\tstrategy.entry(\"Short\", strategy.short)\n\n// Class equity value from the beginning of the day\neqFromDayStart = ta.valuewhen(ta.change(dayofweek) > 0, strategy.equity, 0)\n\n// Calculate change of the current equity from the beginning of the current day.\neqChgPct = 100 * ((strategy.equity - eqFromDayStart) / strategy.equity)\n\n// Plot it\nplot(eqChgPct) \nhline(-lossPct)"
            },
            {
              "desc": "",
              "examples": "// Sets the maximum intraday loss using the strategy\\`s cash value.\n//@version=5\nstrategy(\"strategy.risk.max_intraday_loss Example 2\", overlay = false)\n\n// Input for maximum intraday loss in absolute cash value of the symbol. \nabsCashLoss = input.float(5)\n\n// Set maximum intraday loss to `absCashLoss` in account currency.\nstrategy.risk.max_intraday_loss(absCashLoss, strategy.cash)\n\n// Enter Short at bar_index zero.\nif bar_index == 0\n\tstrategy.entry(\"Short\", strategy.short)\n\n// Class the open price value from the beginning of the day.\nbeginPrice = ta.valuewhen(ta.change(dayofweek) > 0, open, 0)\n\n// Calculate the absolute price change for the current period.\npriceChg = (close - beginPrice)\n\nhline(absCashLoss)\nplot(priceChg)"
            }
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "strategy.risk.max_intraday_filled_orders",
          "desc": "The purpose of this rule is to determine maximum number of filled orders per 1 day (per 1 bar, if chart resolution is higher than 1 day). The rule affects the whole strategy. Once the maximum number of filled orders is reached, all pending orders are cancelled, all open positions are closed and no new orders can be placed till the end of the current trading session.",
          "args": [
            {
              "name": "count",
              "desc": "A required parameter. The maximum number of filled orders per 1 day.",
              "default": null,
              "required": true,
              "displayType": "simple int",
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "alert_message",
              "desc": "An optional parameter which replaces the {{strategy.order.alert_message}} placeholder when it is used in the \"Create Alert\" dialog box\\`s \"Message\" field.",
              "default": null,
              "required": false,
              "displayType": "simple string",
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "strategy.risk.max_intraday_filled_orders(count, alert_message) → void",
          "seeAlso": [
            "[strategy.entry](#fun_strategy.entry)",
            "[strategy.exit](#fun_strategy.exit)",
            "[strategy.order](#fun_strategy.order)"
          ],
          "examples": "//@version=5\nstrategy(\"risk.max_intraday_filled_orders Demo\")\nstrategy.risk.max_intraday_filled_orders(10) // After 10 orders are filled, no more strategy orders will be placed (except for a market order to exit current open market position, if there is any).\nif open > close\n\tstrategy.entry(\"buy\", strategy.long)\nif open < close\n\tstrategy.entry(\"sell\", strategy.short)",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "strategy.risk.allow_entry_in",
          "desc": "This function can be used to specify in which market direction the [strategy.entry](#fun_strategy.entry) function is allowed to open positions.",
          "args": [
            {
              "name": "value",
              "desc": "The allowed direction.  \nPossible values: [strategy.direction.all](#var_strategy.direction.all), [strategy.direction.long](#var_strategy.direction.long), [strategy.direction.short](#var_strategy.direction.short)",
              "default": null,
              "required": true,
              "displayType": "simple string",
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "strategy.direction.all",
                "strategy.direction.long",
                "strategy.direction.short"
              ]
            }
          ],
          "syntax": "strategy.risk.allow_entry_in(value) → void",
          "seeAlso": [
            "[strategy.entry](#fun_strategy.entry)",
            "[strategy.exit](#fun_strategy.exit)",
            "[strategy.order](#fun_strategy.order)"
          ],
          "examples": "//@version=5\nstrategy(\"strategy.risk.allow_entry_in\")\n\nstrategy.risk.allow_entry_in(strategy.direction.long)\nif open > close\n\tstrategy.entry(\"Long\", strategy.long)\n// Instead of opening a short position with 10 contracts, this command will close long entries.\nif open < close\n\tstrategy.entry(\"Short\", strategy.short, qty = 10)",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "strategy.risk.max_cons_loss_days",
          "desc": "The purpose of this rule is to cancel all pending orders, close all open positions and stop placing orders after a specified number of consecutive days with losses. The rule affects the whole strategy.",
          "args": [
            {
              "name": "count",
              "desc": "A required parameter. The allowed number of consecutive days with losses.",
              "default": null,
              "required": true,
              "displayType": "simple int",
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "alert_message",
              "desc": "An optional parameter which replaces the {{strategy.order.alert_message}} placeholder when it is used in the \"Create Alert\" dialog box\\`s \"Message\" field.",
              "default": null,
              "required": false,
              "displayType": "simple string",
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "strategy.risk.max_cons_loss_days(count, alert_message) → void",
          "seeAlso": [
            "[strategy.entry](#fun_strategy.entry)",
            "[strategy.exit](#fun_strategy.exit)",
            "[strategy.order](#fun_strategy.order)"
          ],
          "examples": "//@version=5\nstrategy(\"risk.max_cons_loss_days Demo 1\")\nstrategy.risk.max_cons_loss_days(3) // No orders will be placed after 3 days, if each day is with loss.\nplot(strategy.position_size)",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "strategy.risk.max_drawdown",
          "desc": "The purpose of this rule is to determine maximum drawdown. The rule affects the whole strategy. Once the maximum drawdown value is reached, all pending orders are cancelled, all open positions are closed and no new orders can be placed.",
          "args": [
            {
              "name": "value",
              "desc": "A required parameter. The maximum drawdown value. It is specified either in money (base currency), or in percentage of maximum equity.  \nFor % of equity the range of allowed values is from 0 to 100.",
              "default": null,
              "required": true,
              "displayType": "simple int|float",
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                0,
                25,
                50,
                75,
                100
              ]
            },
            {
              "name": "displayType",
              "desc": "A required parameter. The type of the value. Please specify one of the following values: [strategy.percent_of_equity](#var_strategy.percent_of_equity) or [strategy.cash](#var_strategy.cash).  \nNote: if equity drops down to zero or to a negative and the 'strategy.percent_of_equity' is specified, all pending orders are cancelled, all open positions are closed and no new orders can be placed for good.",
              "default": null,
              "required": true,
              "displayType": "simple string",
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "strategy.percent_of_equity",
                "strategy.cash"
              ]
            },
            {
              "name": "alert_message",
              "desc": "An optional parameter which replaces the {{strategy.order.alert_message}} placeholder when it is used in the \"Create Alert\" dialog box\\`s \"Message\" field.",
              "default": null,
              "required": false,
              "displayType": "simple string",
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "strategy.risk.max_drawdown(value, type, alert_message) → void",
          "seeAlso": [
            "[strategy.entry](#fun_strategy.entry)",
            "[strategy.exit](#fun_strategy.exit)",
            "[strategy.order](#fun_strategy.order)"
          ],
          "returnedType": "void",
          "detailedDesc": [
            {
              "desc": "",
              "examples": "//@version=5\nstrategy(\"risk.max_drawdown Demo 1\")\nstrategy.risk.max_drawdown(50, strategy.percent_of_equity) // set maximum drawdown to 50% of maximum equity\nplot(strategy.position_size)"
            },
            {
              "desc": "",
              "examples": "//@version=5\nstrategy(\"risk.max_drawdown Demo 2\", currency = \"EUR\")\nstrategy.risk.max_drawdown(2000, strategy.cash)  // set maximum drawdown to 2000 EUR from maximum equity\nplot(strategy.position_size)"
            }
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "box.copy",
          "desc": "Clones the box object.",
          "args": [
            {
              "name": "id",
              "desc": "Box object.",
              "default": null,
              "required": true,
              "displayType": "series box",
              "allowedTypeIDs": [
                "series box"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "box.copy(id) → series box",
          "seeAlso": [
            "[box.new](#fun_box.new)",
            "[box.delete](#fun_box.delete)"
          ],
          "examples": "//@version=5\nindicator('Last 50 bars price ranges', overlay = true)\nLOOKBACK = 50\nhighest = ta.highest(LOOKBACK)\nlowest = ta.lowest(LOOKBACK)\nif barstate.islastconfirmedhistory\n\tvar BoxLast = box.new(bar_index[LOOKBACK], highest, bar_index, lowest, bgcolor = color.new(color.green, 80))\n\tvar BoxPrev = box.copy(BoxLast)\n\tbox.set_lefttop(BoxPrev, bar_index[LOOKBACK * 2], highest[50])\n\tbox.set_rightbottom(BoxPrev, bar_index[LOOKBACK], lowest[50])\n\tbox.set_bgcolor(BoxPrev, color.new(color.red, 80))",
          "returnedType": "box",
          "returnedTypes": [
            "series box"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "box.new",
          "desc": "Creates a new box object.",
          "args": [
            {
              "name": "left",
              "desc": "Bar index (if xloc = [xloc.bar_index](#var_xloc.bar_index)) or UNIX time (if xloc = [xloc.bar_time](#var_xloc.bar_time)) of the left border of the box.  \nNote that objects positioned using [xloc.bar_index](#var_xloc.bar_index) cannot be drawn further than 500 bars into the future.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "bar_index",
                "time"
              ]
            },
            {
              "name": "top",
              "desc": "Price of the top border of the box.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "high",
                "low",
                "open",
                "close",
                "close[1]"
              ]
            },
            {
              "name": "right",
              "desc": "Bar index (if xloc = [xloc.bar_index](#var_xloc.bar_index)) or UNIX time (if xloc = [xloc.bar_time](#var_xloc.bar_time)) of the right border of the box.  \nNote that objects positioned using [xloc.bar_index](#var_xloc.bar_index) cannot be drawn further than 500 bars into the future.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "bar_index",
                "time"
              ]
            },
            {
              "name": "bottom",
              "desc": "Price of the bottom border of the box.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "high",
                "low",
                "open",
                "close",
                "close[1]"
              ]
            },
            {
              "name": "border_color",
              "desc": "Color of the four borders. Optional. The default is [color.blue](#var_color.blue).",
              "default": "color.blue",
              "required": false,
              "displayType": "series color",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "possibleValues": [
                "colors"
              ]
            },
            {
              "name": "border_width",
              "desc": "Width of the four borders, in pixels. Optional. The default is 1 pixel.",
              "default": 1,
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            },
            {
              "name": "border_style",
              "desc": "Style of the four borders.  \nPossible values: [line.style_solid](#var_line.style_solid), [line.style_dotted](#var_line.style_dotted), [line.style_dashed](#var_line.style_dashed).  \nOptional. The default value is [line.style_solid](#var_line.style_solid).",
              "default": "line.style_solid",
              "required": false,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "line.style_solid",
                "line.style_dotted",
                "line.style_dashed"
              ]
            },
            {
              "name": "extend",
              "desc": "When [extend.none](#var_extend.none) is used, the horizontal borders start at the left border and end at the right border.  \nWith [extend.left](#var_extend.left) or [extend.right](#var_extend.right), the horizontal borders are extended indefinitely to the left or right of the box, respectively.  \nWith [extend.both](#var_extend.both), the horizontal borders are extended on both sides.  \nOptional. The default value is [extend.none](#var_extend.none).",
              "default": "extend.none",
              "required": false,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "extend.none",
                "extend.left",
                "extend.right",
                "extend.both"
              ]
            },
            {
              "name": "xloc",
              "desc": "Determines whether the arguments to 'left' and 'right' are a bar index or a time value.  \nIf xloc = [xloc.bar_index](#var_xloc.bar_index), the arguments must be a bar index.  \nIf xloc = [xloc.bar_time](#var_xloc.bar_time), the arguments must be a UNIX time. \nPossible values: [xloc.bar_index](#var_xloc.bar_index) and [xloc.bar_time](#var_xloc.bar_time).  \nOptional. The default is [xloc.bar_index](#var_xloc.bar_index).",
              "default": "xloc.bar_index",
              "required": false,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "xloc.bar_index",
                "xloc.bar_time"
              ]
            },
            {
              "name": "bgcolor",
              "desc": "Background color of the box. Optional. The default is [color.blue](#var_color.blue).",
              "default": "color.blue",
              "required": false,
              "displayType": "series color",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "possibleValues": [
                "colors"
              ]
            },
            {
              "name": "text",
              "desc": "The text to be displayed inside the box. Optional. The default is empty string.",
              "default": "\"\"",
              "required": false,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "text_size",
              "desc": "The size of the text. An optional parameter, the default value is [size.auto](#var_size.auto). \nPossible values: [size.auto](#var_size.auto), [size.tiny](#var_size.tiny), [size.small](#var_size.small), [size.normal](#var_size.normal), [size.large](#var_size.large), [size.huge](#var_size.huge).",
              "default": "size.auto",
              "required": false,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "size.auto",
                "size.tiny",
                "size.small",
                "size.normal",
                "size.large",
                "size.huge"
              ]
            },
            {
              "name": "text_font_family",
              "desc": "The font family of the text. Optional. The default value is [font.family_default](#var_font.family_default). \nPossible values: [font.family_default](#var_font.family_default), [font.family_monospace](#var_font.family_monospace).",
              "default": "font.family_default",
              "required": false,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "font.family_default",
                "font.family_monospace"
              ]
            },
            {
              "name": "text_color",
              "desc": "The color of the text. Optional. The default is [color.black](#var_color.black).",
              "default": "color.black",
              "required": false,
              "displayType": "series color",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "possibleValues": [
                "colors"
              ]
            },
            {
              "name": "text_halign",
              "desc": "The horizontal alignment of the box\\`s text. Optional. The default value is [text.align_center](#var_text.align_center). \nPossible values: [text.align_left](#var_text.align_left), [text.align_center](#var_text.align_center), [text.align_right](#var_text.align_right).",
              "default": "text.align_center",
              "required": false,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "text.align_left",
                "text.align_center",
                "text.align_right"
              ]
            },
            {
              "name": "text_valign",
              "desc": "The vertical alignment of the box\\`s text. Optional. The default value is [text.align_center](#var_text.align_center). \nPossible values: [text.align_top](#var_text.align_top), [text.align_center](#var_text.align_center), [text.align_bottom](#var_text.align_bottom).",
              "default": "text.align_center",
              "required": false,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "text.align_top",
                "text.align_center",
                "text.align_bottom"
              ]
            },
            {
              "name": "text_wrap",
              "desc": "Defines whether the text is presented in a single line, extending past the width of the box if necessary, or wrapped so every line is no wider than the box itself (and clipped by the bottom border of the box if the height of the resulting wrapped text is higher than the height of the box).  \nOptional. The default value is [text.wrap_none](#var_text.wrap_none). \nPossible values: [text.wrap_none](#var_text.wrap_none), [text.wrap_auto](#var_text.wrap_auto).",
              "default": "text.wrap_none",
              "required": false,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "text.wrap_none",
                "text.wrap_auto"
              ]
            },
            {
              "name": "top_left",
              "desc": "A [chart.point](#op_chart.point) object that specifies the top-left corner location of the box.",
              "default": null,
              "required": true,
              "displayType": "chart.point",
              "allowedTypeIDs": [
                "chart.point"
              ],
              "possibleValues": null
            },
            {
              "name": "bottom_right",
              "desc": "A [chart.point](#op_chart.point) object that specifies the bottom-right corner location of the box.",
              "default": null,
              "required": true,
              "displayType": "chart.point",
              "allowedTypeIDs": [
                "chart.point"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "box.new(left, top, right, bottom, border_color, border_width, border_style, extend, xloc, bgcolor, text, text_size, text_color, text_halign, text_valign, text_wrap, text_font_family) → series box\nbox.new(top_left, bottom_right, border_color, border_width, border_style, extend, xloc, bgcolor, text, text_size, text_color, text_halign, text_valign, text_wrap, text_font_family) → series box",
          "returns": "The ID of a box object which may be used in box.set_*() and box.get_*() functions.",
          "seeAlso": [
            "[box.delete](#fun_box.delete)",
            "[box.get_left](#fun_box.get_left)",
            "[box.get_top](#fun_box.get_top)",
            "[box.get_right](#fun_box.get_right)",
            "[box.get_bottom](#fun_box.get_bottom)",
            "[box.set_top_left_point](#fun_box.set_top_left_point)",
            "[box.set_left](#fun_box.set_left)",
            "[box.set_top](#fun_box.set_top)",
            "[box.set_bottom_right_point](#fun_box.set_bottom_right_point)",
            "[box.set_right](#fun_box.set_right)",
            "[box.set_bottom](#fun_box.set_bottom)",
            "[box.set_border_color](#fun_box.set_border_color)",
            "[box.set_bgcolor](#fun_box.set_bgcolor)",
            "[box.set_border_width](#fun_box.set_border_width)",
            "[box.set_border_style](#fun_box.set_border_style)",
            "[box.set_extend](#fun_box.set_extend)"
          ],
          "examples": "//@version=5\nindicator(\"box.new\")\nvar b = box.new(time, open, time + 60 * 60 * 24, close, xloc=xloc.bar_time, border_style=line.style_dashed)\nbox.set_lefttop(b, time, 100)\nbox.set_rightbottom(b, time + 60 * 60 * 24, 500)\nbox.set_bgcolor(b, color.green)",
          "returnedType": "box",
          "returnedTypes": [
            "series box"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "box.delete",
          "desc": "Deletes the specified box object. If it has already been deleted, does nothing.",
          "args": [
            {
              "name": "id",
              "desc": "A box object to delete.",
              "default": null,
              "required": true,
              "displayType": "series box",
              "allowedTypeIDs": [
                "series box"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "box.delete(id) → void",
          "seeAlso": [
            "[box.new](#fun_box.new)"
          ],
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "box.get_left",
          "desc": "Returns the bar index or the UNIX time (depending on the last value used for 'xloc') of the left border of the box.",
          "args": [
            {
              "name": "id",
              "desc": "A box object.",
              "default": null,
              "required": true,
              "displayType": "series box",
              "allowedTypeIDs": [
                "series box"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "box.get_left(id) → series int",
          "returns": "A bar index or a UNIX timestamp (in milliseconds).",
          "seeAlso": [
            "[box.new](#fun_box.new)",
            "[box.set_left](#fun_box.set_left)"
          ],
          "returnedType": "int",
          "returnedTypes": [
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "box.get_right",
          "desc": "Returns the bar index or the UNIX time (depending on the last value used for 'xloc') of the right border of the box.",
          "args": [
            {
              "name": "id",
              "desc": "A box object.",
              "default": null,
              "required": true,
              "displayType": "series box",
              "allowedTypeIDs": [
                "series box"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "box.get_right(id) → series int",
          "returns": "A bar index or a UNIX timestamp (in milliseconds).",
          "seeAlso": [
            "[box.new](#fun_box.new)",
            "[box.set_right](#fun_box.set_right)"
          ],
          "returnedType": "int",
          "returnedTypes": [
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "box.get_top",
          "desc": "Returns the price value of the top border of the box.",
          "args": [
            {
              "name": "id",
              "desc": "A box object.",
              "default": null,
              "required": true,
              "displayType": "series box",
              "allowedTypeIDs": [
                "series box"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "box.get_top(id) → series float",
          "returns": "The price value.",
          "seeAlso": [
            "[box.new](#fun_box.new)",
            "[box.set_top](#fun_box.set_top)"
          ],
          "returnedType": "float",
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "box.get_bottom",
          "desc": "Returns the price value of the bottom border of the box.",
          "args": [
            {
              "name": "id",
              "desc": "A box object.",
              "default": null,
              "required": true,
              "displayType": "series box",
              "allowedTypeIDs": [
                "series box"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "box.get_bottom(id) → series float",
          "returns": "The price value.",
          "seeAlso": [
            "[box.new](#fun_box.new)",
            "[box.set_bottom](#fun_box.set_bottom)"
          ],
          "returnedType": "float",
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "box.set_left",
          "desc": "Sets the left coordinate of the box.",
          "args": [
            {
              "name": "id",
              "desc": "A box object.",
              "default": null,
              "required": true,
              "displayType": "series box",
              "allowedTypeIDs": [
                "series box"
              ],
              "possibleValues": null
            },
            {
              "name": "left",
              "desc": "Bar index or bar time of the left border. Note that objects positioned using [xloc.bar_index](#var_xloc.bar_index) cannot be drawn further than 500 bars into the future.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "bar_index",
                "time"
              ]
            }
          ],
          "syntax": "box.set_left(id, left) → void",
          "seeAlso": [
            "[box.new](#fun_box.new)",
            "[box.get_left](#fun_box.get_left)"
          ],
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "box.set_lefttop",
          "desc": "Sets the left and top coordinates of the box.",
          "args": [
            {
              "name": "id",
              "desc": "A box object.",
              "default": null,
              "required": true,
              "displayType": "series box",
              "allowedTypeIDs": [
                "series box"
              ],
              "possibleValues": null
            },
            {
              "name": "left",
              "desc": "Bar index or bar time of the left border.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "time",
                "bar_index",
                "time_close",
                "last_bar_index",
                "last_bar_time"
              ]
            },
            {
              "name": "top",
              "desc": "Price value of the top border.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "high",
                "low",
                "open",
                "close",
                "hl2"
              ]
            }
          ],
          "syntax": "box.set_lefttop(id, left, top) → void",
          "seeAlso": [
            "[box.new](#fun_box.new)",
            "[box.get_left](#fun_box.get_left)",
            "[box.get_top](#fun_box.get_top)"
          ],
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "box.set_right",
          "desc": "Sets the right coordinate of the box.",
          "args": [
            {
              "name": "id",
              "desc": "A box object.",
              "default": null,
              "required": true,
              "displayType": "series box",
              "allowedTypeIDs": [
                "series box"
              ],
              "possibleValues": null
            },
            {
              "name": "right",
              "desc": "Bar index or bar time of the right border. Note that objects positioned using [xloc.bar_index](#var_xloc.bar_index) cannot be drawn further than 500 bars into the future.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "bar_index",
                "time"
              ]
            }
          ],
          "syntax": "box.set_right(id, right) → void",
          "seeAlso": [
            "[box.new](#fun_box.new)",
            "[box.get_right](#fun_box.get_right)"
          ],
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "box.set_rightbottom",
          "desc": "Sets the right and bottom coordinates of the box.",
          "args": [
            {
              "name": "id",
              "desc": "A box object.",
              "default": null,
              "required": true,
              "displayType": "series box",
              "allowedTypeIDs": [
                "series box"
              ],
              "possibleValues": null
            },
            {
              "name": "right",
              "desc": "Bar index or bar time of the right border.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "time",
                "bar_index",
                "time_close",
                "last_bar_index",
                "last_bar_time"
              ]
            },
            {
              "name": "bottom",
              "desc": "Price value of the bottom border.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "box.set_rightbottom(id, right, bottom) → void",
          "seeAlso": [
            "[box.new](#fun_box.new)",
            "[box.get_right](#fun_box.get_right)",
            "[box.get_bottom](#fun_box.get_bottom)"
          ],
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "box.set_top",
          "desc": "Sets the top coordinate of the box.",
          "args": [
            {
              "name": "id",
              "desc": "A box object.",
              "default": null,
              "required": true,
              "displayType": "series box",
              "allowedTypeIDs": [
                "series box"
              ],
              "possibleValues": null
            },
            {
              "name": "top",
              "desc": "Price value of the top border.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "box.set_top(id, top) → void",
          "seeAlso": [
            "[box.new](#fun_box.new)",
            "[box.get_top](#fun_box.get_top)"
          ],
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "box.set_bottom",
          "desc": "Sets the bottom coordinate of the box.",
          "args": [
            {
              "name": "id",
              "desc": "A box object.",
              "default": null,
              "required": true,
              "displayType": "series box",
              "allowedTypeIDs": [
                "series box"
              ],
              "possibleValues": null
            },
            {
              "name": "bottom",
              "desc": "Price value of the bottom border.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "box.set_bottom(id, bottom) → void",
          "seeAlso": [
            "[box.new](#fun_box.new)",
            "[box.get_bottom](#fun_box.get_bottom)"
          ],
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "box.set_border_color",
          "desc": "Sets the border color of the box.",
          "args": [
            {
              "name": "id",
              "desc": "A box object.",
              "default": null,
              "required": true,
              "displayType": "series box",
              "allowedTypeIDs": [
                "series box"
              ],
              "possibleValues": null
            },
            {
              "name": "color",
              "desc": "New border color.",
              "default": null,
              "required": true,
              "displayType": "series color",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "possibleValues": [
                "colors"
              ]
            }
          ],
          "syntax": "box.set_border_color(id, color) → void",
          "seeAlso": [
            "[box.new](#fun_box.new)"
          ],
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "box.set_bgcolor",
          "desc": "Sets the background color of the box.",
          "args": [
            {
              "name": "id",
              "desc": "A box object.",
              "default": null,
              "required": true,
              "displayType": "series box",
              "allowedTypeIDs": [
                "series box"
              ],
              "possibleValues": null
            },
            {
              "name": "color",
              "desc": "New background color.",
              "default": null,
              "required": true,
              "displayType": "series color",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "possibleValues": [
                "colors"
              ]
            }
          ],
          "syntax": "box.set_bgcolor(id, color) → void",
          "seeAlso": [
            "[box.new](#fun_box.new)"
          ],
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "box.set_border_width",
          "desc": "Sets the border width of the box.",
          "args": [
            {
              "name": "id",
              "desc": "A box object.",
              "default": null,
              "required": true,
              "displayType": "series box",
              "allowedTypeIDs": [
                "series box"
              ],
              "possibleValues": null
            },
            {
              "name": "width",
              "desc": "Width of the four borders, in pixels.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            }
          ],
          "syntax": "box.set_border_width(id, width) → void",
          "seeAlso": [
            "[box.new](#fun_box.new)"
          ],
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "box.set_border_style",
          "desc": "Sets the border style of the box.",
          "args": [
            {
              "name": "id",
              "desc": "A box object.",
              "default": null,
              "required": true,
              "displayType": "series box",
              "allowedTypeIDs": [
                "series box"
              ],
              "possibleValues": null
            },
            {
              "name": "style",
              "desc": "New border style.",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "line.style_solid",
                "line.style_dotted",
                "line.style_dashed"
              ]
            }
          ],
          "syntax": "box.set_border_style(id, style) → void",
          "seeAlso": [
            "[box.new](#fun_box.new)",
            "[line.style_solid](#const_line.style_solid)",
            "[line.style_dotted](#const_line.style_dotted)",
            "[line.style_dashed](#const_line.style_dashed)"
          ],
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "box.set_extend",
          "desc": "Sets extending type of the border of this box object. When [extend.none](#var_extend.none) is used, the horizontal borders start at the left border and end at the right border.  \nWith [extend.left](#var_extend.left) or [extend.right](#var_extend.right), the horizontal borders are extended indefinitely to the left or right of the box, respectively.  \nWith [extend.both](#var_extend.both), the horizontal borders are extended on both sides.",
          "args": [
            {
              "name": "id",
              "desc": "A box object.",
              "default": null,
              "required": true,
              "displayType": "series box",
              "allowedTypeIDs": [
                "series box"
              ],
              "possibleValues": null
            },
            {
              "name": "extend",
              "desc": "New extending type.",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "extend.none",
                "extend.right",
                "extend.left",
                "extend.both"
              ]
            }
          ],
          "syntax": "box.set_extend(id, extend) → void",
          "seeAlso": [
            "[box.new](#fun_box.new)",
            "[extend.none](#const_extend.none)",
            "[extend.right](#const_extend.right)",
            "[extend.left](#const_extend.left)",
            "[extend.both](#const_extend.both)"
          ],
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "box.set_text_font_family",
          "desc": "The function sets the font family of the text inside the box.",
          "args": [
            {
              "name": "id",
              "desc": "A box object.",
              "default": null,
              "required": true,
              "displayType": "series box",
              "allowedTypeIDs": [
                "series box"
              ],
              "possibleValues": null
            },
            {
              "name": "text_font_family",
              "desc": "The font family of the text.  \nPossible values: [font.family_default](#var_font.family_default), [font.family_monospace](#var_font.family_monospace).",
              "default": "font.family_default",
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "font.family_default",
                "font.family_monospace"
              ]
            }
          ],
          "syntax": "box.set_text_font_family(id, text_font_family) → void",
          "seeAlso": [
            "[box.new](#fun_box.new)",
            "[font.family_default](#const_font.family_default)",
            "[font.family_monospace](#const_font.family_monospace)"
          ],
          "examples": "//@version=5\nindicator(\"Example of setting the box font\")\nif barstate.islastconfirmedhistory\n    b = box.new(bar_index, open-ta.tr, bar_index-50, open-ta.tr*5, text=\"monospace\")\n    box.set_text_font_family(b, font.family_monospace)",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "box.set_text_halign",
          "desc": "The function sets the horizontal alignment of the box\\`s text.",
          "args": [
            {
              "name": "id",
              "desc": "A box object.",
              "default": null,
              "required": true,
              "displayType": "series box",
              "allowedTypeIDs": [
                "series box"
              ],
              "possibleValues": null
            },
            {
              "name": "text_halign",
              "desc": "The horizontal alignment of a box\\`s text.  \nPossible values: [text.align_left](#var_text.align_left), [text.align_center](#var_text.align_center), [text.align_right](#var_text.align_right).",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "text.align_left",
                "text.align_center",
                "text.align_right"
              ]
            }
          ],
          "syntax": "box.set_text_halign(id, text_halign) → void",
          "seeAlso": [
            "[box.set_text](#fun_box.set_text)",
            "[box.set_text_size](#fun_box.set_text_size)",
            "[box.set_text_valign](#fun_box.set_text_valign)",
            "[box.set_text_color](#fun_box.set_text_color)"
          ],
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "box.set_text_valign",
          "desc": "The function sets the vertical alignment of a box\\`s text.",
          "args": [
            {
              "name": "id",
              "desc": "A box object.",
              "default": null,
              "required": true,
              "displayType": "series box",
              "allowedTypeIDs": [
                "series box"
              ],
              "possibleValues": null
            },
            {
              "name": "text_valign",
              "desc": "The vertical alignment of the box\\`s text.  \nPossible values: [text.align_top](#var_text.align_top), [text.align_center](#var_text.align_center), [text.align_bottom](#var_text.align_bottom).",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "text.align_top",
                "text.align_center",
                "text.align_bottom"
              ]
            }
          ],
          "syntax": "box.set_text_valign(id, text_valign) → void",
          "seeAlso": [
            "[box.set_text](#fun_box.set_text)",
            "[box.set_text_size](#fun_box.set_text_size)",
            "[box.set_text_color](#fun_box.set_text_color)",
            "[box.set_text_halign](#fun_box.set_text_halign)"
          ],
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "box.set_text_size",
          "desc": "The function sets the size of the box\\`s text.",
          "args": [
            {
              "name": "id",
              "desc": "A box object.",
              "default": null,
              "required": true,
              "displayType": "series box",
              "allowedTypeIDs": [
                "series box"
              ],
              "possibleValues": null
            },
            {
              "name": "text_size",
              "desc": "The size of the text.  \nPossible values: [size.auto](#var_size.auto), [size.tiny](#var_size.tiny), [size.small](#var_size.small), [size.normal](#var_size.normal), [size.large](#var_size.large), [size.huge](#var_size.huge).",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "size.auto",
                "size.tiny",
                "size.small",
                "size.normal",
                "size.large",
                "size.huge"
              ]
            }
          ],
          "syntax": "box.set_text_size(id, text_size) → void",
          "seeAlso": [
            "[box.set_text](#fun_box.set_text)",
            "[box.set_text_color](#fun_box.set_text_color)",
            "[box.set_text_valign](#fun_box.set_text_valign)",
            "[box.set_text_halign](#fun_box.set_text_halign)"
          ],
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "box.set_text",
          "desc": "The function sets the text in the box.",
          "args": [
            {
              "name": "id",
              "desc": "A box object.",
              "default": null,
              "required": true,
              "displayType": "series box",
              "allowedTypeIDs": [
                "series box"
              ],
              "possibleValues": null
            },
            {
              "name": "text",
              "desc": "The text to be displayed inside the box.",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "box.set_text(id, text) → void",
          "seeAlso": [
            "[box.set_text_color](#fun_box.set_text_color)",
            "[box.set_text_size](#fun_box.set_text_size)",
            "[box.set_text_valign](#fun_box.set_text_valign)",
            "[box.set_text_halign](#fun_box.set_text_halign)"
          ],
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "box.set_text_color",
          "desc": "The function sets the color of the text inside the box.",
          "args": [
            {
              "name": "id",
              "desc": "A box object.",
              "default": null,
              "required": true,
              "displayType": "series box",
              "allowedTypeIDs": [
                "series box"
              ],
              "possibleValues": null
            },
            {
              "name": "text_color",
              "desc": "The color of the text.",
              "default": null,
              "required": true,
              "displayType": "series color",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "possibleValues": [
                "colors"
              ]
            }
          ],
          "syntax": "box.set_text_color(id, text_color) → void",
          "seeAlso": [
            "[box.set_text](#fun_box.set_text)",
            "[box.set_text_size](#fun_box.set_text_size)",
            "[box.set_text_valign](#fun_box.set_text_valign)",
            "[box.set_text_halign](#fun_box.set_text_halign)"
          ],
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "line.copy",
          "desc": "Clones the line object.",
          "args": [
            {
              "name": "id",
              "desc": "Line object.",
              "default": null,
              "required": true,
              "displayType": "series line",
              "allowedTypeIDs": [
                "series line"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "line.copy(id) → series line",
          "returns": "New line ID object which may be passed to line.setXXX and line.getXXX functions.",
          "seeAlso": [
            "[line.new](#fun_line.new)",
            "[line.delete](#fun_line.delete)"
          ],
          "examples": "//@version=5\nindicator('Last 100 bars price range', overlay = true)\nLOOKBACK = 100\nhighest = ta.highest(LOOKBACK)\nlowest = ta.lowest(LOOKBACK)\nif barstate.islastconfirmedhistory\n\tvar lineTop = line.new(bar_index[LOOKBACK], highest, bar_index, highest, color = color.green)\n\tvar lineBottom = line.copy(lineTop)\n\tline.set_y1(lineBottom, lowest)\n\tline.set_y2(lineBottom, lowest)\n\tline.set_color(lineBottom, color.red)",
          "returnedType": "line",
          "returnedTypes": [
            "series line"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "box.set_text_wrap",
          "desc": "The function sets the mode of wrapping of the text inside the box.",
          "args": [
            {
              "name": "id",
              "desc": "A box object.",
              "default": null,
              "required": true,
              "displayType": "series box",
              "allowedTypeIDs": [
                "series box"
              ],
              "possibleValues": null
            },
            {
              "name": "text_wrap",
              "desc": "The mode of the wrapping.  \nPossible values: [text.wrap_auto](#var_text.wrap_auto), [text.wrap_none](#var_text.wrap_none).",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "text.wrap_auto",
                "text.wrap_none"
              ]
            }
          ],
          "syntax": "box.set_text_wrap(id, text_wrap) → void",
          "seeAlso": [
            "[box.set_text](#fun_box.set_text)",
            "[box.set_text_size](#fun_box.set_text_size)",
            "[box.set_text_valign](#fun_box.set_text_valign)",
            "[box.set_text_halign](#fun_box.set_text_halign)",
            "[box.set_text_color](#fun_box.set_text_color)"
          ],
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "line.new",
          "desc": "Creates new line object.",
          "args": [
            {
              "name": "x1",
              "desc": "Bar index (if xloc = [xloc.bar_index](#var_xloc.bar_index)) or bar UNIX time (if xloc = [xloc.bar_time](#var_xloc.bar_time)) of the first point of the line.  \nNote that objects positioned using [xloc.bar_index](#var_xloc.bar_index) cannot be drawn further than 500 bars into the future.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "bar_index",
                "time"
              ]
            },
            {
              "name": "y1",
              "desc": "Price of the first point of the line.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "close",
                "high",
                "low",
                "open"
              ]
            },
            {
              "name": "x2",
              "desc": "Bar index (if xloc = [xloc.bar_index](#var_xloc.bar_index)) or bar UNIX time (if xloc = [xloc.bar_time](#var_xloc.bar_time)) of the second point of the line.  \nNote that objects positioned using [xloc.bar_index](#var_xloc.bar_index) cannot be drawn further than 500 bars into the future.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "bar_index",
                "time"
              ]
            },
            {
              "name": "y2",
              "desc": "Price of the second point of the line.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "close",
                "high",
                "low",
                "open"
              ]
            },
            {
              "name": "xloc",
              "desc": "See description of **x1** argument.  \nPossible values: [xloc.bar_index](#var_xloc.bar_index) and [xloc.bar_time](#var_xloc.bar_time).  \nDefault is [xloc.bar_index](#var_xloc.bar_index).",
              "default": "xloc.bar_index",
              "required": false,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "xloc.bar_time",
                "xloc.bar_index"
              ]
            },
            {
              "name": "extend",
              "desc": "If extend=[extend.none](#var_extend.none), draws segment starting at point (x1, y1) and ending at point (x2, y2).  \nIf extend is equal to [extend.right](#var_extend.right) or [extend.left](#var_extend.left), draws a ray starting at point (x1, y1) or (x2, y2), respectively.  \nIf extend=[extend.both](#var_extend.both), draws a straight line that goes through these points.  \nDefault value is [extend.none](#var_extend.none).",
              "default": "extend.none",
              "required": false,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "extend.none",
                "extend.right",
                "extend.left",
                "extend.both"
              ]
            },
            {
              "name": "color",
              "desc": "Line color.",
              "default": "color.blue",
              "required": false,
              "displayType": "series color",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "possibleValues": [
                "colors"
              ]
            },
            {
              "name": "width",
              "desc": "Line width in pixels.",
              "default": 1,
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            },
            {
              "name": "style",
              "desc": "Line style.  \nPossible values: [line.style_solid](#var_line.style_solid), [line.style_dotted](#var_line.style_dotted), [line.style_dashed](#var_line.style_dashed), [line.style_arrow_left](#var_line.style_arrow_left), [line.style_arrow_right](#var_line.style_arrow_right), [line.style_arrow_both](#var_line.style_arrow_both).",
              "default": "line.style_solid",
              "required": false,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "line.style_solid",
                "line.style_dotted",
                "line.style_dashed",
                "line.style_arrow_left",
                "line.style_arrow_right",
                "line.style_arrow_both"
              ]
            },
            {
              "name": "first_point",
              "desc": "A [chart.point](#op_chart.point) object that specifies the line\\`s starting coordinate.",
              "default": null,
              "required": true,
              "displayType": "chart.point",
              "allowedTypeIDs": [
                "chart.point"
              ],
              "possibleValues": null
            },
            {
              "name": "second_point",
              "desc": "A [chart.point](#op_chart.point) object that specifies the line\\`s ending coordinate.",
              "default": null,
              "required": true,
              "displayType": "chart.point",
              "allowedTypeIDs": [
                "chart.point"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "line.new(x1, y1, x2, y2, xloc, extend, color, style, width) → series line\nline.new(first_point, second_point, xloc, extend, color, style, width) → series line",
          "returns": "Line ID object which may be passed to line.setXXX and line.getXXX functions.",
          "seeAlso": [
            "[line.delete](#fun_line.delete)",
            "[line.set_x1](#fun_line.set_x1)",
            "[line.set_y1](#fun_line.set_y1)",
            "[line.set_xy1](#fun_line.set_xy1)",
            "[line.set_x2](#fun_line.set_x2)",
            "[line.set_y2](#fun_line.set_y2)",
            "[line.set_xy2](#fun_line.set_xy2)",
            "[line.set_xloc](#fun_line.set_xloc)",
            "[line.set_color](#fun_line.set_color)",
            "[line.set_extend](#fun_line.set_extend)",
            "[line.set_style](#fun_line.set_style)",
            "[line.set_width](#fun_line.set_width)"
          ],
          "examples": "//@version=5\nindicator(\"line.new\")\nvar line1 = line.new(0, low, bar_index, high, extend=extend.right)\nvar line2 = line.new(time, open, time + 60 * 60 * 24, close, xloc=xloc.bar_time, style=line.style_dashed)\nline.set_x2(line1, 0)\nline.set_xloc(line1, time, time + 60 * 60 * 24, xloc.bar_time)\nline.set_color(line2, color.green)\nline.set_width(line2, 5)",
          "returnedType": "line",
          "returnedTypes": [
            "series line"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "line.set_x1",
          "desc": "Sets bar index or bar time (depending on the xloc) of the first point.",
          "args": [
            {
              "name": "id",
              "desc": "Line object.",
              "default": null,
              "required": true,
              "displayType": "series line",
              "allowedTypeIDs": [
                "series line"
              ],
              "possibleValues": null
            },
            {
              "name": "x",
              "desc": "Bar index or bar time. Note that objects positioned using [xloc.bar_index](#var_xloc.bar_index) cannot be drawn further than 500 bars into the future.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "time",
                "bar_index",
                "time_close",
                "last_bar_index",
                "last_bar_time"
              ]
            }
          ],
          "syntax": "line.set_x1(id, x) → void",
          "seeAlso": [
            "[line.new](#fun_line.new)"
          ],
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "line.set_y1",
          "desc": "Sets price of the first point",
          "args": [
            {
              "name": "id",
              "desc": "Line object.",
              "default": null,
              "required": true,
              "displayType": "series line",
              "allowedTypeIDs": [
                "series line"
              ],
              "possibleValues": null
            },
            {
              "name": "y",
              "desc": "Price.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "high",
                "low",
                "open",
                "close",
                "close[1]"
              ]
            }
          ],
          "syntax": "line.set_y1(id, y) → void",
          "seeAlso": [
            "[line.new](#fun_line.new)"
          ],
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "line.set_xy1",
          "desc": "Sets bar index/time and price of the first point.",
          "args": [
            {
              "name": "id",
              "desc": "Line object.",
              "default": null,
              "required": true,
              "displayType": "series line",
              "allowedTypeIDs": [
                "series line"
              ],
              "possibleValues": null
            },
            {
              "name": "x",
              "desc": "Bar index or bar time. Note that objects positioned using [xloc.bar_index](#var_xloc.bar_index) cannot be drawn further than 500 bars into the future.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "time",
                "bar_index",
                "time_close",
                "last_bar_index",
                "last_bar_time"
              ]
            },
            {
              "name": "y",
              "desc": "Price.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "line.set_xy1(id, x, y) → void",
          "seeAlso": [
            "[line.new](#fun_line.new)"
          ],
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "line.set_x2",
          "desc": "Sets bar index or bar time (depending on the xloc) of the second point.",
          "args": [
            {
              "name": "id",
              "desc": "Line object.",
              "default": null,
              "required": true,
              "displayType": "series line",
              "allowedTypeIDs": [
                "series line"
              ],
              "possibleValues": null
            },
            {
              "name": "x",
              "desc": "Bar index or bar time. Note that objects positioned using [xloc.bar_index](#var_xloc.bar_index) cannot be drawn further than 500 bars into the future.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "time",
                "bar_index",
                "time_close",
                "last_bar_index",
                "last_bar_time"
              ]
            }
          ],
          "syntax": "line.set_x2(id, x) → void",
          "seeAlso": [
            "[line.new](#fun_line.new)"
          ],
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "line.set_y2",
          "desc": "Sets price of the second point.",
          "args": [
            {
              "name": "id",
              "desc": "Line object.",
              "default": null,
              "required": true,
              "displayType": "series line",
              "allowedTypeIDs": [
                "series line"
              ],
              "possibleValues": null
            },
            {
              "name": "y",
              "desc": "Price.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "line.set_y2(id, y) → void",
          "seeAlso": [
            "[line.new](#fun_line.new)"
          ],
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "line.set_xy2",
          "desc": "Sets bar index/time and price of the second point",
          "args": [
            {
              "name": "id",
              "desc": "Line object.",
              "default": null,
              "required": true,
              "displayType": "series line",
              "allowedTypeIDs": [
                "series line"
              ],
              "possibleValues": null
            },
            {
              "name": "x",
              "desc": "Bar index or bar time.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "bar_index",
                "time",
                "time_close",
                "last_bar_index",
                "last_bar_time"
              ]
            },
            {
              "name": "y",
              "desc": "Price.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "high",
                "low",
                "open",
                "close",
                "close[1]"
              ]
            }
          ],
          "syntax": "line.set_xy2(id, x, y) → void",
          "seeAlso": [
            "[line.new](#fun_line.new)"
          ],
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "line.set_xloc",
          "desc": "Sets x-location and new bar index/time values.",
          "args": [
            {
              "name": "id",
              "desc": "Line object.",
              "default": null,
              "required": true,
              "displayType": "series line",
              "allowedTypeIDs": [
                "series line"
              ],
              "possibleValues": null
            },
            {
              "name": "x1",
              "desc": "Bar index or bar time of the first point.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "time",
                "bar_index",
                "time_close",
                "last_bar_index",
                "last_bar_time"
              ]
            },
            {
              "name": "x2",
              "desc": "Bar index or bar time of the second point.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "time",
                "bar_index",
                "time_close",
                "last_bar_index",
                "last_bar_time"
              ]
            },
            {
              "name": "xloc",
              "desc": "New x-location value.",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "xloc.bar_index",
                "xloc.bar_time"
              ]
            }
          ],
          "syntax": "line.set_xloc(id, x1, x2, xloc) → void",
          "seeAlso": [
            "[xloc.bar_index](#const_xloc.bar_index)",
            "[xloc.bar_time](#const_xloc.bar_time)",
            "[line.new](#fun_line.new)"
          ],
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "line.set_extend",
          "desc": "Sets extending type of this line object. If extend=[extend.none](#var_extend.none), draws segment starting at point (x1, y1) and ending at point (x2, y2).  \nIf extend is equal to [extend.right](#var_extend.right) or [extend.left](#var_extend.left), draws a ray starting at point (x1, y1) or (x2, y2), respectively.  \nIf extend=[extend.both](#var_extend.both), draws a straight line that goes through these points.",
          "args": [
            {
              "name": "id",
              "desc": "Line object.",
              "default": null,
              "required": true,
              "displayType": "series line",
              "allowedTypeIDs": [
                "series line"
              ],
              "possibleValues": null
            },
            {
              "name": "extend",
              "desc": "New extending type.",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "extend.none",
                "extend.right",
                "extend.left",
                "extend.both"
              ]
            }
          ],
          "syntax": "line.set_extend(id, extend) → void",
          "seeAlso": [
            "[extend.none](#const_extend.none)",
            "[extend.right](#const_extend.right)",
            "[extend.left](#const_extend.left)",
            "[extend.both](#const_extend.both)",
            "[line.new](#fun_line.new)"
          ],
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "line.set_color",
          "desc": "Sets the line color",
          "args": [
            {
              "name": "id",
              "desc": "Line object.",
              "default": null,
              "required": true,
              "displayType": "series line",
              "allowedTypeIDs": [
                "series line"
              ],
              "possibleValues": null
            },
            {
              "name": "color",
              "desc": "New line color",
              "default": null,
              "required": true,
              "displayType": "series color",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "possibleValues": [
                "colors"
              ]
            }
          ],
          "syntax": "line.set_color(id, color) → void",
          "seeAlso": [
            "[line.new](#fun_line.new)"
          ],
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "line.set_style",
          "desc": "Sets the line style",
          "args": [
            {
              "name": "id",
              "desc": "Line object.",
              "default": null,
              "required": true,
              "displayType": "series line",
              "allowedTypeIDs": [
                "series line"
              ],
              "possibleValues": null
            },
            {
              "name": "style",
              "desc": "New line style.",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "line.style_solid",
                "line.style_dotted",
                "line.style_dashed",
                "line.style_arrow_left",
                "line.style_arrow_right",
                "line.style_arrow_both"
              ]
            }
          ],
          "syntax": "line.set_style(id, style) → void",
          "seeAlso": [
            "[line.style_solid](#const_line.style_solid)",
            "[line.style_dotted](#const_line.style_dotted)",
            "[line.style_dashed](#const_line.style_dashed)",
            "[line.style_arrow_left](#const_line.style_arrow_left)",
            "[line.style_arrow_right](#const_line.style_arrow_right)",
            "[line.style_arrow_both](#const_line.style_arrow_both)",
            "[line.new](#fun_line.new)"
          ],
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "line.set_width",
          "desc": "Sets the line width.",
          "args": [
            {
              "name": "id",
              "desc": "Line object.",
              "default": null,
              "required": true,
              "displayType": "series line",
              "allowedTypeIDs": [
                "series line"
              ],
              "possibleValues": null
            },
            {
              "name": "width",
              "desc": "New line width in pixels.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            }
          ],
          "syntax": "line.set_width(id, width) → void",
          "seeAlso": [
            "[line.new](#fun_line.new)"
          ],
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "line.delete",
          "desc": "Deletes the specified line object. If it has already been deleted, does nothing.",
          "args": [
            {
              "name": "id",
              "desc": "Line object to delete.",
              "default": null,
              "required": true,
              "displayType": "series line",
              "allowedTypeIDs": [
                "series line"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "line.delete(id) → void",
          "seeAlso": [
            "[line.new](#fun_line.new)"
          ],
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "line.get_x1",
          "desc": "Returns UNIX time or bar index (depending on the last xloc value set) of the first point of the line.",
          "args": [
            {
              "name": "id",
              "desc": "Line object.",
              "default": null,
              "required": true,
              "displayType": "series line",
              "allowedTypeIDs": [
                "series line"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "line.get_x1(id) → series int",
          "returns": "UNIX timestamp (in milliseconds) or bar index.",
          "seeAlso": [
            "[line.new](#fun_line.new)"
          ],
          "examples": "//@version=5\nindicator(\"line.get_x1\")\nmy_line = line.new(time, open, time + 60 * 60 * 24, close, xloc=xloc.bar_time)\na = line.get_x1(my_line)\nplot(time - line.get_x1(my_line)) //draws zero plot",
          "returnedType": "int",
          "returnedTypes": [
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "line.get_y1",
          "desc": "Returns price of the first point of the line.",
          "args": [
            {
              "name": "id",
              "desc": "Line object.",
              "default": null,
              "required": true,
              "displayType": "series line",
              "allowedTypeIDs": [
                "series line"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "line.get_y1(id) → series float",
          "returns": "Price value.",
          "seeAlso": [
            "[line.new](#fun_line.new)"
          ],
          "returnedType": "float",
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "line.get_x2",
          "desc": "Returns UNIX time or bar index (depending on the last xloc value set) of the second point of the line.",
          "args": [
            {
              "name": "id",
              "desc": "Line object.",
              "default": null,
              "required": true,
              "displayType": "series line",
              "allowedTypeIDs": [
                "series line"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "line.get_x2(id) → series int",
          "returns": "UNIX timestamp (in milliseconds) or bar index.",
          "seeAlso": [
            "[line.new](#fun_line.new)"
          ],
          "returnedType": "int",
          "returnedTypes": [
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "line.get_y2",
          "desc": "Returns price of the second point of the line.",
          "args": [
            {
              "name": "id",
              "desc": "Line object.",
              "default": null,
              "required": true,
              "displayType": "series line",
              "allowedTypeIDs": [
                "series line"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "line.get_y2(id) → series float",
          "returns": "Price value.",
          "seeAlso": [
            "[line.new](#fun_line.new)"
          ],
          "returnedType": "float",
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "line.get_price",
          "desc": "Returns the price level of a line at a given bar index.",
          "args": [
            {
              "name": "id",
              "desc": "Line object.",
              "default": null,
              "required": true,
              "displayType": "series line",
              "allowedTypeIDs": [
                "series line"
              ],
              "possibleValues": null
            },
            {
              "name": "x",
              "desc": "Bar index for which price is required.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "bar_index"
              ]
            }
          ],
          "syntax": "line.get_price(id, x) → series float",
          "remarks": "The line is considered to have been created using 'extend=extend.both'.\nThis function can only be called for lines created using 'xloc.bar_index'.  \nIf you try to call it for a line created with 'xloc.bar_time', it will generate an error.",
          "returns": "Price value of line 'id' at bar index 'x'.",
          "seeAlso": [
            "[line.new](#fun_line.new)"
          ],
          "examples": "//@version=5\nindicator(\"GetPrice\", overlay=true)\nvar line l = na\nif bar_index == 10\n    l := line.new(0, high[5], bar_index, high)\nplot(line.get_price(l, bar_index), color=color.green)",
          "returnedType": "float",
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "linefill.new",
          "desc": "Creates a new linefill object and displays it on the chart, filling the space between `line1` and `line2` with the color specified in `color`.",
          "args": [
            {
              "name": "line1",
              "desc": "First line object.",
              "default": null,
              "required": true,
              "displayType": "series line",
              "allowedTypeIDs": [
                "series line"
              ],
              "possibleValues": null
            },
            {
              "name": "line2",
              "desc": "Second line object.",
              "default": null,
              "required": true,
              "displayType": "series line",
              "allowedTypeIDs": [
                "series line"
              ],
              "possibleValues": null
            },
            {
              "name": "color",
              "desc": "The color used to fill the space between the lines.",
              "default": null,
              "required": true,
              "displayType": "series color",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "possibleValues": [
                "colors"
              ]
            }
          ],
          "syntax": "linefill.new(line1, line2, color) → series linefill",
          "remarks": "If any line of the two is deleted, the linefill object is also deleted.  \nIf the lines are moved (e.g. via [line.set_xy](#fun_line.set_xy) functions), the linefill object is also moved.  \nIf both lines are extended in the same direction relative to the lines themselves (e.g.both have [extend.right](#var_extend.right) as the value of their `extend=` parameter),  \nthe space between line extensions will also be filled.",
          "returns": "The ID of a linefill object that can be passed to other linefill.*() functions.",
          "seeAlso": [
            "[linefill.delete](#fun_linefill.delete)",
            "[linefill.set_color](#fun_linefill.set_color)",
            "[linefill.get_line1](#fun_linefill.get_line1)",
            "[linefill.get_line2](#fun_linefill.get_line2)",
            "[line.get_price](#fun_line.get_price)"
          ],
          "examples": "//@version=5\nindicator(\"My Script\")\n\nvar line l1 = na\nvar line l2 = na\nvar linefill lf = na\n\nif bar_index == 10\n    l1 := line.new(0, high[5], bar_index, high)\n    l2 := line.new(0, low[5], bar_index, low)\n    lf := linefill.new(l1, l2, color.red)\n",
          "returnedType": "linefill",
          "returnedTypes": [
            "series linefill"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "linefill.delete",
          "desc": "Deletes the specified linefill object. If it has already been deleted, does nothing.",
          "args": [
            {
              "name": "id",
              "desc": "A linefill object.",
              "default": null,
              "required": true,
              "displayType": "series linefill",
              "allowedTypeIDs": [
                "series linefill"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "linefill.delete(id) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "linefill.set_color",
          "desc": "The function sets the color of the linefill object passed to it.",
          "args": [
            {
              "name": "id",
              "desc": "A linefill object.",
              "default": null,
              "required": true,
              "displayType": "series linefill",
              "allowedTypeIDs": [
                "series linefill"
              ],
              "possibleValues": null
            },
            {
              "name": "color",
              "desc": "The color of the linefill object.",
              "default": null,
              "required": true,
              "displayType": "series color",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "possibleValues": [
                "colors"
              ]
            }
          ],
          "syntax": "linefill.set_color(id, color) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "linefill.get_line1",
          "desc": "Returns the ID of the first line used in the `id` linefill.",
          "args": [
            {
              "name": "id",
              "desc": "A linefill object.",
              "default": null,
              "required": true,
              "displayType": "series linefill",
              "allowedTypeIDs": [
                "series linefill"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "linefill.get_line1(id) → series line",
          "returnedType": "line",
          "returnedTypes": [
            "series line"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "linefill.get_line2",
          "desc": "Returns the ID of the second line used in the `id` linefill.",
          "args": [
            {
              "name": "id",
              "desc": "A linefill object.",
              "default": null,
              "required": true,
              "displayType": "series linefill",
              "allowedTypeIDs": [
                "series linefill"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "linefill.get_line2(id) → series line",
          "returnedType": "line",
          "returnedTypes": [
            "series line"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "label.new",
          "desc": "Creates new label object.",
          "args": [
            {
              "name": "x",
              "desc": "Bar index (if xloc = [xloc.bar_index](#var_xloc.bar_index)) or bar UNIX time (if xloc = [xloc.bar_time](#var_xloc.bar_time)) of the label position.  \nNote that objects positioned using [xloc.bar_index](#var_xloc.bar_index) cannot be drawn further than 500 bars into the future.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "bar_index",
                "time"
              ]
            },
            {
              "name": "y",
              "desc": "Price of the label position. It is taken into account only if yloc=[yloc.price](#var_yloc.price).",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            },
            {
              "name": "text",
              "desc": "Label text. Default is empty string.",
              "default": "\"\"",
              "required": false,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "xloc",
              "desc": "See description of **x** argument.  \nPossible values: [xloc.bar_index](#var_xloc.bar_index) and [xloc.bar_time](#var_xloc.bar_time).  \nDefault is [xloc.bar_index](#var_xloc.bar_index).",
              "default": "xloc.bar_index",
              "required": false,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "xloc.bar_index",
                "xloc.bar_time"
              ]
            },
            {
              "name": "yloc",
              "desc": "Possible values are [yloc.price](#var_yloc.price), [yloc.abovebar](#var_yloc.abovebar), [yloc.belowbar](#var_yloc.belowbar).  \nIf yloc=[yloc.price](#var_yloc.price), **y** argument specifies the price of the label position.  \nIf yloc=[yloc.abovebar](#var_yloc.abovebar), label is located above bar.  \nIf yloc=[yloc.belowbar](#var_yloc.belowbar), label is located below bar.  \nDefault is [yloc.price](#var_yloc.price).",
              "default": "yloc.price",
              "required": false,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "yloc.price",
                "yloc.abovebar",
                "yloc.belowbar"
              ]
            },
            {
              "name": "color",
              "desc": "Color of the label border and arrow",
              "default": "color.blue",
              "required": false,
              "displayType": "series color",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "possibleValues": [
                "colors"
              ]
            },
            {
              "name": "style",
              "desc": "Label style.  \nPossible values: [label.style_none](#var_label.style_none), [label.style_xcross](#var_label.style_xcross), [label.style_cross](#var_label.style_cross), [label.style_triangleup](#var_label.style_triangleup), [label.style_triangledown](#var_label.style_triangledown), [label.style_flag](#var_label.style_flag), [label.style_circle](#var_label.style_circle), [label.style_arrowup](#var_label.style_arrowup), [label.style_arrowdown](#var_label.style_arrowdown), [label.style_label_up](#var_label.style_label_up), [label.style_label_down](#var_label.style_label_down), [label.style_label_left](#var_label.style_label_left), [label.style_label_right](#var_label.style_label_right), [label.style_label_lower_left](#var_label.style_label_lower_left), [label.style_label_lower_right](#var_label.style_label_lower_right), [label.style_label_upper_left](#var_label.style_label_upper_left), [label.style_label_upper_right](#var_label.style_label_upper_right), [label.style_label_center](#var_label.style_label_center), [label.style_square](#var_label.style_square), [label.style_diamond](#var_label.style_diamond), [label.style_text_outline](#var_label.style_text_outline).  \nDefault is [label.style_label_down](#var_label.style_label_down).",
              "default": "label.style_label_down",
              "required": false,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "label.style_none",
                "label.style_xcross",
                "label.style_cross",
                "label.style_triangleup",
                "label.style_triangledown",
                "label.style_flag",
                "label.style_circle",
                "label.style_arrowup",
                "label.style_arrowdown",
                "label.style_label_up",
                "label.style_label_down",
                "label.style_label_left",
                "label.style_label_right",
                "label.style_label_lower_left",
                "label.style_label_lower_right",
                "label.style_label_upper_left",
                "label.style_label_upper_right",
                "label.style_label_center",
                "label.style_square",
                "label.style_diamond",
                "label.style_text_outline"
              ]
            },
            {
              "name": "textcolor",
              "desc": "Text color.",
              "default": "color.white",
              "required": false,
              "displayType": "series color",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "possibleValues": [
                "colors"
              ]
            },
            {
              "name": "size",
              "desc": "Label size.  \nPossible values: [size.auto](#var_size.auto), [size.tiny](#var_size.tiny), [size.small](#var_size.small), [size.normal](#var_size.normal), [size.large](#var_size.large), [size.huge](#var_size.huge).  \nDefault value is [size.normal](#var_size.normal).",
              "default": "size.normal",
              "required": false,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "size.auto",
                "size.tiny",
                "size.small",
                "size.normal",
                "size.large",
                "size.huge"
              ]
            },
            {
              "name": "textalign",
              "desc": "Label text alignment.  \nPossible values: [text.align_left](#var_text.align_left), [text.align_center](#var_text.align_center), [text.align_right](#var_text.align_right).  \nDefault value is [text.align_center](#var_text.align_center).",
              "default": "text.align_center",
              "required": false,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "text.align_left",
                "text.align_center",
                "text.align_right"
              ]
            },
            {
              "name": "tooltip",
              "desc": "Hover to see tooltip label.",
              "default": "na",
              "required": false,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "text_font_family",
              "desc": "The font family of the text. Optional. The default value is [font.family_default](#var_font.family_default). \nPossible values: [font.family_default](#var_font.family_default), [font.family_monospace](#var_font.family_monospace).",
              "default": "font.family_default",
              "required": false,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "font.family_default",
                "font.family_monospace"
              ]
            },
            {
              "name": "point",
              "desc": "A [chart.point](#op_chart.point) object that specifies the label\\`s location.",
              "default": null,
              "required": true,
              "displayType": "chart.point",
              "allowedTypeIDs": [
                "chart.point"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "label.new(x, y, text, xloc, yloc, color, style, textcolor, size, textalign, tooltip, text_font_family) → series label\nlabel.new(point, text, xloc, yloc, color, style, textcolor, size, textalign, tooltip, text_font_family) → series label",
          "returns": "Label ID object which may be passed to label.setXXX and label.getXXX functions.",
          "seeAlso": [
            "[label.delete](#fun_label.delete)",
            "[label.set_x](#fun_label.set_x)",
            "[label.set_y](#fun_label.set_y)",
            "[label.set_xy](#fun_label.set_xy)",
            "[label.set_xloc](#fun_label.set_xloc)",
            "[label.set_yloc](#fun_label.set_yloc)",
            "[label.set_color](#fun_label.set_color)",
            "[label.set_textcolor](#fun_label.set_textcolor)",
            "[label.set_style](#fun_label.set_style)",
            "[label.set_size](#fun_label.set_size)",
            "[label.set_textalign](#fun_label.set_textalign)",
            "[label.set_tooltip](#fun_label.set_tooltip)"
          ],
          "examples": "//@version=5\nindicator(\"label.new\")\nvar label1 = label.new(bar_index, low, text=\"Hello, world!\", style=label.style_circle)\nlabel.set_x(label1, 0)\nlabel.set_xloc(label1, time, xloc.bar_time)\nlabel.set_color(label1, color.red)\nlabel.set_size(label1, size.large)",
          "returnedType": "label",
          "returnedTypes": [
            "series label"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "label.copy",
          "desc": "Clones the label object.",
          "args": [
            {
              "name": "id",
              "desc": "Label object.",
              "default": null,
              "required": true,
              "displayType": "series label",
              "allowedTypeIDs": [
                "series label"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "label.copy(id) → series label",
          "returns": "New label ID object which may be passed to label.setXXX and label.getXXX functions.",
          "seeAlso": [
            "[label.new](#fun_label.new)",
            "[label.delete](#fun_label.delete)"
          ],
          "examples": "//@version=5\nindicator('Last 100 bars highest/lowest', overlay = true)\nLOOKBACK = 100\nhighest = ta.highest(LOOKBACK)\nhighestBars = ta.highestbars(LOOKBACK)\nlowest = ta.lowest(LOOKBACK)\nlowestBars = ta.lowestbars(LOOKBACK)\nif barstate.islastconfirmedhistory\n\tvar labelHigh = label.new(bar_index + highestBars, highest, str.tostring(highest), color = color.green)\n\tvar labelLow = label.copy(labelHigh)\n\tlabel.set_xy(labelLow, bar_index + lowestBars, lowest)\n\tlabel.set_text(labelLow, str.tostring(lowest))\n\tlabel.set_color(labelLow, color.red)\n\tlabel.set_style(labelLow, label.style_label_up)",
          "returnedType": "label",
          "returnedTypes": [
            "series label"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "label.set_x",
          "desc": "Sets bar index or bar time (depending on the xloc) of the label position.",
          "args": [
            {
              "name": "id",
              "desc": "Label object.",
              "default": null,
              "required": true,
              "displayType": "series label",
              "allowedTypeIDs": [
                "series label"
              ],
              "possibleValues": null
            },
            {
              "name": "x",
              "desc": "New bar index or bar time of the label position. Note that objects positioned using [xloc.bar_index](#var_xloc.bar_index) cannot be drawn further than 500 bars into the future.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "time",
                "bar_index",
                "time_close",
                "last_bar_index",
                "last_bar_time"
              ]
            }
          ],
          "syntax": "label.set_x(id, x) → void",
          "seeAlso": [
            "[label.new](#fun_label.new)"
          ],
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "label.set_y",
          "desc": "Sets price of the label position",
          "args": [
            {
              "name": "id",
              "desc": "Label object.",
              "default": null,
              "required": true,
              "displayType": "series label",
              "allowedTypeIDs": [
                "series label"
              ],
              "possibleValues": null
            },
            {
              "name": "y",
              "desc": "New price of the label position.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "label.set_y(id, y) → void",
          "seeAlso": [
            "[label.new](#fun_label.new)"
          ],
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "label.set_xy",
          "desc": "Sets bar index/time and price of the label position.",
          "args": [
            {
              "name": "id",
              "desc": "Label object.",
              "default": null,
              "required": true,
              "displayType": "series label",
              "allowedTypeIDs": [
                "series label"
              ],
              "possibleValues": null
            },
            {
              "name": "x",
              "desc": "New bar index or bar time of the label position. Note that objects positioned using [xloc.bar_index](#var_xloc.bar_index) cannot be drawn further than 500 bars into the future.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "time",
                "bar_index",
                "time_close",
                "last_bar_index",
                "last_bar_time"
              ]
            },
            {
              "name": "y",
              "desc": "New price of the label position.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "label.set_xy(id, x, y) → void",
          "seeAlso": [
            "[label.new](#fun_label.new)"
          ],
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "label.set_xloc",
          "desc": "Sets x-location and new bar index/time value.",
          "args": [
            {
              "name": "id",
              "desc": "Label object.",
              "default": null,
              "required": true,
              "displayType": "series label",
              "allowedTypeIDs": [
                "series label"
              ],
              "possibleValues": null
            },
            {
              "name": "x",
              "desc": "New bar index or bar time of the label position.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "bar_index",
                "time"
              ]
            },
            {
              "name": "xloc",
              "desc": "New x-location value.",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "xloc.bar_index",
                "xloc.bar_time"
              ]
            }
          ],
          "syntax": "label.set_xloc(id, x, xloc) → void",
          "seeAlso": [
            "[xloc.bar_index](#const_xloc.bar_index)",
            "[xloc.bar_time](#const_xloc.bar_time)",
            "[label.new](#fun_label.new)"
          ],
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "label.set_yloc",
          "desc": "Sets new y-location calculation algorithm.",
          "args": [
            {
              "name": "id",
              "desc": "Label object.",
              "default": null,
              "required": true,
              "displayType": "series label",
              "allowedTypeIDs": [
                "series label"
              ],
              "possibleValues": null
            },
            {
              "name": "yloc",
              "desc": "New y-location value.",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "yloc.price",
                "yloc.abovebar",
                "yloc.belowbar"
              ]
            }
          ],
          "syntax": "label.set_yloc(id, yloc) → void",
          "seeAlso": [
            "[yloc.price](#const_yloc.price)",
            "[yloc.abovebar](#const_yloc.abovebar)",
            "[yloc.belowbar](#const_yloc.belowbar)",
            "[label.new](#fun_label.new)"
          ],
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "label.set_text",
          "desc": "Sets label text",
          "args": [
            {
              "name": "id",
              "desc": "Label object.",
              "default": null,
              "required": true,
              "displayType": "series label",
              "allowedTypeIDs": [
                "series label"
              ],
              "possibleValues": null
            },
            {
              "name": "text",
              "desc": "New label text.",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "label.set_text(id, text) → void",
          "seeAlso": [
            "[label.new](#fun_label.new)"
          ],
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "label.set_text_font_family",
          "desc": "The function sets the font family of the text inside the label.",
          "args": [
            {
              "name": "id",
              "desc": "A label object.",
              "default": null,
              "required": true,
              "displayType": "series label",
              "allowedTypeIDs": [
                "series label"
              ],
              "possibleValues": null
            },
            {
              "name": "text_font_family",
              "desc": "The font family of the text.  \nPossible values: [font.family_default](#var_font.family_default), [font.family_monospace](#var_font.family_monospace).",
              "default": "font.family_default",
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "font.family_default",
                "font.family_monospace"
              ]
            }
          ],
          "syntax": "label.set_text_font_family(id, text_font_family) → void",
          "seeAlso": [
            "[label.new](#fun_label.new)",
            "[font.family_default](#const_font.family_default)",
            "[font.family_monospace](#const_font.family_monospace)"
          ],
          "examples": "//@version=5\nindicator(\"Example of setting the label font\")\nif barstate.islastconfirmedhistory\n    l = label.new(bar_index, 0, \"monospace\", yloc=yloc.abovebar)\n    label.set_text_font_family(l, font.family_monospace)",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "label.set_color",
          "desc": "Sets label border and arrow color.",
          "args": [
            {
              "name": "id",
              "desc": "Label object.",
              "default": null,
              "required": true,
              "displayType": "series label",
              "allowedTypeIDs": [
                "series label"
              ],
              "possibleValues": null
            },
            {
              "name": "color",
              "desc": "New label border and arrow color.",
              "default": null,
              "required": true,
              "displayType": "series color",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "possibleValues": [
                "colors"
              ]
            }
          ],
          "syntax": "label.set_color(id, color) → void",
          "seeAlso": [
            "[label.new](#fun_label.new)"
          ],
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "label.set_style",
          "desc": "Sets label style.",
          "args": [
            {
              "name": "id",
              "desc": "Label object.",
              "default": null,
              "required": true,
              "displayType": "series label",
              "allowedTypeIDs": [
                "series label"
              ],
              "possibleValues": null
            },
            {
              "name": "style",
              "desc": "New label style.  \nPossible values: [label.style_none](#var_label.style_none), [label.style_xcross](#var_label.style_xcross), [label.style_cross](#var_label.style_cross), [label.style_triangleup](#var_label.style_triangleup), [label.style_triangledown](#var_label.style_triangledown), [label.style_flag](#var_label.style_flag), [label.style_circle](#var_label.style_circle), [label.style_arrowup](#var_label.style_arrowup), [label.style_arrowdown](#var_label.style_arrowdown), [label.style_label_up](#var_label.style_label_up), [label.style_label_down](#var_label.style_label_down), [label.style_label_left](#var_label.style_label_left), [label.style_label_right](#var_label.style_label_right), [label.style_label_lower_left](#var_label.style_label_lower_left), [label.style_label_lower_right](#var_label.style_label_lower_right), [label.style_label_upper_left](#var_label.style_label_upper_left), [label.style_label_upper_right](#var_label.style_label_upper_right), [label.style_label_center](#var_label.style_label_center), [label.style_square](#var_label.style_square), [label.style_diamond](#var_label.style_diamond), [label.style_text_outline](#var_label.style_text_outline).",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "label.style_none",
                "label.style_xcross",
                "label.style_cross",
                "label.style_triangleup",
                "label.style_triangledown",
                "label.style_flag",
                "label.style_circle",
                "label.style_arrowup",
                "label.style_arrowdown",
                "label.style_label_up",
                "label.style_label_down",
                "label.style_label_left",
                "label.style_label_right",
                "label.style_label_lower_left",
                "label.style_label_lower_right",
                "label.style_label_upper_left",
                "label.style_label_upper_right",
                "label.style_label_center",
                "label.style_square",
                "label.style_diamond",
                "label.style_text_outline"
              ]
            }
          ],
          "syntax": "label.set_style(id, style) → void",
          "seeAlso": [
            "[label.new](#fun_label.new)"
          ],
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "label.set_textcolor",
          "desc": "Sets color of the label text.",
          "args": [
            {
              "name": "id",
              "desc": "Label object.",
              "default": null,
              "required": true,
              "displayType": "series label",
              "allowedTypeIDs": [
                "series label"
              ],
              "possibleValues": null
            },
            {
              "name": "textcolor",
              "desc": "New text color.",
              "default": null,
              "required": true,
              "displayType": "series color",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "possibleValues": [
                "colors"
              ]
            }
          ],
          "syntax": "label.set_textcolor(id, textcolor) → void",
          "seeAlso": [
            "[label.new](#fun_label.new)"
          ],
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "label.set_size",
          "desc": "Sets arrow and text size of the specified label object.",
          "args": [
            {
              "name": "id",
              "desc": "Label object.",
              "default": null,
              "required": true,
              "displayType": "series label",
              "allowedTypeIDs": [
                "series label"
              ],
              "possibleValues": null
            },
            {
              "name": "size",
              "desc": " \nPossible values: [size.auto](#var_size.auto), [size.tiny](#var_size.tiny), [size.small](#var_size.small), [size.normal](#var_size.normal), [size.large](#var_size.large), [size.huge](#var_size.huge).  \nDefault value is [size.auto](#var_size.auto).",
              "default": "size.auto",
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "size.auto",
                "size.tiny",
                "size.small",
                "size.normal",
                "size.large",
                "size.huge"
              ]
            }
          ],
          "syntax": "label.set_size(id, size) → void",
          "seeAlso": [
            "[size.auto](#const_size.auto)",
            "[size.tiny](#const_size.tiny)",
            "[size.small](#const_size.small)",
            "[size.normal](#const_size.normal)",
            "[size.large](#const_size.large)",
            "[size.huge](#const_size.huge)",
            "[label.new](#fun_label.new)"
          ],
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "label.set_textalign",
          "desc": "Sets the alignment for the label text.",
          "args": [
            {
              "name": "id",
              "desc": "Label object.",
              "default": null,
              "required": true,
              "displayType": "series label",
              "allowedTypeIDs": [
                "series label"
              ],
              "possibleValues": null
            },
            {
              "name": "textalign",
              "desc": "Label text alignment.  \nPossible values: [text.align_left](#var_text.align_left), [text.align_center](#var_text.align_center), [text.align_right](#var_text.align_right).",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "text.align_left",
                "text.align_center",
                "text.align_right"
              ]
            }
          ],
          "syntax": "label.set_textalign(id, textalign) → void",
          "seeAlso": [
            "[text.align_left](#const_text.align_left)",
            "[text.align_center](#const_text.align_center)",
            "[text.align_right](#const_text.align_right)",
            "[label.new](#fun_label.new)"
          ],
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "label.set_tooltip",
          "desc": "Sets the tooltip text.",
          "args": [
            {
              "name": "id",
              "desc": "Label object.",
              "default": null,
              "required": true,
              "displayType": "series label",
              "allowedTypeIDs": [
                "series label"
              ],
              "possibleValues": null
            },
            {
              "name": "tooltip",
              "desc": "Tooltip text.",
              "default": null,
              "required": false,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "label.set_tooltip(id, tooltip) → void",
          "seeAlso": [
            "[label.new](#fun_label.new)"
          ],
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "label.delete",
          "desc": "Deletes the specified label object. If it has already been deleted, does nothing.",
          "args": [
            {
              "name": "id",
              "desc": "Label object to delete.",
              "default": null,
              "required": true,
              "displayType": "series label",
              "allowedTypeIDs": [
                "series label"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "label.delete(id) → void",
          "seeAlso": [
            "[label.new](#fun_label.new)"
          ],
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "label.get_x",
          "desc": "Returns UNIX time or bar index (depending on the last xloc value set) of this label\\`s position.",
          "args": [
            {
              "name": "id",
              "desc": "Label object.",
              "default": null,
              "required": true,
              "displayType": "series label",
              "allowedTypeIDs": [
                "series label"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "label.get_x(id) → series int",
          "returns": "UNIX timestamp (in milliseconds) or bar index.",
          "seeAlso": [
            "[label.new](#fun_label.new)"
          ],
          "examples": "//@version=5\nindicator(\"label.get_x\")\nmy_label = label.new(time, open, text=\"Open bar text\", xloc=xloc.bar_time)\na = label.get_x(my_label)\nplot(time - label.get_x(my_label)) //draws zero plot",
          "returnedType": "int",
          "returnedTypes": [
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "label.get_y",
          "desc": "Returns price of this label\\`s position.",
          "args": [
            {
              "name": "id",
              "desc": "Label object.",
              "default": null,
              "required": true,
              "displayType": "series label",
              "allowedTypeIDs": [
                "series label"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "label.get_y(id) → series float",
          "returns": "Floating point value representing price.",
          "seeAlso": [
            "[label.new](#fun_label.new)"
          ],
          "returnedType": "float",
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "label.get_text",
          "desc": "Returns the text of this label object.",
          "args": [
            {
              "name": "id",
              "desc": "Label object.",
              "default": null,
              "required": true,
              "displayType": "series label",
              "allowedTypeIDs": [
                "series label"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "label.get_text(id) → series string",
          "returns": "String object containing the text of this label.",
          "seeAlso": [
            "[label.new](#fun_label.new)"
          ],
          "examples": "//@version=5\nindicator(\"label.get_text\")\nmy_label = label.new(time, open, text=\"Open bar text\", xloc=xloc.bar_time)\na = label.get_text(my_label)\nlabel.new(time, close, text = a + \" new\", xloc=xloc.bar_time)",
          "returnedType": "string",
          "returnedTypes": [
            "series string",
            "simple string",
            "input string",
            "const string"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "max_bars_back",
          "desc": "Function sets the maximum number of bars that is available for historical reference of a given built-in or user variable.  \nWhen operator '[]' is applied to a variable - it is a reference to a historical value of that variable.\n\nIf an argument of an operator '[]' is a compile time constant value (e.g. 'v[10]', 'close[500]') then there is no need to use 'max_bars_back' function for that variable.  \nPine Script™ compiler will use that constant value as history buffer size.\n\nIf an argument of an operator '[]' is a value, calculated at runtime (e.g. 'v[i]' where 'i' - is a series variable) then Pine Script™ attempts to autodetect the history buffer size at runtime.  \nSometimes it fails and the script crashes at runtime because it eventually refers to historical values that are out of the buffer.  \nIn that case you should use 'max_bars_back' to fix that problem manually.",
          "args": [
            {
              "name": "var",
              "desc": "Series variable identifier for which history buffer should be resized. Possible values are: 'open', 'high', 'low', 'close', 'volume', 'time', or any user defined variable id.",
              "default": null,
              "required": true,
              "displayType": "series int|float|bool|color|label|line",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float",
                "series bool",
                "simple bool",
                "input bool",
                "const bool",
                "series color",
                "simple color",
                "input color",
                "const color",
                "series label",
                "series line"
              ],
              "possibleValues": null
            },
            {
              "name": "num",
              "desc": "History buffer size which is the number of bars that could be referenced for variable 'var'.",
              "default": null,
              "required": true,
              "displayType": "const int",
              "allowedTypeIDs": [
                "const int"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "max_bars_back(var, num) → void",
          "remarks": [
            "At the moment 'max_bars_back' cannot be applied to built-ins like 'hl2', 'hlc3', 'ohlc4'. Please use multiple 'max_bars_back' calls as workaround here (e.g. instead of a single ‘max_bars_back(hl2, 100)’ call you should call the function twice: ‘max_bars_back(high, 100), max_bars_back(low, 100)’).",
            "",
            "If the [indicator](#fun_indicator) or [strategy](#fun_strategy) 'max_bars_back' parameter is used, all variables in the indicator are affected. This may result in excessive memory usage and cause runtime problems. When possible (i.e. when the cause is a variable rather than a function), please use the [max_bars_back](#fun_max_bars_back) function instead."
          ],
          "returns": "void",
          "seeAlso": [
            "Param 'max_bars_back' of [indicator](#fun_indicator) and [strategy](#fun_strategy) functions."
          ],
          "examples": "//@version=5\nindicator(\"max_bars_back\")\nclose_() → close\ndepth() → 400\nd = depth()\nv = close_()\nmax_bars_back(v, 500)\nout = if bar_index > 0\n\tv[d]\nelse\n\tv\nplot(out)",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "array.new<type>",
          "desc": "The function creates a new array object of <type> elements.",
          "args": [
            {
              "name": "size",
              "desc": "Initial size of an array. Optional. The default is 0.",
              "default": "0",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "size.auto",
                "size.tiny",
                "size.small",
                "size.normal",
                "size.large",
                "size.huge"
              ]
            },
            {
              "name": "initial_value",
              "desc": "Initial value of all array elements. Optional. The default is 'na'.",
              "default": "na",
              "required": false,
              "displayType": "<array_type>",
              "allowedTypeIDs": [],
              "possibleValues": null
            }
          ],
          "syntax": "array.new<type>(size, initial_value) → type[]",
          "remarks": "An array index starts from 0.\nIf you want to initialize an array and specify all its elements at the same time, then use the function array.from.",
          "returns": "The ID of an array object which may be used in other array.*() functions.",
          "seeAlso": [
            "[array.from](#fun_array.from)",
            "[array.push](#fun_array.push)",
            "[array.get](#fun_array.get)",
            "[array.size](#fun_array.size)",
            "[array.remove](#fun_array.remove)",
            "[array.shift](#fun_array.shift)",
            "[array.sum](#fun_array.sum)"
          ],
          "examples": "//@version=5\nindicator(\"array.new<string> example\")\na = array.new<string>(1, \"Hello, World!\")\nlabel.new(bar_index, close, array.get(a, 0))",
          "detailedDesc": [
            {
              "desc": "",
              "examples": "//@version=5\nindicator(\"array.new<color> example\")\na = array.new<color>()\narray.push(a, color.red)\narray.push(a, color.green)\nplot(close, color = array.get(a, close > open ? 1 : 0))"
            },
            {
              "desc": "",
              "examples": "//@version=5\nindicator(\"array.new<float> example\")\nlength = 5\nvar a = array.new<float>(length, close)\nif array.size(a) == length\n\tarray.remove(a, 0)\n\tarray.push(a, close)\nplot(array.sum(a) / length, \"SMA\")"
            },
            {
              "desc": "",
              "examples": "//@version=5\nindicator(\"array.new<line> example\")\n// draw last 15 lines\nvar a = array.new<line>()\narray.push(a, line.new(bar_index - 1, close[1], bar_index, close))\nif array.size(a) > 15\n    ln = array.shift(a)\n    line.delete(ln)"
            }
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "array.new<float>",
          "desc": "The function creates a new array object of float type elements.",
          "args": [
            {
              "name": "size",
              "desc": "Initial size of an array. Optional. The default is 0.",
              "default": "0",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "size.auto",
                "size.tiny",
                "size.small",
                "size.normal",
                "size.large",
                "size.huge"
              ]
            },
            {
              "name": "initial_value",
              "desc": "Initial value of all array elements. Optional. The default is 'na'.",
              "default": "na",
              "required": false,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "array.new<float>(size, initial_value) → array<float>",
          "remarks": "An array index starts from 0.",
          "returns": "The ID of an array object which may be used in other array.*() functions.",
          "seeAlso": [
            "[array.from](#fun_array.from)",
            "[array.push](#fun_array.push)",
            "[array.get](#fun_array.get)",
            "[array.size](#fun_array.size)",
            "[array.remove](#fun_array.remove)",
            "[array.shift](#fun_array.shift)",
            "[array.sum](#fun_array.sum)"
          ],
          "examples": "//@version=5\nindicator(\"array.new<float> example\")\nlength = 5\na = array.new<float>(length, close)\nplot(array.sum(a) / length)",
          "returnedType": "array<float>",
          "returnedTypes": [
            "array<float>"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "array.new<int>",
          "desc": "The function creates a new array object of int type elements.",
          "args": [
            {
              "name": "size",
              "desc": "Initial size of an array. Optional. The default is 0.",
              "default": "0",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "size.auto",
                "size.tiny",
                "size.small",
                "size.normal",
                "size.large",
                "size.huge"
              ]
            },
            {
              "name": "initial_value",
              "desc": "Initial value of all array elements. Optional. The default is 'na'.",
              "default": "na",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "array.new<int>(size, initial_value) → array<int>",
          "remarks": "An array index starts from 0.",
          "returns": "The ID of an array object which may be used in other array.*() functions.",
          "seeAlso": [
            "[array.from](#fun_array.from)",
            "[array.push](#fun_array.push)",
            "[array.get](#fun_array.get)",
            "[array.size](#fun_array.size)",
            "[array.remove](#fun_array.remove)",
            "[array.shift](#fun_array.shift)",
            "[array.sum](#fun_array.sum)"
          ],
          "examples": "//@version=5\nindicator(\"array.new<int> example\")\nlength = 5\na = array.new<int>(length, int(close))\nplot(array.sum(a) / length)",
          "returnedType": "array<int>",
          "returnedTypes": [
            "array<int>"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "array.new<color>",
          "desc": "The function creates a new array object of color type elements.",
          "args": [
            {
              "name": "size",
              "desc": "Initial size of an array. Optional. The default is 0.",
              "default": "0",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "size.auto",
                "size.tiny",
                "size.small",
                "size.normal",
                "size.large",
                "size.huge"
              ]
            },
            {
              "name": "initial_value",
              "desc": "Initial value of all array elements. Optional. The default is 'na'.",
              "default": "na",
              "required": false,
              "displayType": "series color",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "possibleValues": [
                "colors"
              ]
            }
          ],
          "syntax": "array.new<color>(size, initial_value) → array<color>",
          "remarks": "An array index starts from 0.",
          "returns": "The ID of an array object which may be used in other array.*() functions.",
          "seeAlso": [
            "[array.from](#fun_array.from)",
            "[array.push](#fun_array.push)",
            "[array.get](#fun_array.get)",
            "[array.size](#fun_array.size)",
            "[array.remove](#fun_array.remove)",
            "[array.shift](#fun_array.shift)",
            "[array.sum](#fun_array.sum)"
          ],
          "examples": "//@version=5\nindicator(\"array.new<color> example\")\nlength = 5\na = array.new<color>(length, color.red)\nplot(close, color = array.get(a, 0))",
          "returnedType": "array<color>",
          "returnedTypes": [
            "array<color>"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "array.new<bool>",
          "desc": "The function creates a new array object of bool type elements.",
          "args": [
            {
              "name": "size",
              "desc": "Initial size of an array. Optional. The default is 0.",
              "default": "0",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "size.auto",
                "size.tiny",
                "size.small",
                "size.normal",
                "size.large",
                "size.huge"
              ]
            },
            {
              "name": "initial_value",
              "desc": "Initial value of all array elements. Optional. The default is 'na'.",
              "default": "na",
              "required": false,
              "displayType": "series bool",
              "allowedTypeIDs": [
                "series bool",
                "simple bool",
                "input bool",
                "const bool"
              ],
              "possibleValues": [
                "true",
                "false"
              ]
            }
          ],
          "syntax": "array.new<bool>(size, initial_value) → array<bool>",
          "remarks": "An array index starts from 0.",
          "returns": "The ID of an array object which may be used in other array.*() functions.",
          "seeAlso": [
            "[array.from](#fun_array.from)",
            "[array.push](#fun_array.push)",
            "[array.get](#fun_array.get)",
            "[array.size](#fun_array.size)",
            "[array.remove](#fun_array.remove)",
            "[array.shift](#fun_array.shift)",
            "[array.sum](#fun_array.sum)"
          ],
          "examples": "//@version=5\nindicator(\"array.new<bool> example\")\nlength = 5\na = array.new<bool>(length, close > open)\nplot(array.get(a, 0) ? close : open)",
          "returnedType": "array<bool>",
          "returnedTypes": [
            "array<bool>"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "array.new<string>",
          "desc": "The function creates a new array object of string type elements.",
          "args": [
            {
              "name": "size",
              "desc": "Initial size of an array. Optional. The default is 0.",
              "default": "0",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "size.auto",
                "size.tiny",
                "size.small",
                "size.normal",
                "size.large",
                "size.huge"
              ]
            },
            {
              "name": "initial_value",
              "desc": "Initial value of all array elements. Optional. The default is 'na'.",
              "default": "na",
              "required": false,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "array.new<string>(size, initial_value) → array<string>",
          "remarks": "An array index starts from 0.",
          "returns": "The ID of an array object which may be used in other array.*() functions.",
          "seeAlso": [
            "[array.from](#fun_array.from)",
            "[array.push](#fun_array.push)",
            "[array.get](#fun_array.get)",
            "[array.size](#fun_array.size)",
            "[array.remove](#fun_array.remove)",
            "[array.shift](#fun_array.shift)",
            "[array.sum](#fun_array.sum)"
          ],
          "examples": "//@version=5\nindicator(\"array.new<string> example\")\nlength = 5\na = array.new<string>(length, \"text\")\nlabel.new(bar_index, close, array.get(a, 0))",
          "returnedType": "array<string>",
          "returnedTypes": [
            "array<string>"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "array.new<line>",
          "desc": "The function creates a new array object of line type elements.",
          "args": [
            {
              "name": "size",
              "desc": "Initial size of an array. Optional. The default is 0.",
              "default": "0",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "size.auto",
                "size.tiny",
                "size.small",
                "size.normal",
                "size.large",
                "size.huge"
              ]
            },
            {
              "name": "initial_value",
              "desc": "Initial value of all array elements. Optional. The default is 'na'.",
              "default": "na",
              "required": false,
              "displayType": "series line",
              "allowedTypeIDs": [
                "series line"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "array.new<line>(size, initial_value) → array<line>",
          "remarks": "An array index starts from 0.",
          "returns": "The ID of an array object which may be used in other array.*() functions.",
          "seeAlso": [
            "[array.from](#fun_array.from)",
            "[array.push](#fun_array.push)",
            "[array.get](#fun_array.get)",
            "[array.size](#fun_array.size)",
            "[array.remove](#fun_array.remove)",
            "[array.shift](#fun_array.shift)",
            "[array.sum](#fun_array.sum)"
          ],
          "examples": "//@version=5\nindicator(\"array.new<line> example\")\n// draw last 15 lines\nvar a = array.new<line>()\narray.push(a, line.new(bar_index - 1, close[1], bar_index, close))\nif array.size(a) > 15\n\tln = array.shift(a)\n\tline.delete(ln)",
          "returnedType": "array<line>",
          "returnedTypes": [
            "array<line>"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "array.new<box>",
          "desc": "The function creates a new array object of box type elements.",
          "args": [
            {
              "name": "size",
              "desc": "Initial size of an array. Optional. The default is 0.",
              "default": "0",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "size.auto",
                "size.tiny",
                "size.small",
                "size.normal",
                "size.large",
                "size.huge"
              ]
            },
            {
              "name": "initial_value",
              "desc": "Initial value of all array elements. Optional. The default is 'na'.",
              "default": "na",
              "required": false,
              "displayType": "series box",
              "allowedTypeIDs": [
                "series box"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "array.new<box>(size, initial_value) → array<box>",
          "remarks": "An array index starts from 0.",
          "returns": "The ID of an array object which may be used in other array.*() functions.",
          "seeAlso": [
            "[array.from](#fun_array.from)",
            "[array.push](#fun_array.push)",
            "[array.get](#fun_array.get)",
            "[array.size](#fun_array.size)",
            "[array.remove](#fun_array.remove)",
            "[array.shift](#fun_array.shift)",
            "[array.sum](#fun_array.sum)"
          ],
          "examples": "//@version=5\nindicator(\"array.new<box> example\")\nbox[] boxes = array.new<box>()\narray.push(boxes, box.new(time, close, time+2, low, xloc=xloc.bar_time))\nplot(1)",
          "returnedType": "array<box>",
          "returnedTypes": [
            "array<box>"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "array.new<table>",
          "desc": "The function creates a new array object of table type elements.",
          "args": [
            {
              "name": "size",
              "desc": "Initial size of an array. Optional. The default is 0.",
              "default": "0",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "size.auto",
                "size.tiny",
                "size.small",
                "size.normal",
                "size.large",
                "size.huge"
              ]
            },
            {
              "name": "initial_value",
              "desc": "Initial value of all array elements. Optional. The default is 'na'.",
              "default": "na",
              "required": false,
              "displayType": "series table",
              "allowedTypeIDs": [
                "series table"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "array.new<table>(size, initial_value) → array<table>",
          "remarks": "An array index starts from 0.",
          "returns": "The ID of an array object which may be used in other array.*() functions.",
          "seeAlso": [
            "[array.from](#fun_array.from)",
            "[array.push](#fun_array.push)",
            "[array.get](#fun_array.get)",
            "[array.size](#fun_array.size)",
            "[array.remove](#fun_array.remove)",
            "[array.shift](#fun_array.shift)",
            "[array.sum](#fun_array.sum)"
          ],
          "examples": "//@version=5\nindicator(\"array.new<table> example\")\ntable[] tables = array.new<table>()\narray.push(tables, table.new(position = position.top_left, rows = 1, columns = 2, bgcolor = color.yellow, border_width=1))\nplot(1)",
          "returnedType": "array<table>",
          "returnedTypes": [
            "array<table>"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "array.new<label>",
          "desc": "The function creates a new array object of label type elements.",
          "args": [
            {
              "name": "size",
              "desc": "Initial size of an array. Optional. The default is 0.",
              "default": "0",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "size.auto",
                "size.tiny",
                "size.small",
                "size.normal",
                "size.large",
                "size.huge"
              ]
            },
            {
              "name": "initial_value",
              "desc": "Initial value of all array elements. Optional. The default is 'na'.",
              "default": "na",
              "required": false,
              "displayType": "series label",
              "allowedTypeIDs": [
                "series label"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "array.new<label>(size, initial_value) → array<label>",
          "remarks": "An array index starts from 0.",
          "returns": "The ID of an array object which may be used in other array.*() functions.",
          "seeAlso": [
            "[array.from](#fun_array.from)",
            "[array.push](#fun_array.push)",
            "[array.get](#fun_array.get)",
            "[array.size](#fun_array.size)",
            "[array.remove](#fun_array.remove)",
            "[array.shift](#fun_array.shift)",
            "[array.sum](#fun_array.sum)"
          ],
          "examples": "//@version=5\nindicator(\"array.new<label> example\")\nvar a = array.new<label>\nl = label.new(bar_index, close, \"some text\")\narray.push(a, l)\nif close > close[1] and close[1] > close[2]\n\t// remove all labels\n\tsize = array.size(a) - 1\n\tfor i = 0 to size\n\t\tlb = array.get(a, i)\n\t\tlabel.delete(lb)",
          "returnedType": "array<label>",
          "returnedTypes": [
            "array<label>"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "array.new<linefill>",
          "desc": "The function creates a new array object of linefill type elements.",
          "args": [
            {
              "name": "size",
              "desc": "Initial size of an array.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "size.auto",
                "size.tiny",
                "size.small",
                "size.normal",
                "size.large",
                "size.huge"
              ]
            },
            {
              "name": "initial_value",
              "desc": "Initial value of all array elements.",
              "default": null,
              "required": true,
              "displayType": "series linefill",
              "allowedTypeIDs": [
                "series linefill"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "array.new<linefill>(size, initial_value) → array<linefill>",
          "remarks": "An array index starts from 0.",
          "returns": "The ID of an array object which may be used in other array.*() functions.",
          "seeAlso": [
            "[array.from](#fun_array.from)",
            "[array.push](#fun_array.push)",
            "[array.get](#fun_array.get)",
            "[array.size](#fun_array.size)",
            "[array.remove](#fun_array.remove)",
            "[array.shift](#fun_array.shift)",
            "[array.sum](#fun_array.sum)"
          ],
          "examples": "//@version=5\nindicator(\"array.new<linefill> example\")\nvar a = array.new<linefill>()\nvar l1 = line.new(bar_index,high,bar_index+50,high, color=color.blue)\nvar l2 = line.new(bar_index,high,bar_index+50,high, color=color.blue)\n\nl = linefill.new(l1, l2, color.silver)\narray.push(a, l)\nif close > close[1] and close[1] > close[2]\n\t// remove all linefills\n\tsize = array.size(a) - 1\n\tfor i = 0 to size\n\t\tlf = array.get(a, i)\n\t\tlinefill.delete(lf)",
          "returnedType": "array<linefill>",
          "returnedTypes": [
            "array<linefill>"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "array.new_float",
          "desc": "The function creates a new array object of float type elements.",
          "args": [
            {
              "name": "size",
              "desc": "Initial size of an array. Optional. The default is 0.",
              "default": "0",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "size.auto",
                "size.tiny",
                "size.small",
                "size.normal",
                "size.large",
                "size.huge"
              ]
            },
            {
              "name": "initial_value",
              "desc": "Initial value of all array elements. Optional. The default is 'na'.",
              "default": "na",
              "required": false,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "array.new_float(size, initial_value) → array<float>",
          "remarks": "An array index starts from 0.",
          "returns": "The ID of an array object which may be used in other array.*() functions.",
          "seeAlso": [
            "[array.new_color](#fun_array.new_color)",
            "[array.new_bool](#fun_array.new_bool)",
            "[array.get](#fun_array.get)",
            "[array.slice](#fun_array.slice)",
            "[array.sort](#fun_array.sort)"
          ],
          "examples": "//@version=5\nindicator(\"array.new_float example\")\nlength = 5\na = array.new_float(length, close)\nplot(array.sum(a) / length)",
          "returnedType": "array<float>",
          "returnedTypes": [
            "array<float>"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "array.new_int",
          "desc": "The function creates a new array object of int type elements.",
          "args": [
            {
              "name": "size",
              "desc": "Initial size of an array. Optional. The default is 0.",
              "default": "0",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "size.auto",
                "size.tiny",
                "size.small",
                "size.normal",
                "size.large",
                "size.huge"
              ]
            },
            {
              "name": "initial_value",
              "desc": "Initial value of all array elements. Optional. The default is 'na'.",
              "default": "na",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "array.new_int(size, initial_value) → array<int>",
          "remarks": "An array index starts from 0.",
          "returns": "The ID of an array object which may be used in other array.*() functions.",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.get](#fun_array.get)",
            "[array.slice](#fun_array.slice)",
            "[array.sort](#fun_array.sort)"
          ],
          "examples": "//@version=5\nindicator(\"array.new_int example\")\nlength = 5\na = array.new_int(length, int(close))\nplot(array.sum(a) / length)",
          "returnedType": "array<int>",
          "returnedTypes": [
            "array<int>"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "array.new_color",
          "desc": "The function creates a new array object of color type elements.",
          "args": [
            {
              "name": "size",
              "desc": "Initial size of an array. Optional. The default is 0.",
              "default": "0",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "size.auto",
                "size.tiny",
                "size.small",
                "size.normal",
                "size.large",
                "size.huge"
              ]
            },
            {
              "name": "initial_value",
              "desc": "Initial value of all array elements. Optional. The default is 'na'.",
              "default": "na",
              "required": false,
              "displayType": "series color",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "possibleValues": [
                "colors"
              ]
            }
          ],
          "syntax": "array.new_color(size, initial_value) → array<color>",
          "remarks": "An array index starts from 0.",
          "returns": "The ID of an array object which may be used in other array.*() functions.",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.get](#fun_array.get)",
            "[array.slice](#fun_array.slice)",
            "[array.sort](#fun_array.sort)"
          ],
          "examples": "//@version=5\nindicator(\"array.new_color example\")\nlength = 5\na = array.new_color(length, color.red)\nplot(close, color = array.get(a, 0))",
          "returnedType": "array<color>",
          "returnedTypes": [
            "array<color>"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "array.new_bool",
          "desc": "The function creates a new array object of bool type elements.",
          "args": [
            {
              "name": "size",
              "desc": "Initial size of an array. Optional. The default is 0.",
              "default": "0",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "size.auto",
                "size.tiny",
                "size.small",
                "size.normal",
                "size.large",
                "size.huge"
              ]
            },
            {
              "name": "initial_value",
              "desc": "Initial value of all array elements. Optional. The default is 'na'.",
              "default": "na",
              "required": false,
              "displayType": "series bool",
              "allowedTypeIDs": [
                "series bool",
                "simple bool",
                "input bool",
                "const bool"
              ],
              "possibleValues": [
                "true",
                "false"
              ]
            }
          ],
          "syntax": "array.new_bool(size, initial_value) → array<bool>",
          "remarks": "An array index starts from 0.",
          "returns": "The ID of an array object which may be used in other array.*() functions.",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.get](#fun_array.get)",
            "[array.slice](#fun_array.slice)",
            "[array.sort](#fun_array.sort)"
          ],
          "examples": "//@version=5\nindicator(\"array.new_bool example\")\nlength = 5\na = array.new_bool(length, close > open)\nplot(array.get(a, 0) ? close : open)",
          "returnedType": "array<bool>",
          "returnedTypes": [
            "array<bool>"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "array.new_string",
          "desc": "The function creates a new array object of string type elements.",
          "args": [
            {
              "name": "size",
              "desc": "Initial size of an array. Optional. The default is 0.",
              "default": "0",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "size.auto",
                "size.tiny",
                "size.small",
                "size.normal",
                "size.large",
                "size.huge"
              ]
            },
            {
              "name": "initial_value",
              "desc": "Initial value of all array elements. Optional. The default is 'na'.",
              "default": "na",
              "required": false,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "array.new_string(size, initial_value) → array<string>",
          "remarks": "An array index starts from 0.",
          "returns": "The ID of an array object which may be used in other array.*() functions.",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.get](#fun_array.get)",
            "[array.slice](#fun_array.slice)"
          ],
          "examples": "//@version=5\nindicator(\"array.new_string example\")\nlength = 5\na = array.new_string(length, \"text\")\nlabel.new(bar_index, close, array.get(a, 0))",
          "returnedType": "array<string>",
          "returnedTypes": [
            "array<string>"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "array.new_line",
          "desc": "The function creates a new array object of line type elements.",
          "args": [
            {
              "name": "size",
              "desc": "Initial size of an array. Optional. The default is 0.",
              "default": "0",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "size.auto",
                "size.tiny",
                "size.small",
                "size.normal",
                "size.large",
                "size.huge"
              ]
            },
            {
              "name": "initial_value",
              "desc": "Initial value of all array elements. Optional. The default is 'na'.",
              "default": "na",
              "required": false,
              "displayType": "series line",
              "allowedTypeIDs": [
                "series line"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "array.new_line(size, initial_value) → array<line>",
          "remarks": "An array index starts from 0.",
          "returns": "The ID of an array object which may be used in other array.*() functions.",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.get](#fun_array.get)",
            "[array.slice](#fun_array.slice)"
          ],
          "examples": "//@version=5\nindicator(\"array.new_line example\")\n// draw last 15 lines\nvar a = array.new_line()\narray.push(a, line.new(bar_index - 1, close[1], bar_index, close))\nif array.size(a) > 15\n\tln = array.shift(a)\n\tline.delete(ln)",
          "returnedType": "array<line>",
          "returnedTypes": [
            "array<line>"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "array.new_box",
          "desc": "The function creates a new array object of box type elements.",
          "args": [
            {
              "name": "size",
              "desc": "Initial size of an array. Optional. The default is 0.",
              "default": "0",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "size.auto",
                "size.tiny",
                "size.small",
                "size.normal",
                "size.large",
                "size.huge"
              ]
            },
            {
              "name": "initial_value",
              "desc": "Initial value of all array elements. Optional. The default is 'na'.",
              "default": "na",
              "required": false,
              "displayType": "series box",
              "allowedTypeIDs": [
                "series box"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "array.new_box(size, initial_value) → array<box>",
          "remarks": "An array index starts from 0.",
          "returns": "The ID of an array object which may be used in other array.*() functions.",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.get](#fun_array.get)",
            "[array.slice](#fun_array.slice)"
          ],
          "examples": "//@version=5\nindicator(\"array.new_box example\")\nbox[] boxes = array.new_box()\narray.push(boxes, box.new(time, close, time+2, low, xloc=xloc.bar_time))\nplot(1)",
          "returnedType": "array<box>",
          "returnedTypes": [
            "array<box>"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "array.new_table",
          "desc": "The function creates a new array object of table type elements.",
          "args": [
            {
              "name": "size",
              "desc": "Initial size of an array. Optional. The default is 0.",
              "default": "0",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "size.auto",
                "size.tiny",
                "size.small",
                "size.normal",
                "size.large",
                "size.huge"
              ]
            },
            {
              "name": "initial_value",
              "desc": "Initial value of all array elements. Optional. The default is 'na'.",
              "default": "na",
              "required": false,
              "displayType": "series table",
              "allowedTypeIDs": [
                "series table"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "array.new_table(size, initial_value) → array<table>",
          "remarks": "An array index starts from 0.",
          "returns": "The ID of an array object which may be used in other array.*() functions.",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.get](#fun_array.get)",
            "[array.slice](#fun_array.slice)"
          ],
          "examples": "//@version=5\nindicator(\"table array\")\ntable[] tables = array.new_table()\narray.push(tables, table.new(position = position.top_left, rows = 1, columns = 2, bgcolor = color.yellow, border_width=1))\nplot(1)",
          "returnedType": "array<table>",
          "returnedTypes": [
            "array<table>"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "array.new_label",
          "desc": "The function creates a new array object of label type elements.",
          "args": [
            {
              "name": "size",
              "desc": "Initial size of an array. Optional. The default is 0.",
              "default": "0",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "size.auto",
                "size.tiny",
                "size.small",
                "size.normal",
                "size.large",
                "size.huge"
              ]
            },
            {
              "name": "initial_value",
              "desc": "Initial value of all array elements. Optional. The default is 'na'.",
              "default": "na",
              "required": false,
              "displayType": "series label",
              "allowedTypeIDs": [
                "series label"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "array.new_label(size, initial_value) → array<label>",
          "remarks": "An array index starts from 0.",
          "returns": "The ID of an array object which may be used in other array.*() functions.",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.get](#fun_array.get)",
            "[array.slice](#fun_array.slice)"
          ],
          "examples": "//@version=5\nindicator(\"array.new_label example\")\nvar a = array.new_label()\nl = label.new(bar_index, close, \"some text\")\narray.push(a, l)\nif close > close[1] and close[1] > close[2]\n\t// remove all labels\n\tsize = array.size(a) - 1\n\tfor i = 0 to size\n\t\tlb = array.get(a, i)\n\t\tlabel.delete(lb)",
          "returnedType": "array<label>",
          "returnedTypes": [
            "array<label>"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "array.new_linefill",
          "desc": "The function creates a new array object of linefill type elements.",
          "args": [
            {
              "name": "size",
              "desc": "Initial size of an array.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "size.auto",
                "size.tiny",
                "size.small",
                "size.normal",
                "size.large",
                "size.huge"
              ]
            },
            {
              "name": "initial_value",
              "desc": "Initial value of all array elements.",
              "default": null,
              "required": true,
              "displayType": "series linefill",
              "allowedTypeIDs": [
                "series linefill"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "array.new_linefill(size, initial_value) → array<linefill>",
          "remarks": "An array index starts from 0.",
          "returns": "The ID of an array object which may be used in other array.*() functions.",
          "examples": "//@version=5\nindicator(\"array.new_linefill example\")\nvar a = array.new_linefill()\nvar l1 = line.new(bar_index,high,bar_index+50,high, color=color.blue)\nvar l2 = line.new(bar_index,high,bar_index+50,high, color=color.blue)\n\nl = linefill.new(l1, l2, color.silver)\narray.push(a, l)\nif close > close[1] and close[1] > close[2]\n\t// remove all linefills\n\tsize = array.size(a) - 1\n\tfor i = 0 to size\n\t\tlf = array.get(a, i)\n\t\tlinefill.delete(lf)",
          "returnedType": "array<linefill>",
          "returnedTypes": [
            "array<linefill>"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "array.copy",
          "desc": "The function creates a copy of an existing array.",
          "args": [
            {
              "name": "id",
              "desc": "An array object.",
              "default": null,
              "required": true,
              "displayType": "any[]",
              "allowedTypeIDs": "array",
              "possibleValues": null
            }
          ],
          "syntax": "array.copy(id) → type[]",
          "returns": "A copy of an array.",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.get](#fun_array.get)",
            "[array.slice](#fun_array.slice)",
            "[array.sort](#fun_array.sort)"
          ],
          "examples": "//@version=5\nindicator(\"array.copy example\")\nlength = 5\na = array.new_float(length, close)\nb = array.copy(a)\na := array.new_float(length, open)\nplot(array.sum(a) / length)\nplot(array.sum(b) / length)"
        },
        {
          "kind": "Built-in Function",
          "name": "array.slice",
          "desc": "The function creates a slice from an existing array. If an object from the slice changes, the changes are applied to both the new and the original arrays.",
          "args": [
            {
              "name": "id",
              "desc": "An array object.",
              "default": null,
              "required": true,
              "displayType": "any[]",
              "allowedTypeIDs": "array",
              "possibleValues": null
            },
            {
              "name": "index_from",
              "desc": "Zero-based index at which to begin extraction.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "index_to",
              "desc": "Zero-based index before which to end extraction. The function extracts up to but not including the element with this index.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "array.slice(id, index_from, index_to) → type[]",
          "returns": "A shallow copy of an array\\`s slice.",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.get](#fun_array.get)",
            "[array.slice](#fun_array.slice)",
            "[array.sort](#fun_array.sort)"
          ],
          "examples": "//@version=5\nindicator(\"array.slice example\")\na = array.new_float(0)\nfor i = 0 to 9\n\tarray.push(a, close[i])\n// take elements from 0 to 4\n// *note that changes in slice also modify original array \nslice = array.slice(a, 0, 5)\nplot(array.sum(a) / 10)\nplot(array.sum(slice) / 5)"
        },
        {
          "kind": "Built-in Function",
          "name": "array.size",
          "desc": "The function returns the number of elements in an array.",
          "args": [
            {
              "name": "id",
              "desc": "An array object.",
              "default": null,
              "required": true,
              "displayType": "any[]",
              "allowedTypeIDs": "array",
              "possibleValues": null
            }
          ],
          "syntax": "array.size(id) → series int",
          "returns": "The number of elements in the array.",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.sum](#fun_array.sum)",
            "[array.slice](#fun_array.slice)",
            "[array.sort](#fun_array.sort)"
          ],
          "examples": "//@version=5\nindicator(\"array.size example\")\na = array.new_float(0)\nfor i = 0 to 9\n\tarray.push(a, close[i])\n// note that changes in slice also modify original array\nslice = array.slice(a, 0, 5)\narray.push(slice, open)\n// size was changed in slice and in original array\nplot(array.size(a))\nplot(array.size(slice))",
          "returnedType": "int",
          "returnedTypes": [
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "array.first",
          "desc": "Returns the array\\`s first element. Throws a runtime error if the array is empty.",
          "args": [
            {
              "name": "id",
              "desc": "An array object.",
              "default": null,
              "required": true,
              "displayType": "any[]",
              "allowedTypeIDs": "array",
              "possibleValues": null
            }
          ],
          "syntax": "array.first(id) → series type",
          "seeAlso": [
            "[array.last](#fun_array.last)",
            "[array.get](#fun_array.get)"
          ],
          "examples": "//@version=5\nindicator(\"array.first example\")\narr = array.new_int(3, 10)\nplot(array.first(arr))"
        },
        {
          "kind": "Built-in Function",
          "name": "array.last",
          "desc": "Returns the array\\`s last element. Throws a runtime error if the array is empty.",
          "args": [
            {
              "name": "id",
              "desc": "An array object.",
              "default": null,
              "required": true,
              "displayType": "any[]",
              "allowedTypeIDs": "array",
              "possibleValues": null
            }
          ],
          "syntax": "array.last(id) → series type",
          "seeAlso": [
            "[array.first](#fun_array.first)",
            "[array.get](#fun_array.get)"
          ],
          "examples": "//@version=5\nindicator(\"array.last example\")\narr = array.new_int(3, 10)\nplot(array.last(arr))"
        },
        {
          "kind": "Built-in Function",
          "name": "array.every",
          "desc": "Returns [true](#op_true) if all elements of the `id` array are [true](#op_true), [false](#op_false) otherwise.",
          "args": [
            {
              "name": "id",
              "desc": "An array object.",
              "default": null,
              "required": true,
              "displayType": "array<bool>",
              "allowedTypeIDs": [
                "array<bool>"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "array.every(id) → series bool",
          "remarks": "This function also works with arrays of [int](#op_int) and [float](#op_float) types, in which case zero values are considered [false](#op_false), and all others [true](#op_true).",
          "seeAlso": [
            "[array.some](#fun_array.some)",
            "[array.get](#fun_array.get)"
          ],
          "returnedType": "bool",
          "returnedTypes": [
            "series bool",
            "simple bool",
            "input bool",
            "const bool"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "array.some",
          "desc": "Returns [true](#op_true) if at least one element of the `id` array is [true](#op_true), [false](#op_false) otherwise.",
          "args": [
            {
              "name": "id",
              "desc": "An array object.",
              "default": null,
              "required": true,
              "displayType": "array<bool>",
              "allowedTypeIDs": [
                "array<bool>"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "array.some(id) → series bool",
          "remarks": "This function also works with arrays of [int](#op_int) and [float](#op_float) types, in which case zero values are considered [false](#op_false), and all others [true](#op_true).",
          "seeAlso": [
            "[array.every](#fun_array.every)",
            "[array.get](#fun_array.get)"
          ],
          "returnedType": "bool",
          "returnedTypes": [
            "series bool",
            "simple bool",
            "input bool",
            "const bool"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "array.get",
          "desc": "The function returns the value of the element at the specified index.",
          "args": [
            {
              "name": "id",
              "desc": "An array object.",
              "default": null,
              "required": true,
              "displayType": "any[]",
              "allowedTypeIDs": "array",
              "possibleValues": null
            },
            {
              "name": "index",
              "desc": "The index of the element whose value is to be returned.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "array.get(id, index) → series type",
          "returns": "The array element\\`s value.",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.set](#fun_array.set)",
            "[array.slice](#fun_array.slice)",
            "[array.sort](#fun_array.sort)"
          ],
          "examples": "//@version=5\nindicator(\"array.get example\")\na = array.new_float(0)\nfor i = 0 to 9\n\tarray.push(a, close[i] - open[i])\nplot(array.get(a, 9))"
        },
        {
          "kind": "Built-in Function",
          "name": "array.min",
          "desc": "The function returns the smallest value, or the nth smallest value in a given array.",
          "args": [
            {
              "name": "id",
              "desc": "An array object.",
              "default": null,
              "required": true,
              "displayType": "array<int|float>",
              "allowedTypeIDs": [
                "array<int>",
                "array<float>"
              ],
              "possibleValues": null
            },
            {
              "name": "nth",
              "desc": "The nth smallest value to return, where zero is the smallest. Optional. The default is 0.",
              "default": "0",
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "array.min(id) → series float|int\narray.min(id, nth) → series float|int",
          "returns": "The smallest or the nth smallest value in the array.",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.max](#fun_array.max)",
            "[array.sum](#fun_array.sum)"
          ],
          "examples": "//@version=5\nindicator(\"array.min\")\na = array.from(5, -2, 0, 9, 1)\nsecondLowest = array.min(a, 1) // 0\nplot(secondLowest)",
          "returnedType": [
            "float",
            "int"
          ],
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float",
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "array.max",
          "desc": "The function returns the greatest value, or the nth greatest value in a given array.",
          "args": [
            {
              "name": "id",
              "desc": "An array object.",
              "default": null,
              "required": true,
              "displayType": "array<int|float>",
              "allowedTypeIDs": [
                "array<int>",
                "array<float>"
              ],
              "possibleValues": null
            },
            {
              "name": "nth",
              "desc": "The nth greatest value to return, where zero is the greatest. Optional. The default is 0.",
              "default": "0",
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "array.max(id) → series float|int\narray.max(id, nth) → series float|int",
          "returns": "The greatest or the nth greatest value in the array.",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.min](#fun_array.min)",
            "[array.sum](#fun_array.sum)"
          ],
          "examples": "//@version=5\nindicator(\"array.max\")\na = array.from(5, -2, 0, 9, 1)\nthirdHighest = array.max(a, 2) // 1\nplot(thirdHighest)",
          "returnedType": [
            "float",
            "int"
          ],
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float",
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "array.range",
          "desc": "The function returns the difference between the min and max values from a given array.",
          "args": [
            {
              "name": "id",
              "desc": "An array object.",
              "default": null,
              "required": true,
              "displayType": "array<int|float>",
              "allowedTypeIDs": [
                "array<int>",
                "array<float>"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "array.range(id) → series float|int",
          "returns": "The difference between the min and max values in the array.",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.min](#fun_array.min)",
            "[array.max](#fun_array.max)",
            "[array.sum](#fun_array.sum)"
          ],
          "examples": "//@version=5\nindicator(\"array.range example\")\na = array.new_float(0)\nfor i = 0 to 9\n\tarray.push(a, close[i])\nplot(array.range(a))",
          "returnedType": [
            "float",
            "int"
          ],
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float",
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "array.sum",
          "desc": "The function returns the sum of an array\\`s elements.",
          "args": [
            {
              "name": "id",
              "desc": "An array object.",
              "default": null,
              "required": true,
              "displayType": "array<int|float>",
              "allowedTypeIDs": [
                "array<int>",
                "array<float>"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "array.sum(id) → series float|int",
          "returns": "The sum of the array\\`s elements.",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.max](#fun_array.max)",
            "[array.min](#fun_array.min)"
          ],
          "examples": "//@version=5\nindicator(\"array.sum example\")\na = array.new_float(0)\nfor i = 0 to 9\n\tarray.push(a, close[i])\nplot(array.sum(a))",
          "returnedType": [
            "float",
            "int"
          ],
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float",
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "array.set",
          "desc": "The function sets the value of the element at the specified index.",
          "args": [
            {
              "name": "id",
              "desc": "An array object.",
              "default": null,
              "required": true,
              "displayType": "any[]",
              "allowedTypeIDs": "array",
              "possibleValues": null
            },
            {
              "name": "index",
              "desc": "The index of the element to be modified.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "value",
              "desc": "The new value to be set.",
              "default": null,
              "required": true,
              "displayType": "any",
              "allowedTypeIDs": [],
              "possibleValues": null
            }
          ],
          "syntax": "array.set(id, index, value) → void",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.get](#fun_array.get)",
            "[array.slice](#fun_array.slice)"
          ],
          "examples": "//@version=5\nindicator(\"array.set example\")\na = array.new_float(10)\nfor i = 0 to 9\n\tarray.set(a, i, close[i])\nplot(array.sum(a) / 10)",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "array.from",
          "desc": "The function takes a variable number of arguments with one of the types: int, float, bool, string, label, line, color, box, table, linefill, and returns an array of the corresponding type.",
          "args": [
            {
              "name": "arg0, arg1, ...",
              "desc": "Array arguments.",
              "required": true,
              "displayType": "any",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float",
                "series bool",
                "simple bool",
                "input bool",
                "const bool",
                "series color",
                "simple color",
                "input color",
                "const color",
                "series string",
                "simple string",
                "input string",
                "const string",
                "series label",
                "series line",
                "series box",
                "series table",
                "series linefill"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "array.from(arg0, arg1, ...) → type[]",
          "returns": "The array element\\`s value.",
          "examples": "//@version=5\nindicator(\"array.from_example\", overlay = false)\narr = array.from(\"Hello\", \"World!\") // arr (string[]) will contain 2 elements: {Hello}, {World!}.\nplot(close)",
          "returnedType": [
            "array<bool>",
            "array<int>",
            "color[]",
            "array<float>",
            "string[]",
            "line[]",
            "label[]",
            "table[]",
            "linefill[]",
            "box[]",
            "array"
          ],
          "returnedTypes": [
            "array<int>",
            "array<float>",
            "array<bool>",
            "string[]",
            "label[]",
            "line[]",
            "color[]",
            "box[]",
            "table[]",
            "linefill[]",
            "array"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "array.fill",
          "desc": "The function sets elements of an array to a single value. If no index is specified, all elements are set. If only a start index (default 0) is supplied, the elements starting at that index are set. If both index parameters are used, the elements from the starting index up to but not including the end index (default na) are set.",
          "args": [
            {
              "name": "id",
              "desc": "An array object.",
              "default": null,
              "required": true,
              "displayType": "any[]",
              "allowedTypeIDs": "array",
              "possibleValues": null
            },
            {
              "name": "value",
              "desc": "Value to fill the array with.",
              "default": null,
              "required": true,
              "displayType": "any",
              "allowedTypeIDs": [],
              "possibleValues": [
                "close",
                "open",
                "high",
                "low",
                "volume"
              ]
            },
            {
              "name": "index_from",
              "desc": "Start index, default is 0.",
              "default": "0",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "index_to",
              "desc": "End index, default is na. Must be one greater than the index of the last element to set.",
              "default": "na",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "array.fill(id, value, index_from, index_to) → void",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.set](#fun_array.set)",
            "[array.slice](#fun_array.slice)"
          ],
          "examples": "//@version=5\nindicator(\"array.fill example\")\na = array.new_float(10)\narray.fill(a, close)\nplot(array.sum(a))",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "array.insert",
          "desc": "The function changes the contents of an array by adding new elements in place.",
          "args": [
            {
              "name": "id",
              "desc": "An array object.",
              "default": null,
              "required": true,
              "displayType": "any[]",
              "allowedTypeIDs": "array",
              "possibleValues": null
            },
            {
              "name": "index",
              "desc": "The index at which to insert the value.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "value",
              "desc": "The value to add to the array.",
              "default": null,
              "required": true,
              "displayType": "any",
              "allowedTypeIDs": [],
              "possibleValues": null
            }
          ],
          "syntax": "array.insert(id, index, value) → void",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.set](#fun_array.set)",
            "[array.push](#fun_array.push)",
            "[array.remove](#fun_array.remove)",
            "[array.pop](#fun_array.pop)",
            "[array.unshift](#fun_array.unshift)"
          ],
          "examples": "//@version=5\nindicator(\"array.insert example\")\na = array.new_float(5, close)\narray.insert(a, 0, open)\nplot(array.get(a, 5))",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "array.join",
          "desc": "The function creates and returns a new string by concatenating all the elements of an array, separated by the specified separator string.",
          "args": [
            {
              "name": "id",
              "desc": "An array object.",
              "default": null,
              "required": true,
              "displayType": "array<int|float|string>",
              "allowedTypeIDs": [
                "array<int>",
                "array<float>",
                "array<string>"
              ],
              "possibleValues": null
            },
            {
              "name": "separator",
              "desc": "The string used to separate each array element.",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "isString": true,
              "possibleValues": [
                "\\n",
                ",",
                ";",
                "|",
                "-",
                "."
              ]
            }
          ],
          "syntax": "array.join(id, separator) → series string",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.set](#fun_array.set)",
            "[array.insert](#fun_array.insert)",
            "[array.remove](#fun_array.remove)",
            "[array.pop](#fun_array.pop)",
            "[array.unshift](#fun_array.unshift)"
          ],
          "examples": "//@version=5\nindicator(\"array.join example\")\na = array.new_float(5, 5)\nlabel.new(bar_index, close, array.join(a, \", \"))",
          "returnedType": "string",
          "returnedTypes": [
            "series string",
            "simple string",
            "input string",
            "const string"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "array.push",
          "desc": "The function appends a value to an array.",
          "args": [
            {
              "name": "id",
              "desc": "An array object.",
              "default": null,
              "required": true,
              "displayType": "any[]",
              "allowedTypeIDs": "array",
              "possibleValues": null
            },
            {
              "name": "value",
              "desc": "The value of the element added to the end of the array.",
              "default": null,
              "required": true,
              "displayType": "any",
              "allowedTypeIDs": [],
              "possibleValues": null
            }
          ],
          "syntax": "array.push(id, value) → void",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.set](#fun_array.set)",
            "[array.insert](#fun_array.insert)",
            "[array.remove](#fun_array.remove)",
            "[array.pop](#fun_array.pop)",
            "[array.unshift](#fun_array.unshift)"
          ],
          "examples": "//@version=5\nindicator(\"array.push example\")\na = array.new_float(5, 0)\narray.push(a, open)\nplot(array.get(a, 5))",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "array.remove",
          "desc": "The function changes the contents of an array by removing the element with the specified index.",
          "args": [
            {
              "name": "id",
              "desc": "An array object.",
              "default": null,
              "required": true,
              "displayType": "any[]",
              "allowedTypeIDs": "array",
              "possibleValues": null
            },
            {
              "name": "index",
              "desc": "The index of the element to remove.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "array.remove(id, index) → series type",
          "returns": "The value of the removed element.",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.set](#fun_array.set)",
            "[array.push](#fun_array.push)",
            "[array.insert](#fun_array.insert)",
            "[array.pop](#fun_array.pop)",
            "[array.shift](#fun_array.shift)"
          ],
          "examples": "//@version=5\nindicator(\"array.remove example\")\na = array.new_float(5, high)\nremovedEl = array.remove(a, 0)\nplot(array.size(a))\nplot(removedEl)"
        },
        {
          "kind": "Built-in Function",
          "name": "array.pop",
          "desc": "The function removes the last element from an array and returns its value.",
          "args": [
            {
              "name": "id",
              "desc": "An array object.",
              "default": null,
              "required": true,
              "displayType": "any[]",
              "allowedTypeIDs": "array",
              "possibleValues": null
            }
          ],
          "syntax": "array.pop(id) → series type",
          "returns": "The value of the removed element.",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.set](#fun_array.set)",
            "[array.push](#fun_array.push)",
            "[array.remove](#fun_array.remove)",
            "[array.insert](#fun_array.insert)",
            "[array.shift](#fun_array.shift)"
          ],
          "examples": "//@version=5\nindicator(\"array.pop example\")\na = array.new_float(5, high)\nremovedEl = array.pop(a)\nplot(array.size(a))\nplot(removedEl)"
        },
        {
          "kind": "Built-in Function",
          "name": "array.clear",
          "desc": "The function removes all elements from an array.",
          "args": [
            {
              "name": "id",
              "desc": "An array object.",
              "default": null,
              "required": true,
              "displayType": "any[]",
              "allowedTypeIDs": "array",
              "possibleValues": null
            }
          ],
          "syntax": "array.clear(id) → void",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.insert](#fun_array.insert)",
            "[array.push](#fun_array.push)",
            "[array.remove](#fun_array.remove)",
            "[array.pop](#fun_array.pop)"
          ],
          "examples": "//@version=5\nindicator(\"array.clear example\")\na = array.new_float(5, high)\narray.clear(a)\narray.push(a, close)\nplot(array.get(a, 0))\nplot(array.size(a))",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "array.sort",
          "desc": "The function sorts the elements of an array.",
          "args": [
            {
              "name": "id",
              "desc": "An array object.",
              "default": null,
              "required": true,
              "displayType": "array<int|float|string>",
              "allowedTypeIDs": [
                "array<int>",
                "array<float>",
                "array<string>"
              ],
              "possibleValues": null
            },
            {
              "name": "order",
              "desc": "The sort order: order.ascending (default) or order.descending.",
              "default": "order.ascending",
              "required": false,
              "displayType": "simple sort_order",
              "allowedTypeIDs": [
                "simple sort_order",
                "series sort_order"
              ],
              "possibleValues": [
                "order.ascending",
                "order.descending"
              ]
            }
          ],
          "syntax": "array.sort(id, order) → void",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.insert](#fun_array.insert)",
            "[array.slice](#fun_array.slice)",
            "[array.reverse](#fun_array.reverse)",
            "[order.ascending](#const_order.ascending)",
            "[order.descending](#const_order.descending)"
          ],
          "examples": "//@version=5\nindicator(\"array.sort example\")\na = array.new_float(0, 0)\nfor i = 0 to 5\n\tarray.push(a, high[i])\narray.sort(a, order.descending)\nif barstate.islast\n\tlabel.new(bar_index, close, str.tostring(a))",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "array.sort_indices",
          "desc": "Returns an array of indices which, when used to index the original array, will access its elements in their sorted order. It does not modify the original array.",
          "args": [
            {
              "name": "id",
              "desc": "An array object.",
              "default": null,
              "required": true,
              "displayType": "array<int|float|string>",
              "allowedTypeIDs": [
                "array<int>",
                "array<float>",
                "array<string>"
              ],
              "possibleValues": null
            },
            {
              "name": "order",
              "desc": "The sort order: order.ascending or order.descending. Optional. The default is order.ascending.",
              "default": "order.ascending",
              "required": false,
              "displayType": "series sort_order",
              "allowedTypeIDs": [
                "series sort_order"
              ],
              "possibleValues": [
                "order.ascending",
                "order.descending"
              ]
            }
          ],
          "syntax": "array.sort_indices(id, order) → array<int>",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.insert](#fun_array.insert)",
            "[array.slice](#fun_array.slice)",
            "[array.reverse](#fun_array.reverse)",
            "[order.ascending](#const_order.ascending)",
            "[order.descending](#const_order.descending)"
          ],
          "examples": "//@version=5\nindicator(\"array.sort_indices\")\na = array.from(5, -2, 0, 9, 1)\nsortedIndices = array.sort_indices(a) // [1, 2, 4, 0, 3]\nindexOfSmallestValue = array.get(sortedIndices, 0) // 1\nsmallestValue = array.get(a, indexOfSmallestValue) // -2\nplot(smallestValue)",
          "returnedType": "array<int>",
          "returnedTypes": [
            "array<int>"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "array.percentrank",
          "desc": "Returns the percentile rank of the element at the specified `index`.",
          "args": [
            {
              "name": "id",
              "desc": "An array object.",
              "default": null,
              "required": true,
              "displayType": "array<int|float>",
              "allowedTypeIDs": [
                "array<int>",
                "array<float>"
              ],
              "possibleValues": null
            },
            {
              "name": "index",
              "desc": "The index of the element for which the percentile rank should be calculated.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "array.percentrank(id, index) → series float|int",
          "remarks": "Percentile rank is the percentage of how many elements in the array are less than or equal to the reference value.",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.insert](#fun_array.insert)",
            "[array.slice](#fun_array.slice)",
            "[array.reverse](#fun_array.reverse)",
            "[order.ascending](#const_order.ascending)",
            "[order.descending](#const_order.descending)"
          ],
          "returnedType": [
            "float",
            "int"
          ],
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float",
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "array.percentile_nearest_rank",
          "desc": "Returns the value for which the specified percentage of array values (percentile) are less than or equal to it, using the nearest-rank method.",
          "args": [
            {
              "name": "id",
              "desc": "An array object.",
              "default": null,
              "required": true,
              "displayType": "array<int|float>",
              "allowedTypeIDs": [
                "array<int>",
                "array<float>"
              ],
              "possibleValues": null
            },
            {
              "name": "percentage",
              "desc": "The percentage of values that must be equal or less than the returned value.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                0,
                25,
                50,
                75,
                100
              ]
            }
          ],
          "syntax": "array.percentile_nearest_rank(id, percentage) → series float|int",
          "remarks": "In statistics, the percentile is the percent of ranking items that appear at or below a certain score.  \nThis measurement shows the percentage of scores within a standard frequency distribution that is lower than the percentile rank you're measuring.",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.insert](#fun_array.insert)",
            "[array.slice](#fun_array.slice)",
            "[array.reverse](#fun_array.reverse)",
            "[order.ascending](#const_order.ascending)",
            "[order.descending](#const_order.descending)"
          ],
          "returnedType": [
            "float",
            "int"
          ],
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float",
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "array.percentile_linear_interpolation",
          "desc": "Returns the value for which the specified percentage of array values (percentile) are less than or equal to it, using linear interpolation.",
          "args": [
            {
              "name": "id",
              "desc": "An array object.",
              "default": null,
              "required": true,
              "displayType": "array<int|float>",
              "allowedTypeIDs": [
                "array<int>",
                "array<float>"
              ],
              "possibleValues": null
            },
            {
              "name": "percentage",
              "desc": "The percentage of values that must be equal or less than the returned value.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                0,
                25,
                50,
                75,
                100
              ]
            }
          ],
          "syntax": "array.percentile_linear_interpolation(id, percentage) → series float|int",
          "remarks": "In statistics, the percentile is the percent of ranking items that appear at or below a certain score.  \nThis measurement shows the percentage of scores within a standard frequency distribution that is lower than the percentile rank you're measuring.  \nLinear interpolation estimates the value between two ranks.",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.insert](#fun_array.insert)",
            "[array.slice](#fun_array.slice)",
            "[array.reverse](#fun_array.reverse)",
            "[order.ascending](#const_order.ascending)",
            "[order.descending](#const_order.descending)"
          ],
          "returnedType": [
            "float",
            "int"
          ],
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float",
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "array.abs",
          "desc": "Returns an array containing the absolute value of each element in the original array.",
          "args": [
            {
              "name": "id",
              "desc": "An array object.",
              "default": null,
              "required": true,
              "displayType": "array<int|float>",
              "allowedTypeIDs": [
                "array<int>",
                "array<float>"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "array.abs(id) → array<float|int>",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.insert](#fun_array.insert)",
            "[array.slice](#fun_array.slice)",
            "[array.reverse](#fun_array.reverse)",
            "[order.ascending](#const_order.ascending)",
            "[order.descending](#const_order.descending)"
          ],
          "returnedType": [
            "array<int>",
            "array<float>"
          ],
          "returnedTypes": [
            "array<float>",
            "array<int>"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "array.binary_search",
          "desc": "The function returns the index of the value, or -1 if the value is not found. The array to search must be sorted in ascending order.",
          "args": [
            {
              "name": "id",
              "desc": "An array object.",
              "default": null,
              "required": true,
              "displayType": "array<int|float>",
              "allowedTypeIDs": [
                "array<int>",
                "array<float>"
              ],
              "possibleValues": null
            },
            {
              "name": "val",
              "desc": "The value to search for in the array.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "array.binary_search(id, val) → series int",
          "remarks": "A binary search works on arrays pre-sorted in ascending order. It begins by comparing an element in the middle of the array with the target value.  \nIf the element matches the target value, its position in the array is returned.  \nIf the element\\`s value is greater than the target value, the search continues in the lower half of the array.  \nIf the element\\`s value is less than the target value, the search continues in the upper half of the array.  \nBy doing this recursively, the algorithm progressively eliminates smaller and smaller portions of the array in which the target value cannot lie.",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.insert](#fun_array.insert)",
            "[array.slice](#fun_array.slice)",
            "[array.reverse](#fun_array.reverse)",
            "[order.ascending](#const_order.ascending)",
            "[order.descending](#const_order.descending)"
          ],
          "examples": "//@version=5\nindicator(\"array.binary_search\")\na = array.from(5, -2, 0, 9, 1)\narray.sort(a) // [-2, 0, 1, 5, 9]\nposition = array.binary_search(a, 0) // 1\nplot(position)",
          "returnedType": "int",
          "returnedTypes": [
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "array.binary_search_leftmost",
          "desc": "The function returns the index of the value if it is found. When the value is not found, the function returns the index of the next smallest element to the left of where the value would lie if it was in the array. The array to search must be sorted in ascending order.",
          "args": [
            {
              "name": "id",
              "desc": "An array object.",
              "default": null,
              "required": true,
              "displayType": "array<int|float>",
              "allowedTypeIDs": [
                "array<int>",
                "array<float>"
              ],
              "possibleValues": null
            },
            {
              "name": "val",
              "desc": "The value to search for in the array.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "array.binary_search_leftmost(id, val) → series int",
          "remarks": "A binary search works on arrays pre-sorted in ascending order. It begins by comparing an element in the middle of the array with the target value.  \nIf the element matches the target value, its position in the array is returned.  \nIf the element\\`s value is greater than the target value, the search continues in the lower half of the array.  \nIf the element\\`s value is less than the target value, the search continues in the upper half of the array.  \nBy doing this recursively, the algorithm progressively eliminates smaller and smaller portions of the array in which the target value cannot lie.",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.insert](#fun_array.insert)",
            "[array.slice](#fun_array.slice)",
            "[array.reverse](#fun_array.reverse)",
            "[order.ascending](#const_order.ascending)",
            "[order.descending](#const_order.descending)"
          ],
          "returnedType": "int",
          "detailedDesc": [
            {
              "desc": "",
              "examples": "//@version=5\nindicator(\"array.binary_search_leftmost\")\na = array.from(5, -2, 0, 9, 1)\narray.sort(a) // [-2, 0, 1, 5, 9]\nposition = array.binary_search_leftmost(a, 3) // 2\nplot(position)"
            },
            {
              "desc": "",
              "examples": "//@version=5\nindicator(\"array.binary_search_leftmost, repetitive elements\")\na = array.from(4, 5, 5, 5)\n// Returns the index of the first instance.\nposition = array.binary_search_leftmost(a, 5) \nplot(position) // Plots 1"
            }
          ],
          "returnedTypes": [
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "array.binary_search_rightmost",
          "desc": "The function returns the index of the value if it is found. When the value is not found, the function returns the index of the element to the right of where the value would lie if it was in the array. The array must be sorted in ascending order.",
          "args": [
            {
              "name": "id",
              "desc": "An array object.",
              "default": null,
              "required": true,
              "displayType": "array<int|float>",
              "allowedTypeIDs": [
                "array<int>",
                "array<float>"
              ],
              "possibleValues": null
            },
            {
              "name": "val",
              "desc": "The value to search for in the array.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "array.binary_search_rightmost(id, val) → series int",
          "remarks": "A binary search works on sorted arrays in ascending order. It begins by comparing an element in the middle of the array with the target value.  \nIf the element matches the target value, its position in the array is returned.  \nIf the element\\`s value is greater than the target value, the search continues in the lower half of the array.  \nIf the element\\`s value is less than the target value, the search continues in the upper half of the array.  \nBy doing this recursively, the algorithm progressively eliminates smaller and smaller portions of the array in which the target value cannot lie.",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.insert](#fun_array.insert)",
            "[array.slice](#fun_array.slice)",
            "[array.reverse](#fun_array.reverse)",
            "[order.ascending](#const_order.ascending)",
            "[order.descending](#const_order.descending)"
          ],
          "returnedType": "int",
          "detailedDesc": [
            {
              "desc": "",
              "examples": "//@version=5\nindicator(\"array.binary_search_rightmost\")\na = array.from(5, -2, 0, 9, 1)\narray.sort(a) // [-2, 0, 1, 5, 9]\nposition = array.binary_search_rightmost(a, 3) // 3\nplot(position)"
            },
            {
              "desc": "",
              "examples": "//@version=5\nindicator(\"array.binary_search_rightmost, repetitive elements\")\na = array.from(4, 5, 5, 5)\n// Returns the index of the last instance.\nposition = array.binary_search_rightmost(a, 5) \nplot(position) // Plots 3"
            }
          ],
          "returnedTypes": [
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "array.concat",
          "desc": "The function is used to merge two arrays. It pushes all elements from the second array to the first array, and returns the first array.",
          "args": [
            {
              "name": "id1",
              "desc": "The first array object.",
              "required": true,
              "displayType": "any[]",
              "allowedTypeIDs": "array",
              "possibleValues": null
            },
            {
              "name": "id2",
              "desc": "The second array object.",
              "default": null,
              "required": true,
              "displayType": "any[]",
              "allowedTypeIDs": "array",
              "possibleValues": null
            }
          ],
          "syntax": "array.concat(id1, id2) → type[]",
          "returns": "The first array with merged elements from the second array.",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.insert](#fun_array.insert)",
            "[array.slice](#fun_array.slice), "
          ],
          "examples": "//@version=5\nindicator(\"array.concat example\")\na = array.new_float(0, 0)\nb = array.new_float(0, 0)\nfor i = 0 to 4\n    array.push(a, high[i])\n    array.push(b, low[i])\nc = array.concat(a, b)\nplot(array.size(a))\nplot(array.size(b))\nplot(array.size(c))"
        },
        {
          "kind": "Built-in Function",
          "name": "array.avg",
          "desc": "The function returns the mean of an array\\`s elements.",
          "args": [
            {
              "name": "id",
              "desc": "An array object.",
              "default": null,
              "required": true,
              "displayType": "array<int|float>",
              "allowedTypeIDs": [
                "array<int>",
                "array<float>"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "array.avg(id) → series float|int",
          "returns": "Mean of array\\`s elements.",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.max](#fun_array.max)",
            "[array.min](#fun_array.min)",
            "[array.stdev](#fun_array.stdev)"
          ],
          "examples": "//@version=5\nindicator(\"array.avg example\")\na = array.new_float(0)\nfor i = 0 to 9\n\tarray.push(a, close[i])\nplot(array.avg(a))",
          "returnedType": [
            "float",
            "int"
          ],
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float",
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "array.stdev",
          "desc": "The function returns the standard deviation of an array\\`s elements.",
          "args": [
            {
              "name": "id",
              "desc": "An array object.",
              "default": null,
              "required": true,
              "displayType": "array<int|float>",
              "allowedTypeIDs": [
                "array<int>",
                "array<float>"
              ],
              "possibleValues": null
            },
            {
              "name": "biased",
              "desc": "Determines which estimate should be used. Optional. The default is true.",
              "default": "true",
              "required": false,
              "displayType": "series bool",
              "allowedTypeIDs": [
                "series bool",
                "simple bool",
                "input bool",
                "const bool"
              ],
              "possibleValues": [
                "true",
                "false"
              ]
            }
          ],
          "syntax": "array.stdev(id, biased) → series float|int",
          "remarks": "If `biased` is true, function will calculate using a biased estimate of the entire population, if false - unbiased estimate of a sample.",
          "returns": "The standard deviation of the array\\`s elements.",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.max](#fun_array.max)",
            "[array.min](#fun_array.min)",
            "[array.avg](#fun_array.avg)"
          ],
          "examples": "//@version=5\nindicator(\"array.stdev example\")\na = array.new_float(0)\nfor i = 0 to 9\n\tarray.push(a, close[i])\nplot(array.stdev(a))",
          "returnedType": [
            "float",
            "int"
          ],
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float",
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "array.variance",
          "desc": "The function returns the variance of an array\\`s elements.",
          "args": [
            {
              "name": "id",
              "desc": "An array object.",
              "default": null,
              "required": true,
              "displayType": "array<int|float>",
              "allowedTypeIDs": [
                "array<int>",
                "array<float>"
              ],
              "possibleValues": null
            },
            {
              "name": "biased",
              "desc": "Determines which estimate should be used. Optional. The default is true.",
              "default": "true",
              "required": false,
              "displayType": "series bool",
              "allowedTypeIDs": [
                "series bool",
                "simple bool",
                "input bool",
                "const bool"
              ],
              "possibleValues": [
                "true",
                "false"
              ]
            }
          ],
          "syntax": "array.variance(id, biased) → series float|int",
          "remarks": "If `biased` is true, function will calculate using a biased estimate of the entire population, if false - unbiased estimate of a sample.",
          "returns": "The variance of the array\\`s elements.",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.stdev](#fun_array.stdev)",
            "[array.min](#fun_array.min)",
            "[array.avg](#fun_array.avg)",
            "[array.covariance](#fun_array.covariance)"
          ],
          "examples": "//@version=5\nindicator(\"array.variance example\")\na = array.new_float(0)\nfor i = 0 to 9\n\tarray.push(a, close[i])\nplot(array.variance(a))",
          "returnedType": [
            "float",
            "int"
          ],
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float",
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "array.covariance",
          "desc": "The function returns the covariance of two arrays.",
          "args": [
            {
              "name": "id1",
              "desc": "An array object.",
              "required": true,
              "displayType": "array<int|float>",
              "allowedTypeIDs": [
                "array<int>",
                "array<float>"
              ],
              "possibleValues": null
            },
            {
              "name": "id2",
              "desc": "An array object.",
              "default": null,
              "required": true,
              "displayType": "array<int|float>",
              "allowedTypeIDs": [
                "array<int>",
                "array<float>"
              ],
              "possibleValues": null
            },
            {
              "name": "biased",
              "desc": "Determines which estimate should be used. Optional. The default is true.",
              "default": "true",
              "required": false,
              "displayType": "series bool",
              "allowedTypeIDs": [
                "series bool",
                "simple bool",
                "input bool",
                "const bool"
              ],
              "possibleValues": [
                "true",
                "false"
              ]
            }
          ],
          "syntax": "array.covariance(id1, id2, biased) → series float",
          "remarks": "If `biased` is true, function will calculate using a biased estimate of the entire population, if false - unbiased estimate of a sample.",
          "returns": "The covariance of two arrays.",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.max](#fun_array.max)",
            "[array.stdev](#fun_array.stdev)",
            "[array.avg](#fun_array.avg)",
            "[array.variance](#fun_array.variance)"
          ],
          "examples": "//@version=5\nindicator(\"array.covariance example\")\na = array.new_float(0)\nb = array.new_float(0)\nfor i = 0 to 9\n\tarray.push(a, close[i])\n\tarray.push(b, open[i])\nplot(array.covariance(a, b))",
          "returnedType": "float",
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "array.mode",
          "desc": "The function returns the mode of an array\\`s elements. If there are several values with the same frequency, it returns the smallest value.",
          "args": [
            {
              "name": "id",
              "desc": "An array object.",
              "default": null,
              "required": true,
              "displayType": "array<int|float>",
              "allowedTypeIDs": [
                "array<int>",
                "array<float>"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "array.mode(id) → series float|int",
          "returns": "The most frequently occurring value from the `id` array. If none exists, returns the smallest value instead.",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[ta.mode](#fun_ta.mode)",
            "[matrix.mode](#fun_matrix.mode)",
            "[array.avg](#fun_array.avg)",
            "[array.variance](#fun_array.variance)",
            "[array.min](#fun_array.min)"
          ],
          "examples": "//@version=5\nindicator(\"array.mode example\")\na = array.new_float(0)\nfor i = 0 to 9\n\tarray.push(a, close[i])\nplot(array.mode(a))",
          "returnedType": [
            "float",
            "int"
          ],
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float",
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "array.median",
          "desc": "The function returns the median of an array\\`s elements.",
          "args": [
            {
              "name": "id",
              "desc": "An array object.",
              "default": null,
              "required": true,
              "displayType": "array<int|float>",
              "allowedTypeIDs": [
                "array<int>",
                "array<float>"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "array.median(id) → series float|int",
          "returns": "The median of the array\\`s elements.",
          "seeAlso": [
            "[array.median](#fun_array.median)",
            "[array.avg](#fun_array.avg)",
            "[array.variance](#fun_array.variance)",
            "[array.min](#fun_array.min)"
          ],
          "examples": "//@version=5\nindicator(\"array.median example\")\na = array.new_float(0)\nfor i = 0 to 9\n\tarray.push(a, close[i])\nplot(array.median(a))",
          "returnedType": [
            "float",
            "int"
          ],
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float",
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "array.standardize",
          "desc": "The function returns the array of standardized elements.",
          "args": [
            {
              "name": "id",
              "desc": "An array object.",
              "default": null,
              "required": true,
              "displayType": "array<int|float>",
              "allowedTypeIDs": [
                "array<int>",
                "array<float>"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "array.standardize(id) → array<float|int>",
          "returns": "The array of standardized elements.",
          "seeAlso": [
            "[array.max](#fun_array.max)",
            "[array.min](#fun_array.min)",
            "[array.mode](#fun_array.mode)",
            "[array.avg](#fun_array.avg)",
            "[array.variance](#fun_array.variance)",
            "[array.stdev](#fun_array.stdev)"
          ],
          "examples": "//@version=5\nindicator(\"array.standardize example\")\na = array.new_float(0)\nfor i = 0 to 9\n\tarray.push(a, close[i])\nb = array.standardize(a)\nplot(array.min(b))\nplot(array.max(b))",
          "returnedType": [
            "array<int>",
            "array<float>"
          ],
          "returnedTypes": [
            "array<float>",
            "array<int>"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "array.indexof",
          "desc": "The function returns the index of the first occurrence of the value, or -1 if the value is not found.",
          "args": [
            {
              "name": "id",
              "desc": "An array object.",
              "default": null,
              "required": true,
              "displayType": "any[]",
              "allowedTypeIDs": "array",
              "possibleValues": null
            },
            {
              "name": "value",
              "desc": "The value to search in the array.",
              "default": null,
              "required": true,
              "displayType": "any",
              "allowedTypeIDs": [],
              "possibleValues": null
            }
          ],
          "syntax": "array.indexof(id, value) → series int",
          "returns": "The index of an element.",
          "seeAlso": [
            "[array.lastindexof](#fun_array.lastindexof)",
            "[array.get](#fun_array.get)",
            "[array.lastindexof](#fun_array.lastindexof)",
            "[array.remove](#fun_array.remove)",
            "[array.insert](#fun_array.insert)"
          ],
          "examples": "//@version=5\nindicator(\"array.indexof example\")\na = array.new_float(5, high)\nindex = array.indexof(a, high)\nplot(index)",
          "returnedType": "int",
          "returnedTypes": [
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "array.lastindexof",
          "desc": "The function returns the index of the last occurrence of the value, or -1 if the value is not found.",
          "args": [
            {
              "name": "id",
              "desc": "An array object.",
              "default": null,
              "required": true,
              "displayType": "any[]",
              "allowedTypeIDs": "array",
              "possibleValues": null
            },
            {
              "name": "value",
              "desc": "The value to search in the array.",
              "default": null,
              "required": true,
              "displayType": "any",
              "allowedTypeIDs": [],
              "possibleValues": null
            }
          ],
          "syntax": "array.lastindexof(id, value) → series int",
          "returns": "The index of an element.",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.set](#fun_array.set)",
            "[array.push](#fun_array.push)",
            "[array.remove](#fun_array.remove)",
            "[array.insert](#fun_array.insert)"
          ],
          "examples": "//@version=5\nindicator(\"array.lastindexof example\")\na = array.new_float(5, high)\nindex = array.lastindexof(a, high)\nplot(index)",
          "returnedType": "int",
          "returnedTypes": [
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "array.includes",
          "desc": "The function returns true if the value was found in an array, false otherwise.",
          "args": [
            {
              "name": "id",
              "desc": "An array object.",
              "default": null,
              "required": true,
              "displayType": "any[]",
              "allowedTypeIDs": "array",
              "possibleValues": null
            },
            {
              "name": "value",
              "desc": "The value to search in the array.",
              "default": null,
              "required": true,
              "displayType": "any",
              "allowedTypeIDs": [],
              "possibleValues": null
            }
          ],
          "syntax": "array.includes(id, value) → series bool",
          "returns": "True if the value was found in the array, false otherwise.",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.indexof](#fun_array.indexof)",
            "[array.shift](#fun_array.shift)",
            "[array.remove](#fun_array.remove)",
            "[array.insert](#fun_array.insert)"
          ],
          "examples": "//@version=5\nindicator(\"array.includes example\")\na = array.new_float(5, high)\np = close\nif array.includes(a, high)\n\tp := open\nplot(p)",
          "returnedType": "bool",
          "returnedTypes": [
            "series bool",
            "simple bool",
            "input bool",
            "const bool"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "array.shift",
          "desc": "The function removes an array\\`s first element and returns its value.",
          "args": [
            {
              "name": "id",
              "desc": "An array object.",
              "default": null,
              "required": true,
              "displayType": "any[]",
              "allowedTypeIDs": "array",
              "possibleValues": null
            }
          ],
          "syntax": "array.shift(id) → series type",
          "returns": "The value of the removed element.",
          "seeAlso": [
            "[array.unshift](#fun_array.unshift)",
            "[array.set](#fun_array.set)",
            "[array.push](#fun_array.push)",
            "[array.remove](#fun_array.remove)",
            "[array.includes](#fun_array.includes)"
          ],
          "examples": "//@version=5\nindicator(\"array.shift example\")\na = array.new_float(5, high)\nremovedEl = array.shift(a)\nplot(array.size(a))\nplot(removedEl)"
        },
        {
          "kind": "Built-in Function",
          "name": "array.unshift",
          "desc": "The function inserts the value at the beginning of the array.",
          "args": [
            {
              "name": "id",
              "desc": "An array object.",
              "default": null,
              "required": true,
              "displayType": "any[]",
              "allowedTypeIDs": "array",
              "possibleValues": null
            },
            {
              "name": "value",
              "desc": "The value to add to the start of the array.",
              "default": null,
              "required": true,
              "displayType": "any",
              "allowedTypeIDs": [],
              "possibleValues": null
            }
          ],
          "syntax": "array.unshift(id, value) → void",
          "seeAlso": [
            "[array.shift](#fun_array.shift)",
            "[array.set](#fun_array.set)",
            "[array.insert](#fun_array.insert)",
            "[array.remove](#fun_array.remove)",
            "[array.indexof](#fun_array.indexof)"
          ],
          "examples": "//@version=5\nindicator(\"array.unshift example\")\na = array.new_float(5, 0)\narray.unshift(a, open)\nplot(array.get(a, 0))",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "array.reverse",
          "desc": "The function reverses an array. The first array element becomes the last, and the last array element becomes the first.",
          "args": [
            {
              "name": "id",
              "desc": "An array object.",
              "default": null,
              "required": true,
              "displayType": "any[]",
              "allowedTypeIDs": "array",
              "possibleValues": null
            }
          ],
          "syntax": "array.reverse(id) → void",
          "seeAlso": [
            "[array.new_float](#fun_array.new_float)",
            "[array.sort](#fun_array.sort)",
            "[array.push](#fun_array.push)",
            "[array.set](#fun_array.set)",
            "[array.avg](#fun_array.avg)"
          ],
          "examples": "//@version=5\nindicator(\"array.reverse example\")\na = array.new_float(0)\nfor i = 0 to 9\n\tarray.push(a, close[i])\nplot(array.get(a, 0))\narray.reverse(a)\nplot(array.get(a, 0))",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "alert",
          "desc": "Creates an alert event when called during the real-time bar, which will trigger a script alert based on \"alert function events\" if one was previously created for the indicator or strategy through the \"Create Alert\" dialog box.",
          "args": [
            {
              "name": "message",
              "desc": "Message sent when the alert triggers. Required argument.",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "freq",
              "desc": "The triggering frequency. Possible values are: [alert.freq_all](#var_alert.freq_all) (all function calls trigger the alert), [alert.freq_once_per_bar](#var_alert.freq_once_per_bar) (the first function call during the bar triggers the alert), [alert.freq_once_per_bar_close](#var_alert.freq_once_per_bar_close) (the function call triggers the alert only when it occurs during the last script iteration of the real-time bar, when it closes).  \nThe default is [alert.freq_once_per_bar](#var_alert.freq_once_per_bar).",
              "default": "alert.freq_once_per_bar",
              "required": true,
              "displayType": "input string",
              "allowedTypeIDs": [
                "input string",
                "const string"
              ],
              "possibleValues": [
                "alert.freq_all",
                "alert.freq_once_per_bar",
                "alert.freq_once_per_bar_close"
              ]
            }
          ],
          "syntax": "alert(message, freq) → void",
          "remarks": "The [Help Center](https://www.tradingview.com/chart/?solution=43000597494) explains how to create such alerts.\nContrary to [alertcondition](#fun_alertcondition), [alert](#fun_alert) calls do NOT count as an additional plot.\nFunction calls can be located in both global and local scopes.\nFunction calls do not display anything on the chart.\nThe 'freq' argument only affects the triggering frequency of the function call where it is used.",
          "seeAlso": [
            "[alertcondition](#fun_alertcondition)"
          ],
          "examples": "//@version=5\nindicator(\"`alert()` example\", \"\", true)\nma = ta.sma(close, 14)\nxUp = ta.crossover(close, ma)\nif xUp\n    // Trigger the alert the first time a cross occurs during the real-time bar.\n    alert(\"Price (\" + str.tostring(close) + \") crossed over MA (\" + str.tostring(ma) +  \").\", alert.freq_once_per_bar)\nplot(ma)\nplotchar(xUp, \"xUp\", \"▲\", location.top, size = size.tiny)",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "request.earnings",
          "desc": "Requests earnings data for the specified symbol.",
          "args": [
            {
              "name": "ticker",
              "desc": "Symbol. Note that the symbol should be passed with a prefix. For example: \"NASDAQ:AAPL\" instead of \"AAPL\".  \nUsing [syminfo.ticker](#var_syminfo.ticker) will cause an error.  \nUse [syminfo.tickerid](#var_syminfo.tickerid) instead.",
              "default": null,
              "required": true,
              "displayType": "simple string",
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "field",
              "desc": "Input string. Possible values include: [earnings.actual](#var_earnings.actual), [earnings.estimate](#var_earnings.estimate), [earnings.standardized](#var_earnings.standardized).  \nDefault value is [earnings.actual](#var_earnings.actual).",
              "default": "earnings.actual",
              "required": true,
              "displayType": "simple string",
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "earnings.actual",
                "earnings.estimate",
                "earnings.standardized"
              ]
            },
            {
              "name": "gaps",
              "desc": "Merge strategy for the requested data (requested data automatically merges with the main series OHLC data). \nPossible values: [barmerge.gaps_on](#var_barmerge.gaps_on), [barmerge.gaps_off](#var_barmerge.gaps_off). [barmerge.gaps_on](#var_barmerge.gaps_on) - requested data is merged with possible gaps ([na](#var_na) values). [barmerge.gaps_off](#var_barmerge.gaps_off) - requested data is merged continuously without gaps, all the gaps are filled with the previous nearest existing values.  \nDefault value is [barmerge.gaps_off](#var_barmerge.gaps_off).",
              "default": "barmerge.gaps_off",
              "required": true,
              "displayType": "simple barmerge_gaps",
              "allowedTypeIDs": [
                "simple barmerge_gaps"
              ],
              "possibleValues": [
                "barmerge.gaps_on",
                "barmerge.gaps_off"
              ]
            },
            {
              "name": "lookahead",
              "desc": "Merge strategy for the requested data position.  \nPossible values: [barmerge.lookahead_on](#var_barmerge.lookahead_on), [barmerge.lookahead_off](#var_barmerge.lookahead_off).  \nDefault value is [barmerge.lookahead_off](#var_barmerge.lookahead_off) starting from version 3.  \nNote that behavour is the same on real-time, and differs only on history.",
              "default": "barmerge.lookahead_off",
              "required": true,
              "displayType": "simple barmerge_lookahead",
              "allowedTypeIDs": [
                "simple barmerge_lookahead"
              ],
              "possibleValues": [
                "barmerge.lookahead_on",
                "barmerge.lookahead_off"
              ]
            },
            {
              "name": "ignore_invalid_symbol",
              "desc": "An optional parameter. Determines the behavior of the function if the specified symbol is not found: if false, the script will halt and return a runtime error; if true, the function will return na and execution will continue.  \nThe default value is false.",
              "default": "false",
              "required": false,
              "displayType": "input bool",
              "allowedTypeIDs": [
                "input bool",
                "const bool"
              ],
              "possibleValues": [
                "true",
                "false"
              ]
            },
            {
              "name": "currency",
              "desc": "Currency into which the symbol\\`s currency-related earnings values (e.g. [earnings.actual](#var_earnings.actual)) are to be converted.  \nThe conversion rates used are based on the FX_IDC pairs' daily rates of the previous day (relative to the bar where the calculation is done).  \nOptional. The default is [syminfo.currency](#var_syminfo.currency). \nPossible values: a three-letter string with the [currency code in the ISO 4217 format](https://en.wikipedia.org/wiki/ISO_4217#Active_codes) (e.g. \"USD\") or one of the constants in the currency.\\* namespace, e.g. [currency.USD](#var_currency.USD).",
              "default": "syminfo.currency",
              "required": false,
              "displayType": "simple string",
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "request.earnings(ticker, field, gaps, lookahead, ignore_invalid_symbol, currency) → series float",
          "returns": "Requested series, or n/a if there is no earnings data for the specified symbol.",
          "seeAlso": [
            "[request.dividends](#fun_request.dividends)",
            "[request.splits](#fun_request.splits)",
            "[request.security](#fun_request.security)",
            "[syminfo.tickerid](#var_syminfo.tickerid)"
          ],
          "examples": "//@version=5\nindicator(\"request.earnings\")\ns1 = request.earnings(\"NASDAQ:BELFA\")\nplot(s1)\ns2 = request.earnings(\"NASDAQ:BELFA\", earnings.actual, gaps=barmerge.gaps_on, lookahead=barmerge.lookahead_on)\nplot(s2)",
          "returnedType": "float",
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "request.dividends",
          "desc": "Requests dividends data for the specified symbol.",
          "args": [
            {
              "name": "ticker",
              "desc": "Symbol. Note that the symbol should be passed with a prefix. For example: \"NASDAQ:AAPL\" instead of \"AAPL\".  \nUsing [syminfo.ticker](#var_syminfo.ticker) will cause an error.  \nUse [syminfo.tickerid](#var_syminfo.tickerid) instead.",
              "default": null,
              "required": true,
              "displayType": "simple string",
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "field",
              "desc": "Input string. Possible values include: [dividends.net](#var_dividends.net), [dividends.gross](#var_dividends.gross).  \nDefault value is [dividends.gross](#var_dividends.gross).",
              "default": "dividends.gross",
              "required": false,
              "displayType": "simple string",
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "dividends.net",
                "dividends.gross"
              ]
            },
            {
              "name": "gaps",
              "desc": "Merge strategy for the requested data (requested data automatically merges with the main series OHLC data). \nPossible values: [barmerge.gaps_on](#var_barmerge.gaps_on), [barmerge.gaps_off](#var_barmerge.gaps_off). [barmerge.gaps_on](#var_barmerge.gaps_on) - requested data is merged with possible gaps ([na](#var_na) values). [barmerge.gaps_off](#var_barmerge.gaps_off) - requested data is merged continuously without gaps, all the gaps are filled with the previous nearest existing values.  \nDefault value is [barmerge.gaps_off](#var_barmerge.gaps_off).",
              "default": "barmerge.gaps_off",
              "required": true,
              "displayType": "simple barmerge_gaps",
              "allowedTypeIDs": [
                "simple barmerge_gaps"
              ],
              "possibleValues": [
                "barmerge.gaps_on",
                "barmerge.gaps_off"
              ]
            },
            {
              "name": "lookahead",
              "desc": "Merge strategy for the requested data position.  \nPossible values: [barmerge.lookahead_on](#var_barmerge.lookahead_on), [barmerge.lookahead_off](#var_barmerge.lookahead_off).  \nDefault value is [barmerge.lookahead_off](#var_barmerge.lookahead_off) starting from version 3.  \nNote that behavour is the same on real-time, and differs only on history.",
              "default": "barmerge.lookahead_off",
              "required": false,
              "displayType": "simple barmerge_lookahead",
              "allowedTypeIDs": [
                "simple barmerge_lookahead"
              ],
              "possibleValues": [
                "barmerge.lookahead_on",
                "barmerge.lookahead_off"
              ]
            },
            {
              "name": "ignore_invalid_symbol",
              "desc": "An optional parameter. Determines the behavior of the function if the specified symbol is not found: if false, the script will halt and return a runtime error; if true, the function will return na and execution will continue.  \nThe default value is false.",
              "default": "false",
              "required": false,
              "displayType": "input bool",
              "allowedTypeIDs": [
                "input bool",
                "const bool"
              ],
              "possibleValues": [
                "true",
                "false"
              ]
            },
            {
              "name": "currency",
              "desc": "Currency into which the symbol\\`s currency-related dividends values (e.g. [dividends.gross](#var_dividends.gross)) are to be converted.  \nThe conversion rates used are based on the FX_IDC pairs' daily rates of the previous day (relative to the bar where the calculation is done).  \nOptional. The default is [syminfo.currency](#var_syminfo.currency). \nPossible values: a three-letter string with the [currency code in the ISO 4217 format](https://en.wikipedia.org/wiki/ISO_4217#Active_codes) (e.g. \"USD\") or one of the constants in the currency.\\* namespace, e.g. [currency.USD](#var_currency.USD).",
              "default": "syminfo.currency",
              "required": false,
              "displayType": "simple string",
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "currency.USD",
                "currency.EUR",
                "currency.JPY",
                "currency.GBP",
                "currency.AUD"
              ]
            }
          ],
          "syntax": "request.dividends(ticker, field, gaps, lookahead, ignore_invalid_symbol, currency) → series float",
          "returns": "Requested series, or n/a if there is no dividends data for the specified symbol.",
          "seeAlso": [
            "[request.earnings](#fun_request.earnings)",
            "[request.splits](#fun_request.splits)",
            "[request.security](#fun_request.security)",
            "[syminfo.tickerid](#var_syminfo.tickerid)"
          ],
          "examples": "//@version=5\nindicator(\"request.dividends\")\ns1 = request.dividends(\"NASDAQ:BELFA\")\nplot(s1)\ns2 = request.dividends(\"NASDAQ:BELFA\", dividends.net, gaps=barmerge.gaps_on, lookahead=barmerge.lookahead_on)\nplot(s2)",
          "returnedType": "float",
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "request.splits",
          "desc": "Requests splits data for the specified symbol.",
          "args": [
            {
              "name": "ticker",
              "desc": "Symbol. Note that the symbol should be passed with a prefix. For example: \"NASDAQ:AAPL\" instead of \"AAPL\".  \nUsing [syminfo.ticker](#var_syminfo.ticker) will cause an error.  \nUse [syminfo.tickerid](#var_syminfo.tickerid) instead.",
              "default": null,
              "required": true,
              "displayType": "simple string",
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "field",
              "desc": "Input string. Possible values include: [splits.denominator](#var_splits.denominator), [splits.numerator](#var_splits.numerator).",
              "default": null,
              "required": true,
              "displayType": "simple string",
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "splits.denominator",
                "splits.numerator"
              ]
            },
            {
              "name": "gaps",
              "desc": "Merge strategy for the requested data (requested data automatically merges with the main series OHLC data). \nPossible values: [barmerge.gaps_on](#var_barmerge.gaps_on), [barmerge.gaps_off](#var_barmerge.gaps_off). [barmerge.gaps_on](#var_barmerge.gaps_on) - requested data is merged with possible gaps ([na](#var_na) values). [barmerge.gaps_off](#var_barmerge.gaps_off) - requested data is merged continuously without gaps, all the gaps are filled with the previous nearest existing values.  \nDefault value is [barmerge.gaps_off](#var_barmerge.gaps_off).",
              "default": "barmerge.gaps_off",
              "required": true,
              "displayType": "simple barmerge_gaps",
              "allowedTypeIDs": [
                "simple barmerge_gaps"
              ],
              "possibleValues": [
                "barmerge.gaps_on",
                "barmerge.gaps_off"
              ]
            },
            {
              "name": "lookahead",
              "desc": "Merge strategy for the requested data position.  \nPossible values: [barmerge.lookahead_on](#var_barmerge.lookahead_on), [barmerge.lookahead_off](#var_barmerge.lookahead_off).  \nDefault value is [barmerge.lookahead_off](#var_barmerge.lookahead_off) starting from version 3.  \nNote that behavour is the same on real-time, and differs only on history.",
              "default": "barmerge.lookahead_off",
              "required": true,
              "displayType": "simple barmerge_lookahead",
              "allowedTypeIDs": [
                "simple barmerge_lookahead"
              ],
              "possibleValues": [
                "barmerge.lookahead_on",
                "barmerge.lookahead_off"
              ]
            },
            {
              "name": "ignore_invalid_symbol",
              "desc": "An optional parameter. Determines the behavior of the function if the specified symbol is not found: if false, the script will halt and return a runtime error; if true, the function will return na and execution will continue.  \nThe default value is false.",
              "default": "false",
              "required": false,
              "displayType": "input bool",
              "allowedTypeIDs": [
                "input bool",
                "const bool"
              ],
              "possibleValues": [
                "true",
                "false"
              ]
            }
          ],
          "syntax": "request.splits(ticker, field, gaps, lookahead, ignore_invalid_symbol) → series float",
          "returns": "Requested series, or n/a if there is no splits data for the specified symbol.",
          "seeAlso": [
            "[request.earnings](#fun_request.earnings)",
            "[request.dividends](#fun_request.dividends)",
            "[request.security](#fun_request.security)",
            "[syminfo.tickerid](#var_syminfo.tickerid)"
          ],
          "examples": "//@version=5\nindicator(\"request.splits\")\ns1 = request.splits(\"NASDAQ:BELFA\", splits.denominator)\nplot(s1)\ns2 = request.splits(\"NASDAQ:BELFA\", splits.denominator, gaps=barmerge.gaps_on, lookahead=barmerge.lookahead_on)\nplot(s2)",
          "returnedType": "float",
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "request.economic",
          "desc": "Requests economic data for a symbol. Economic data includes information such as the state of a country\\`s economy (GDP, inflation rate, etc.) or of a particular industry (steel production, ICU beds, etc.).",
          "args": [
            {
              "name": "country_code",
              "desc": "The code of the country (e.g. \"US\") or the region (e.g. \"EU\") for which the economic data is requested.  \nThe [Help Center article](https://www.tradingview.com/chart/?solution=43000665359) lists the countries and their codes.  \nThe countries for which information is available vary with metrics.  \nThe [Help Center article for each metric](https://www.tradingview.com/support/folders/43000581956-list-of-available-economic-indicators/) lists the countries for which the metric is available.",
              "default": null,
              "required": true,
              "displayType": "simple string",
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "field",
              "desc": "The code of the requested economic metric (e.g., \"GDP\"). The [Help Center article](https://www.tradingview.com/chart/?solution=43000665359) lists the metrics and their codes.",
              "default": null,
              "required": true,
              "displayType": "simple string",
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "gaps",
              "desc": "Specifies how the returned values are merged on chart bars.  \nPossible values: [barmerge.gaps_off](#var_barmerge.gaps_off), [barmerge.gaps_on](#var_barmerge.gaps_on).  \nWith [barmerge.gaps_on](#var_barmerge.gaps_on), a value only appears on the current chart bar when it first becomes available from the function\\`s context, otherwise [na](#var_na) is returned (thus a \"gap\" occurs).  \nWith [barmerge.gaps_off](#var_barmerge.gaps_off), what would otherwise be gaps are filled with the latest known value returned, avoiding [na](#var_na) values.  \nOptional. The default is [barmerge.gaps_off](#var_barmerge.gaps_off).",
              "default": "barmerge.gaps_off",
              "required": false,
              "displayType": "simple barmerge_gaps",
              "allowedTypeIDs": [
                "simple barmerge_gaps"
              ],
              "possibleValues": [
                "barmerge.gaps_off",
                "barmerge.gaps_on"
              ]
            },
            {
              "name": "ignore_invalid_symbol",
              "desc": "Determines the behavior of the function if the specified symbol is not found: if [false](#op_false), the script will halt and return a runtime error; if [true](#op_true), the function will return [na](#var_na) and execution will continue.  \nOptional. The default is [false](#op_false).",
              "default": "false",
              "required": false,
              "displayType": "input bool",
              "allowedTypeIDs": [
                "input bool",
                "const bool"
              ],
              "possibleValues": [
                "true",
                "false"
              ]
            }
          ],
          "syntax": "request.economic(country_code, field, gaps, ignore_invalid_symbol) → series float",
          "remarks": "Economic data can also be accessed from charts, just like a regular symbol. Use \"ECONOMIC\" as the exchange name and `{country_code}{field}` as the ticker.  \nThe name of US GDP data is thus \"ECONOMIC:USGDP\".",
          "returns": "Requested series.",
          "seeAlso": [
            "[request.financial](#fun_request.financial)",
            "[request.quandl](#fun_request.quandl)"
          ],
          "examples": "//@version=5\nindicator(\"US GDP\")\ne = request.economic(\"US\", \"GDP\")\nplot(e)",
          "returnedType": "float",
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "request.seed",
          "desc": "Requests data from a user-maintained GitHub repository and returns it as a series.  \nAn in-depth tutorial on how to add new data can be found [here](https://github.com/tradingview-eod/pine-seeds-docs).",
          "args": [
            {
              "name": "source",
              "desc": "Name of the GitHub repository.",
              "default": null,
              "required": true,
              "displayType": "simple string",
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "symbol",
              "desc": "Name of the file in the GitHub repository containing the data. The \".csv\" file extension must not be included.",
              "default": null,
              "required": true,
              "displayType": "simple string",
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "expression",
              "desc": "An expression to be calculated and returned from the requested symbol\\`s context.  \nIt can be a built-in variable like [close](#var_close), an expression such as `ta.sma(close, 100)`, a non-mutable variable previously calculated in the script, a function call that does not use Pine Script™ drawings, an array, a matrix, or a tuple.  \nMutable variables are not allowed, unless they are enclosed in the body of a function used in the expression.",
              "default": null,
              "required": true,
              "displayType": "<type>",
              "allowedTypeIDs": [],
              "possibleValues": null
            }
          ],
          "syntax": "request.seed(source, symbol, expression)",
          "returns": "Requested series or tuple of series, which may include array/matrix IDs.",
          "examples": "//@version=5\nindicator(\"BTC Development Activity\")\n\n[devAct, devActSMA] = request.seed(\"seed_crypto_sentiment\", \"BTC_DEV_ACTIVITY\", [close, ta.sma(close, 10)])\n\nplot(devAct, \"BTC Development Activity\")\nplot(devActSMA, \"BTC Development Activity SMA10\", color = color.yellow)"
        },
        {
          "kind": "Built-in Function",
          "name": "table.new",
          "desc": "The function creates a new table.",
          "args": [
            {
              "name": "position",
              "desc": "Position of the table. Possible values are: [position.top_left](#var_position.top_left), [position.top_center](#var_position.top_center), [position.top_right](#var_position.top_right), [position.middle_left](#var_position.middle_left), [position.middle_center](#var_position.middle_center), [position.middle_right](#var_position.middle_right), [position.bottom_left](#var_position.bottom_left), [position.bottom_center](#var_position.bottom_center), [position.bottom_right](#var_position.bottom_right).",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "position.top_left",
                "position.top_center",
                "position.top_right",
                "position.middle_left",
                "position.middle_center",
                "position.middle_right",
                "position.bottom_left",
                "position.bottom_center",
                "position.bottom_right"
              ]
            },
            {
              "name": "columns",
              "desc": "The number of columns in the table.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "rows",
              "desc": "The number of rows in the table.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "bgcolor",
              "desc": "The background color of the table. Optional. The default is no color.",
              "default": "na",
              "required": false,
              "displayType": "series color",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "possibleValues": [
                "colors"
              ]
            },
            {
              "name": "frame_color",
              "desc": "The color of the outer frame of the table. Optional. The default is no color.",
              "default": "na",
              "required": false,
              "displayType": "series color",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "possibleValues": [
                "colors"
              ]
            },
            {
              "name": "frame_width",
              "desc": "The width of the outer frame of the table. Optional. The default is 0.",
              "default": "0",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            },
            {
              "name": "border_color",
              "desc": "The color of the borders of the cells (excluding the outer frame). Optional. The default is no color.",
              "default": "na",
              "required": false,
              "displayType": "series color",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "possibleValues": [
                "colors"
              ]
            },
            {
              "name": "border_width",
              "desc": "The width of the borders of the cells (excluding the outer frame). Optional. The default is 0.",
              "default": "0",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            }
          ],
          "syntax": "table.new(position, columns, rows, bgcolor, frame_color, frame_width, border_color, border_width) → series table",
          "remarks": "This function creates the table object itself, but the table will not be displayed until its cells are populated.  \nTo define a cell and change its contents or attributes, use [table.cell](#fun_table.cell) and other table.cell_*() functions.\nOne [table.new](#fun_table.new) call can only display one table (the last one drawn), but the function itself will be recalculated on each bar it is used on.  \nFor performance reasons, it is wise to use [table.new](#fun_table.new) in conjunction with either the [var](#op_var) keyword (so the table object is only created on the first bar) or in an [if](#op_if) [barstate.islast](#var_barstate.islast) block (so the table object is only created on the last bar).",
          "returns": "The ID of a table object that can be passed to other table.*() functions.",
          "seeAlso": [
            "[table.cell](#fun_table.cell)",
            "[table.clear](#fun_table.clear)",
            "[table.delete](#fun_table.delete)",
            "[table.set_bgcolor](#fun_table.set_bgcolor)",
            "[table.set_border_color](#fun_table.set_border_color)",
            "[table.set_border_width](#fun_table.set_border_width)",
            "[table.set_frame_color](#fun_table.set_frame_color)",
            "[table.set_frame_width](#fun_table.set_frame_width)",
            "[table.set_position](#fun_table.set_position)"
          ],
          "examples": "//@version=5\nindicator(\"table.new example\")\nvar testTable = table.new(position = position.top_right, columns = 2, rows = 1, bgcolor = color.yellow, border_width = 1)\nif barstate.islast\n    table.cell(table_id = testTable, column = 0, row = 0, text = \"Open is \" + str.tostring(open))\n    table.cell(table_id = testTable, column = 1, row = 0, text = \"Close is \" + str.tostring(close), bgcolor=color.teal)",
          "returnedType": "table",
          "returnedTypes": [
            "series table"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "table.delete",
          "desc": "The function deletes a table.",
          "args": [
            {
              "name": "table_id",
              "desc": "A table object.",
              "default": null,
              "required": true,
              "displayType": "series table",
              "allowedTypeIDs": [
                "series table"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "table.delete(table_id) → void",
          "seeAlso": [
            "[table.new](#fun_table.new)",
            "[table.clear](#fun_table.clear)"
          ],
          "examples": "//@version=5\nindicator(\"table.delete example\")\nvar testTable = table.new(position = position.top_right, columns = 2, rows = 1, bgcolor = color.yellow, border_width = 1)\nif barstate.islast\n    table.cell(table_id = testTable, column = 0, row = 0, text = \"Open is \" + str.tostring(open))\n    table.cell(table_id = testTable, column = 1, row = 0, text = \"Close is \" + str.tostring(close), bgcolor=color.teal)\nif barstate.isrealtime\n    table.delete(testTable)",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "table.set_position",
          "desc": "The function sets the position of a table.",
          "args": [
            {
              "name": "table_id",
              "desc": "A table object.",
              "default": null,
              "required": true,
              "displayType": "series table",
              "allowedTypeIDs": [
                "series table"
              ],
              "possibleValues": null
            },
            {
              "name": "position",
              "desc": "Position of the table. Possible values are: [position.top_left](#var_position.top_left), [position.top_center](#var_position.top_center), [position.top_right](#var_position.top_right), [position.middle_left](#var_position.middle_left), [position.middle_center](#var_position.middle_center), [position.middle_right](#var_position.middle_right), [position.bottom_left](#var_position.bottom_left), [position.bottom_center](#var_position.bottom_center), [position.bottom_right](#var_position.bottom_right).",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "position.top_left",
                "position.top_center",
                "position.top_right",
                "position.middle_left",
                "position.middle_center",
                "position.middle_right",
                "position.bottom_left",
                "position.bottom_center",
                "position.bottom_right"
              ]
            }
          ],
          "syntax": "table.set_position(table_id, position) → void",
          "seeAlso": [
            "[table.clear](#fun_table.clear)",
            "[table.delete](#fun_table.delete)",
            "[table.new](#fun_table.new)",
            "[table.set_bgcolor](#fun_table.set_bgcolor)",
            "[table.set_border_color](#fun_table.set_border_color)",
            "[table.set_border_width](#fun_table.set_border_width)",
            "[table.set_frame_color](#fun_table.set_frame_color)",
            "[table.set_frame_width](#fun_table.set_frame_width)"
          ],
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "table.set_bgcolor",
          "desc": "The function sets the background color of a table.",
          "args": [
            {
              "name": "table_id",
              "desc": "A table object.",
              "default": null,
              "required": true,
              "displayType": "series table",
              "allowedTypeIDs": [
                "series table"
              ],
              "possibleValues": null
            },
            {
              "name": "bgcolor",
              "desc": "The background color of the table. Optional. The default is no color.",
              "default": "color(na)",
              "required": false,
              "displayType": "series color",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "possibleValues": [
                "colors"
              ]
            }
          ],
          "syntax": "table.set_bgcolor(table_id, bgcolor) → void",
          "seeAlso": [
            "[table.clear](#fun_table.clear)",
            "[table.delete](#fun_table.delete)",
            "[table.new](#fun_table.new)",
            "[table.set_border_color](#fun_table.set_border_color)",
            "[table.set_border_width](#fun_table.set_border_width)",
            "[table.set_frame_color](#fun_table.set_frame_color)",
            "[table.set_frame_width](#fun_table.set_frame_width)",
            "[table.set_position](#fun_table.set_position)"
          ],
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "table.set_frame_color",
          "desc": "The function sets the color of the outer frame of a table.",
          "args": [
            {
              "name": "table_id",
              "desc": "A table object.",
              "default": null,
              "required": true,
              "displayType": "series table",
              "allowedTypeIDs": [
                "series table"
              ],
              "possibleValues": null
            },
            {
              "name": "frame_color",
              "desc": "The color of the frame of the table. Optional. The default is no color.",
              "default": "color(na)",
              "required": false,
              "displayType": "series color",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "possibleValues": [
                "colors"
              ]
            }
          ],
          "syntax": "table.set_frame_color(table_id, frame_color) → void",
          "seeAlso": [
            "[table.clear](#fun_table.clear)",
            "[table.delete](#fun_table.delete)",
            "[table.new](#fun_table.new)",
            "[table.set_border_color](#fun_table.set_border_color)",
            "[table.set_border_width](#fun_table.set_border_width)",
            "[table.set_bgcolor](#fun_table.set_bgcolor)",
            "[table.set_frame_width](#fun_table.set_frame_width)",
            "[table.set_position](#fun_table.set_position)"
          ],
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "table.set_border_color",
          "desc": "The function sets the color of the borders (excluding the outer frame) of the table\\`s cells.",
          "args": [
            {
              "name": "table_id",
              "desc": "A table object.",
              "default": null,
              "required": true,
              "displayType": "series table",
              "allowedTypeIDs": [
                "series table"
              ],
              "possibleValues": null
            },
            {
              "name": "border_color",
              "desc": "The color of the borders. Optional. The default is no color.",
              "default": "color(na)",
              "required": false,
              "displayType": "series color",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "possibleValues": [
                "colors"
              ]
            }
          ],
          "syntax": "table.set_border_color(table_id, border_color) → void",
          "seeAlso": [
            "[table.clear](#fun_table.clear)",
            "[table.delete](#fun_table.delete)",
            "[table.new](#fun_table.new)",
            "[table.set_frame_color](#fun_table.set_frame_color)",
            "[table.set_border_width](#fun_table.set_border_width)",
            "[table.set_bgcolor](#fun_table.set_bgcolor)",
            "[table.set_frame_width](#fun_table.set_frame_width)",
            "[table.set_position](#fun_table.set_position)"
          ],
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "table.set_frame_width",
          "desc": "The function set the width of the outer frame of a table.",
          "args": [
            {
              "name": "table_id",
              "desc": "A table object.",
              "default": null,
              "required": true,
              "displayType": "series table",
              "allowedTypeIDs": [
                "series table"
              ],
              "possibleValues": null
            },
            {
              "name": "frame_width",
              "desc": "The width of the outer frame of the table. Optional. The default is 0.",
              "default": "0",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            }
          ],
          "syntax": "table.set_frame_width(table_id, frame_width) → void",
          "seeAlso": [
            "[table.clear](#fun_table.clear)",
            "[table.delete](#fun_table.delete)",
            "[table.new](#fun_table.new)",
            "[table.set_frame_color](#fun_table.set_frame_color)",
            "[table.set_border_width](#fun_table.set_border_width)",
            "[table.set_bgcolor](#fun_table.set_bgcolor)",
            "[table.set_border_color](#fun_table.set_border_color)",
            "[table.set_position](#fun_table.set_position)"
          ],
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "table.set_border_width",
          "desc": "The function sets the width of the borders (excluding the outer frame) of the table\\`s cells.",
          "args": [
            {
              "name": "table_id",
              "desc": "A table object.",
              "default": null,
              "required": true,
              "displayType": "series table",
              "allowedTypeIDs": [
                "series table"
              ],
              "possibleValues": null
            },
            {
              "name": "border_width",
              "desc": "The width of the borders. Optional. The default is 0.",
              "default": "0",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            }
          ],
          "syntax": "table.set_border_width(table_id, border_width) → void",
          "seeAlso": [
            "[table.clear](#fun_table.clear)",
            "[table.delete](#fun_table.delete)",
            "[table.new](#fun_table.new)",
            "[table.set_frame_color](#fun_table.set_frame_color)",
            "[table.set_frame_width](#fun_table.set_frame_width)",
            "[table.set_bgcolor](#fun_table.set_bgcolor)",
            "[table.set_border_color](#fun_table.set_border_color)",
            "[table.set_position](#fun_table.set_position)"
          ],
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "table.cell",
          "desc": "The function defines a cell in the table and sets its attributes.",
          "args": [
            {
              "name": "table_id",
              "desc": "A table object.",
              "default": null,
              "required": true,
              "displayType": "series table",
              "allowedTypeIDs": [
                "series table"
              ],
              "possibleValues": null
            },
            {
              "name": "column",
              "desc": "The index of the cell\\`s column. Numbering starts at 0.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            },
            {
              "name": "row",
              "desc": "The index of the cell\\`s row. Numbering starts at 0.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            },
            {
              "name": "text",
              "desc": "The text to be displayed inside the cell. Optional. The default is empty string.",
              "default": "\"\"",
              "required": false,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "text_font_family",
              "desc": "The font family of the text. Optional. The default value is [font.family_default](#var_font.family_default). \nPossible values: [font.family_default](#var_font.family_default), [font.family_monospace](#var_font.family_monospace).",
              "default": "font.family_default",
              "required": false,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "font.family_default",
                "font.family_monospace"
              ]
            },
            {
              "name": "width",
              "desc": "The width of the cell as a % of the indicator\\`s visual space. Optional. By default, auto-adjusts the width based on the text inside the cell.  \nValue 0 has the same effect.",
              "default": "0",
              "required": false,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            },
            {
              "name": "height",
              "desc": "The height of the cell as a % of the indicator\\`s visual space. Optional. By default, auto-adjusts the height based on the text inside of the cell.  \nValue 0 has the same effect.",
              "default": "0",
              "required": false,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                0,
                10,
                20,
                30,
                40
              ]
            },
            {
              "name": "text_color",
              "desc": "The color of the text. Optional. The default is [color.black](#var_color.black).",
              "default": "color.black",
              "required": false,
              "displayType": "series color",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "possibleValues": [
                "colors"
              ]
            },
            {
              "name": "text_halign",
              "desc": "The horizontal alignment of the cell\\`s text. Optional. The default value is [text.align_center](#var_text.align_center). \nPossible values: [text.align_left](#var_text.align_left), [text.align_center](#var_text.align_center), [text.align_right](#var_text.align_right).",
              "default": "text.align_center",
              "required": false,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "text.align_left",
                "text.align_center",
                "text.align_right"
              ]
            },
            {
              "name": "text_valign",
              "desc": "The vertical alignment of the cell\\`s text. Optional. The default value is [text.align_center](#var_text.align_center). \nPossible values: [text.align_top](#var_text.align_top), [text.align_center](#var_text.align_center), [text.align_bottom](#var_text.align_bottom).",
              "default": "text.align_center",
              "required": false,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "text.align_top",
                "text.align_center",
                "text.align_bottom"
              ]
            },
            {
              "name": "text_size",
              "desc": "The size of the text. An optional parameter, the default value is [size.normal](#var_size.normal). \nPossible values: [size.auto](#var_size.auto), [size.tiny](#var_size.tiny), [size.small](#var_size.small), [size.normal](#var_size.normal), [size.large](#var_size.large), [size.huge](#var_size.huge).",
              "default": "size.normal",
              "required": false,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "size.auto",
                "size.tiny",
                "size.small",
                "size.normal",
                "size.large",
                "size.huge"
              ]
            },
            {
              "name": "bgcolor",
              "desc": "The background color of the text.",
              "default": null,
              "required": false,
              "displayType": "series color",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "possibleValues": [
                "colors"
              ]
            },
            {
              "name": "tooltip",
              "desc": "The tooltip to be displayed inside the cell. Optional.",
              "default": null,
              "required": false,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "table.cell(table_id, column, row, text, width, height, text_color, text_halign, text_valign, text_size, bgcolor, tooltip, text_font_family) → void",
          "remarks": "This function does not create the table itself, but defines the table’s cells. To use it, you first need to create a table object with [table.new](#fun_table.new).\nEach [table.cell](#fun_table.cell) call overwrites all previously defined properties of a cell.  \nIf you call [table.cell](#fun_table.cell) twice in a row, e.g., the first time with text='Test Text', and the second time with text_color=[color.red](#var_color.red) but without a new text argument, the default value of the 'text' being an empty string, it will overwrite 'Test Text', and your cell will display an empty string.  \nIf you want, instead, to modify any of the cell\\`s properties, use the table.cell_set_*() functions.\nA single script can only display one table in each of the possible locations.  \nIf [table.cell](#fun_table.cell) is used on several bars to change the same attribute of a cell (e.g.  \nchange the background color of the cell to red on the first bar, then to yellow on the second bar), only the last change will be reflected in the table, i.e., the cell’s background will be yellow.  \nAvoid unnecessary setting of cell properties by enclosing function calls in an [if](#op_if) [barstate.islast](#var_barstate.islast) block whenever possible, to restrict their execution to the last bar of the series.",
          "seeAlso": [
            "[table.cell_set_bgcolor](#fun_table.cell_set_bgcolor)",
            "[table.cell_set_height](#fun_table.cell_set_height)",
            "[table.cell_set_text](#fun_table.cell_set_text)",
            "[table.cell_set_text_color](#fun_table.cell_set_text_color)",
            "[table.cell_set_text_halign](#fun_table.cell_set_text_halign)",
            "[table.cell_set_text_size](#fun_table.cell_set_text_size)",
            "[table.cell_set_text_valign](#fun_table.cell_set_text_valign)",
            "[table.cell_set_width](#fun_table.cell_set_width)",
            "[table.cell_set_tooltip](#fun_table.cell_set_tooltip)"
          ],
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "table.cell_set_text",
          "desc": "The function sets the text in the specified cell.",
          "args": [
            {
              "name": "table_id",
              "desc": "A table object.",
              "default": null,
              "required": true,
              "displayType": "series table",
              "allowedTypeIDs": [
                "series table"
              ],
              "possibleValues": null
            },
            {
              "name": "column",
              "desc": "The index of the cell\\`s column. Numbering starts at 0.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            },
            {
              "name": "row",
              "desc": "The index of the cell\\`s row. Numbering starts at 0.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            },
            {
              "name": "text",
              "desc": "The text to be displayed inside the cell.",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "table.cell_set_text(table_id, column, row, text) → void",
          "seeAlso": [
            "[table.cell_set_bgcolor](#fun_table.cell_set_bgcolor)",
            "[table.cell_set_height](#fun_table.cell_set_height)",
            "[table.cell_set_text_color](#fun_table.cell_set_text_color)",
            "[table.cell_set_text_halign](#fun_table.cell_set_text_halign)",
            "[table.cell_set_text_size](#fun_table.cell_set_text_size)",
            "[table.cell_set_text_valign](#fun_table.cell_set_text_valign)",
            "[table.cell_set_width](#fun_table.cell_set_width)",
            "[table.cell_set_tooltip](#fun_table.cell_set_tooltip)"
          ],
          "examples": "//@version=5\nindicator(\"TABLE example\")\nvar tLog = table.new(position = position.top_left, rows = 1, columns = 2, bgcolor = color.yellow, border_width=1)\ntable.cell(tLog, row = 0, column = 0, text = \"sometext\", text_color = color.blue)\ntable.cell_set_text(tLog, row = 0, column = 0, text = \"sometext\")",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "table.cell_set_text_font_family",
          "desc": "The function sets the font family of the text inside the cell.",
          "args": [
            {
              "name": "table_id",
              "desc": "A table object.",
              "default": null,
              "required": true,
              "displayType": "series table",
              "allowedTypeIDs": [
                "series table"
              ],
              "possibleValues": null
            },
            {
              "name": "column",
              "desc": "The index of the cell\\`s column. Numbering starts at 0.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            },
            {
              "name": "row",
              "desc": "The index of the cell\\`s row. Numbering starts at 0.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            },
            {
              "name": "text_font_family",
              "desc": "The font family of the text.  \nPossible values: [font.family_default](#var_font.family_default), [font.family_monospace](#var_font.family_monospace).",
              "default": "font.family_default",
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "font.family_default",
                "font.family_monospace"
              ]
            }
          ],
          "syntax": "table.cell_set_text_font_family(table_id, column, row, text_font_family) → void",
          "seeAlso": [
            "[table.new](#fun_table.new)",
            "[font.family_default](#const_font.family_default)",
            "[font.family_monospace](#const_font.family_monospace)"
          ],
          "examples": "//@version=5\nindicator(\"Example of setting the table cell font\")\nvar t = table.new(position.top_left, rows = 1, columns = 1)\ntable.cell(t, 0, 0, \"monospace\", text_color = color.blue)\ntable.cell_set_text_font_family(t, 0, 0, font.family_monospace)",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "table.cell_set_tooltip",
          "desc": "The function sets the tooltip in the specified cell.",
          "args": [
            {
              "name": "table_id",
              "desc": "A table object.",
              "default": null,
              "required": true,
              "displayType": "series table",
              "allowedTypeIDs": [
                "series table"
              ],
              "possibleValues": null
            },
            {
              "name": "column",
              "desc": "The index of the cell\\`s column. Numbering starts at 0.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            },
            {
              "name": "row",
              "desc": "The index of the cell\\`s row. Numbering starts at 0.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            },
            {
              "name": "tooltip",
              "desc": "The tooltip to be displayed inside the cell.",
              "default": null,
              "required": false,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "table.cell_set_tooltip(table_id, column, row, tooltip) → void",
          "seeAlso": [
            "[table.cell_set_bgcolor](#fun_table.cell_set_bgcolor)",
            "[table.cell_set_height](#fun_table.cell_set_height)",
            "[table.cell_set_text_color](#fun_table.cell_set_text_color)",
            "[table.cell_set_text_halign](#fun_table.cell_set_text_halign)",
            "[table.cell_set_text_size](#fun_table.cell_set_text_size)",
            "[table.cell_set_text_valign](#fun_table.cell_set_text_valign)",
            "[table.cell_set_width](#fun_table.cell_set_width)",
            "[table.cell_set_text](#fun_table.cell_set_text)"
          ],
          "examples": "//@version=5\nindicator(\"TABLE example\")\nvar tLog = table.new(position = position.top_left, rows = 1, columns = 2, bgcolor = color.yellow, border_width=1)\ntable.cell(tLog, row = 0, column = 0, text = \"sometext\", text_color = color.blue)\ntable.cell_set_tooltip(tLog, row = 0, column = 0, tooltip = \"sometext\")",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "table.cell_set_width",
          "desc": "The function sets the width of the cell.",
          "args": [
            {
              "name": "table_id",
              "desc": "A table object.",
              "default": null,
              "required": true,
              "displayType": "series table",
              "allowedTypeIDs": [
                "series table"
              ],
              "possibleValues": null
            },
            {
              "name": "column",
              "desc": "The index of the cell\\`s column. Numbering starts at 0.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            },
            {
              "name": "row",
              "desc": "The index of the cell\\`s row. Numbering starts at 0.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            },
            {
              "name": "width",
              "desc": "The width of the cell as a % of the chart window. Passing 0 auto-adjusts the width based on the text inside of the cell.",
              "default": null,
              "required": false,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            }
          ],
          "syntax": "table.cell_set_width(table_id, column, row, width) → void",
          "seeAlso": [
            "[table.cell_set_bgcolor](#fun_table.cell_set_bgcolor)",
            "[table.cell_set_height](#fun_table.cell_set_height)",
            "[table.cell_set_text](#fun_table.cell_set_text)",
            "[table.cell_set_text_color](#fun_table.cell_set_text_color)",
            "[table.cell_set_text_halign](#fun_table.cell_set_text_halign)",
            "[table.cell_set_text_size](#fun_table.cell_set_text_size)",
            "[table.cell_set_text_valign](#fun_table.cell_set_text_valign)",
            "[table.cell_set_tooltip](#fun_table.cell_set_tooltip)"
          ],
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "table.cell_set_height",
          "desc": "The function sets the height of cell.",
          "args": [
            {
              "name": "table_id",
              "desc": "A table object.",
              "default": null,
              "required": true,
              "displayType": "series table",
              "allowedTypeIDs": [
                "series table"
              ],
              "possibleValues": null
            },
            {
              "name": "column",
              "desc": "The index of the cell\\`s column. Numbering starts at 0.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            },
            {
              "name": "row",
              "desc": "The index of the cell\\`s row. Numbering starts at 0.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            },
            {
              "name": "height",
              "desc": "The height of the cell as a % of the chart window. Passing 0 auto-adjusts the height based on the text inside of the cell.",
              "default": null,
              "required": false,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                0,
                25,
                50,
                75,
                100
              ]
            }
          ],
          "syntax": "table.cell_set_height(table_id, column, row, height) → void",
          "seeAlso": [
            "[table.cell_set_bgcolor](#fun_table.cell_set_bgcolor)",
            "[table.cell_set_text](#fun_table.cell_set_text)",
            "[table.cell_set_text_color](#fun_table.cell_set_text_color)",
            "[table.cell_set_text_halign](#fun_table.cell_set_text_halign)",
            "[table.cell_set_text_size](#fun_table.cell_set_text_size)",
            "[table.cell_set_text_valign](#fun_table.cell_set_text_valign)",
            "[table.cell_set_width](#fun_table.cell_set_width)",
            "[table.cell_set_tooltip](#fun_table.cell_set_tooltip)"
          ],
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "table.cell_set_text_color",
          "desc": "The function sets the color of the text inside the cell.",
          "args": [
            {
              "name": "table_id",
              "desc": "A table object.",
              "default": null,
              "required": true,
              "displayType": "series table",
              "allowedTypeIDs": [
                "series table"
              ],
              "possibleValues": null
            },
            {
              "name": "column",
              "desc": "The index of the cell\\`s column. Numbering starts at 0.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            },
            {
              "name": "row",
              "desc": "The index of the cell\\`s row. Numbering starts at 0.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            },
            {
              "name": "text_color",
              "desc": "The color of the text.",
              "default": null,
              "required": true,
              "displayType": "series color",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "possibleValues": [
                "colors"
              ]
            }
          ],
          "syntax": "table.cell_set_text_color(table_id, column, row, text_color) → void",
          "seeAlso": [
            "[table.cell_set_bgcolor](#fun_table.cell_set_bgcolor)",
            "[table.cell_set_height](#fun_table.cell_set_height)",
            "[table.cell_set_text](#fun_table.cell_set_text)",
            "[table.cell_set_text_halign](#fun_table.cell_set_text_halign)",
            "[table.cell_set_text_size](#fun_table.cell_set_text_size)",
            "[table.cell_set_text_valign](#fun_table.cell_set_text_valign)",
            "[table.cell_set_width](#fun_table.cell_set_width)",
            "[table.cell_set_tooltip](#fun_table.cell_set_tooltip)"
          ],
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "table.cell_set_text_halign",
          "desc": "The function sets the horizontal alignment of the cell\\`s text.",
          "args": [
            {
              "name": "table_id",
              "desc": "A table object.",
              "default": null,
              "required": true,
              "displayType": "series table",
              "allowedTypeIDs": [
                "series table"
              ],
              "possibleValues": null
            },
            {
              "name": "column",
              "desc": "The index of the cell\\`s column. Numbering starts at 0.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            },
            {
              "name": "row",
              "desc": "The index of the cell\\`s row. Numbering starts at 0.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            },
            {
              "name": "text_halign",
              "desc": "The horizontal alignment of a cell\\`s text.  \nPossible values: [text.align_left](#var_text.align_left), [text.align_center](#var_text.align_center), [text.align_right](#var_text.align_right).",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "text.align_left",
                "text.align_center",
                "text.align_right"
              ]
            }
          ],
          "syntax": "table.cell_set_text_halign(table_id, column, row, text_halign) → void",
          "seeAlso": [
            "[table.cell_set_bgcolor](#fun_table.cell_set_bgcolor)",
            "[table.cell_set_height](#fun_table.cell_set_height)",
            "[table.cell_set_text](#fun_table.cell_set_text)",
            "[table.cell_set_text_color](#fun_table.cell_set_text_color)",
            "[table.cell_set_text_size](#fun_table.cell_set_text_size)",
            "[table.cell_set_text_valign](#fun_table.cell_set_text_valign)",
            "[table.cell_set_width](#fun_table.cell_set_width)",
            "[table.cell_set_tooltip](#fun_table.cell_set_tooltip)"
          ],
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "table.cell_set_text_valign",
          "desc": "The function sets the vertical alignment of a cell\\`s text.",
          "args": [
            {
              "name": "table_id",
              "desc": "A table object.",
              "default": null,
              "required": true,
              "displayType": "series table",
              "allowedTypeIDs": [
                "series table"
              ],
              "possibleValues": null
            },
            {
              "name": "column",
              "desc": "The index of the cell\\`s column. Numbering starts at 0.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            },
            {
              "name": "row",
              "desc": "The index of the cell\\`s row. Numbering starts at 0.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            },
            {
              "name": "text_valign",
              "desc": "The vertical alignment of the cell\\`s text.  \nPossible values: [text.align_top](#var_text.align_top), [text.align_center](#var_text.align_center), [text.align_bottom](#var_text.align_bottom).",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "text.align_top",
                "text.align_center",
                "text.align_bottom"
              ]
            }
          ],
          "syntax": "table.cell_set_text_valign(table_id, column, row, text_valign) → void",
          "seeAlso": [
            "[table.cell_set_bgcolor](#fun_table.cell_set_bgcolor)",
            "[table.cell_set_height](#fun_table.cell_set_height)",
            "[table.cell_set_text](#fun_table.cell_set_text)",
            "[table.cell_set_text_color](#fun_table.cell_set_text_color)",
            "[table.cell_set_text_halign](#fun_table.cell_set_text_halign)",
            "[table.cell_set_text_size](#fun_table.cell_set_text_size)",
            "[table.cell_set_width](#fun_table.cell_set_width)",
            "[table.cell_set_tooltip](#fun_table.cell_set_tooltip)"
          ],
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "table.cell_set_text_size",
          "desc": "The function sets the size of the cell\\`s text.",
          "args": [
            {
              "name": "table_id",
              "desc": "A table object.",
              "default": null,
              "required": true,
              "displayType": "series table",
              "allowedTypeIDs": [
                "series table"
              ],
              "possibleValues": null
            },
            {
              "name": "column",
              "desc": "The index of the cell\\`s column. Numbering starts at 0.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            },
            {
              "name": "row",
              "desc": "The index of the cell\\`s row. Numbering starts at 0.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            },
            {
              "name": "text_size",
              "desc": "The size of the text.  \nPossible values: [size.auto](#var_size.auto), [size.tiny](#var_size.tiny), [size.small](#var_size.small), [size.normal](#var_size.normal), [size.large](#var_size.large), [size.huge](#var_size.huge).",
              "default": null,
              "required": false,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "size.auto",
                "size.tiny",
                "size.small",
                "size.normal",
                "size.large",
                "size.huge"
              ]
            }
          ],
          "syntax": "table.cell_set_text_size(table_id, column, row, text_size) → void",
          "seeAlso": [
            "[table.cell_set_bgcolor](#fun_table.cell_set_bgcolor)",
            "[table.cell_set_height](#fun_table.cell_set_height)",
            "[table.cell_set_text](#fun_table.cell_set_text)",
            "[table.cell_set_text_color](#fun_table.cell_set_text_color)",
            "[table.cell_set_text_halign](#fun_table.cell_set_text_halign)",
            "[table.cell_set_text_valign](#fun_table.cell_set_text_valign)",
            "[table.cell_set_width](#fun_table.cell_set_width)",
            "[table.cell_set_tooltip](#fun_table.cell_set_tooltip)"
          ],
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "table.cell_set_bgcolor",
          "desc": "The function sets the background color of the cell.",
          "args": [
            {
              "name": "table_id",
              "desc": "A table object.",
              "default": null,
              "required": true,
              "displayType": "series table",
              "allowedTypeIDs": [
                "series table"
              ],
              "possibleValues": null
            },
            {
              "name": "column",
              "desc": "The index of the cell\\`s column. Numbering starts at 0.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            },
            {
              "name": "row",
              "desc": "The index of the cell\\`s row. Numbering starts at 0.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            },
            {
              "name": "bgcolor",
              "desc": "The background color of the cell.",
              "default": null,
              "required": false,
              "displayType": "series color",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "possibleValues": [
                "colors"
              ]
            }
          ],
          "syntax": "table.cell_set_bgcolor(table_id, column, row, bgcolor) → void",
          "seeAlso": [
            "[table.cell_set_height](#fun_table.cell_set_height)",
            "[table.cell_set_text](#fun_table.cell_set_text)",
            "[table.cell_set_text_color](#fun_table.cell_set_text_color)",
            "[table.cell_set_text_halign](#fun_table.cell_set_text_halign)",
            "[table.cell_set_text_size](#fun_table.cell_set_text_size)",
            "[table.cell_set_text_valign](#fun_table.cell_set_text_valign)",
            "[table.cell_set_width](#fun_table.cell_set_width)",
            "[table.cell_set_tooltip](#fun_table.cell_set_tooltip)"
          ],
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "table.clear",
          "desc": "The function removes a cell or a sequence of cells from the table. The cells are removed in a rectangle shape where the start_column and start_row specify the top-left corner, and end_column and end_row specify the bottom-right corner.",
          "args": [
            {
              "name": "table_id",
              "desc": "A table object.",
              "default": null,
              "required": true,
              "displayType": "series table",
              "allowedTypeIDs": [
                "series table"
              ],
              "possibleValues": null
            },
            {
              "name": "start_column",
              "desc": "The index of the column of the first cell to delete. Numbering starts at 0.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "start_row",
              "desc": "The index of the row of the first cell to delete. Numbering starts at 0.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "end_column",
              "desc": "The index of the column of the last cell to delete. Optional. The default is the argument used for start_column.  \nNumbering starts at 0.",
              "default": "'start_column'",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "end_row",
              "desc": "The index of the row of the last cell to delete. Optional. The default is the argument used for start_row.  \nNumbering starts at 0.",
              "default": "'start_row'",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "table.clear(table_id, start_column, start_row, end_column, end_row) → void",
          "seeAlso": [
            "[table.delete](#fun_table.delete)",
            "[table.new](#fun_table.new)"
          ],
          "examples": "//@version=5\nindicator(\"A donut\", overlay=true)\nif barstate.islast\n    colNum = 8, rowNum = 8\n    padding = \"◯\"\n    donutTable = table.new(position.middle_right, colNum, rowNum)\n    for c = 0 to colNum - 1\n        for r = 0 to rowNum - 1\n            table.cell(donutTable, c, r, text=padding, bgcolor=#face6e, text_color=color.new(color.black, 100))\n    table.clear(donutTable, 2, 2, 5, 5)",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "matrix.new<int>",
          "desc": "Create matrix from random values",
          "args": [
            {
              "name": "rows",
              "desc": "Initial row count of the matrix. Optional. The default value is 0.",
              "default": "0",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "columns",
              "desc": "Initial column count of the matrix. Optional. The default value is 0.",
              "default": "0",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "initial_value",
              "desc": "Initial value of all matrix elements. Optional. The default is 'na'.",
              "default": "na",
              "required": false,
              "displayType": "matrix<type>",
              "allowedTypeIDs": [],
              "possibleValues": null
            }
          ],
          "syntax": "matrix.new<int>(rows, columns, initial_value) → matrix<int>",
          "returns": "The ID of the new matrix object.",
          "seeAlso": [
            "[matrix.set](#fun_matrix.set)",
            "[matrix.fill](#fun_matrix.fill)",
            "[matrix.columns](#fun_matrix.columns)",
            "[matrix.rows](#fun_matrix.rows)",
            "[array.new<type>](#fun_array.new<type>)"
          ],
          "examples": "//@version=5\nindicator('`matrix.new<int>()` Example')\n// Function to create a matrix with random values (0.0 to 1.0).\nmatrixRandom(int rows, int columns)=>\n    result = matrix.new<float>(rows, columns)\n    for i = 0 to rows - 1\n        for j = 0 to columns - 1\n            matrix.set(result, i, j, math.random())\n    result\n// Create a 2x3 matrix with random values.\nvar m = matrixRandom(2, 3)\n// Display using a label.\nif barstate.islastconfirmedhistory\n    label.new(bar_index, high, str.tostring(m))"
        },
        {
          "kind": "Built-in Function",
          "name": "matrix.new<float>",
          "desc": "Create matrix from random values",
          "args": [
            {
              "name": "rows",
              "desc": "Initial row count of the matrix. Optional. The default value is 0.",
              "default": "0",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "columns",
              "desc": "Initial column count of the matrix. Optional. The default value is 0.",
              "default": "0",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "initial_value",
              "desc": "Initial value of all matrix elements. Optional. The default is 'na'.",
              "default": "na",
              "required": false,
              "displayType": "matrix<type>",
              "allowedTypeIDs": [],
              "possibleValues": null
            }
          ],
          "syntax": "matrix.new<float>(rows, columns, initial_value) → matrix<float>",
          "returns": "The ID of the new matrix object.",
          "seeAlso": [
            "[matrix.set](#fun_matrix.set)",
            "[matrix.fill](#fun_matrix.fill)",
            "[matrix.columns](#fun_matrix.columns)",
            "[matrix.rows](#fun_matrix.rows)",
            "[array.new<type>](#fun_array.new<type>)"
          ],
          "examples": "//@version=5\nindicator('`matrix.new<float>()` Example')\n// Function to create a matrix with random values (0.0 to 1.0).\nmatrixRandom(int rows, int columns)=>\n    result = matrix.new<float>(rows, columns)\n    for i = 0 to rows - 1\n        for j = 0 to columns - 1\n            matrix.set(result, i, j, math.random())\n    result\n// Create a 2x3 matrix with random values.\nvar m = matrixRandom(2, 3)\n// Display using a label.\nif barstate.islastconfirmedhistory\n    label.new(bar_index, high, str.tostring(m))"
        },
        {
          "kind": "Built-in Function",
          "name": "matrix.new<bool>",
          "desc": "Create matrix from random values",
          "args": [
            {
              "name": "rows",
              "desc": "Initial row count of the matrix. Optional. The default value is 0.",
              "default": "0",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "columns",
              "desc": "Initial column count of the matrix. Optional. The default value is 0.",
              "default": "0",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "initial_value",
              "desc": "Initial value of all matrix elements. Optional. The default is 'na'.",
              "default": "na",
              "required": false,
              "displayType": "matrix<type>",
              "allowedTypeIDs": [],
              "possibleValues": [
                "true",
                "false"
              ]
            }
          ],
          "syntax": "matrix.new<bool>(rows, columns, initial_value) → matrix<bool>",
          "returns": "The ID of the new matrix object.",
          "seeAlso": [
            "[matrix.set](#fun_matrix.set)",
            "[matrix.fill](#fun_matrix.fill)",
            "[matrix.columns](#fun_matrix.columns)",
            "[matrix.rows](#fun_matrix.rows)",
            "[array.new<type>](#fun_array.new<type>)"
          ],
          "examples": "//@version=5\nindicator('`matrix.new<bool>()` Example')\n// Function to create a matrix with random values (0.0 to 1.0).\nmatrixRandom(int rows, int columns)=>\n    result = matrix.new<float>(rows, columns)\n    for i = 0 to rows - 1\n        for j = 0 to columns - 1\n            matrix.set(result, i, j, math.random())\n    result\n// Create a 2x3 matrix with random values.\nvar m = matrixRandom(2, 3)\n// Display using a label.\nif barstate.islastconfirmedhistory\n    label.new(bar_index, high, str.tostring(m))"
        },
        {
          "kind": "Built-in Function",
          "name": "matrix.new<string>",
          "desc": "Create matrix from random values",
          "args": [
            {
              "name": "rows",
              "desc": "Initial row count of the matrix. Optional. The default value is 0.",
              "default": "0",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "columns",
              "desc": "Initial column count of the matrix. Optional. The default value is 0.",
              "default": "0",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "initial_value",
              "desc": "Initial value of all matrix elements. Optional. The default is 'na'.",
              "default": "na",
              "required": false,
              "displayType": "matrix<type>",
              "allowedTypeIDs": [],
              "possibleValues": null
            }
          ],
          "syntax": "matrix.new<string>(rows, columns, initial_value) → matrix<string>",
          "returns": "The ID of the new matrix object.",
          "seeAlso": [
            "[matrix.set](#fun_matrix.set)",
            "[matrix.fill](#fun_matrix.fill)",
            "[matrix.columns](#fun_matrix.columns)",
            "[matrix.rows](#fun_matrix.rows)",
            "[array.new<type>](#fun_array.new<type>)"
          ],
          "examples": "//@version=5\nindicator('`matrix.new<string>()` Example')\n// Function to create a matrix with random values (0.0 to 1.0).\nmatrixRandom(int rows, int columns)=>\n    result = matrix.new<float>(rows, columns)\n    for i = 0 to rows - 1\n        for j = 0 to columns - 1\n            matrix.set(result, i, j, math.random())\n    result\n// Create a 2x3 matrix with random values.\nvar m = matrixRandom(2, 3)\n// Display using a label.\nif barstate.islastconfirmedhistory\n    label.new(bar_index, high, str.tostring(m))"
        },
        {
          "kind": "Built-in Function",
          "name": "matrix.new<color>",
          "desc": "Create matrix from random values",
          "args": [
            {
              "name": "rows",
              "desc": "Initial row count of the matrix. Optional. The default value is 0.",
              "default": "0",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "columns",
              "desc": "Initial column count of the matrix. Optional. The default value is 0.",
              "default": "0",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "initial_value",
              "desc": "Initial value of all matrix elements. Optional. The default is 'na'.",
              "default": "na",
              "required": false,
              "displayType": "matrix<type>",
              "allowedTypeIDs": [],
              "possibleValues": null
            }
          ],
          "syntax": "matrix.new<color>(rows, columns, initial_value) → matrix<color>",
          "returns": "The ID of the new matrix object.",
          "seeAlso": [
            "[matrix.set](#fun_matrix.set)",
            "[matrix.fill](#fun_matrix.fill)",
            "[matrix.columns](#fun_matrix.columns)",
            "[matrix.rows](#fun_matrix.rows)",
            "[array.new<type>](#fun_array.new<type>)"
          ],
          "examples": "//@version=5\nindicator('`matrix.new<color>()` Example')\n// Function to create a matrix with random values (0.0 to 1.0).\nmatrixRandom(int rows, int columns)=>\n    result = matrix.new<float>(rows, columns)\n    for i = 0 to rows - 1\n        for j = 0 to columns - 1\n            matrix.set(result, i, j, math.random())\n    result\n// Create a 2x3 matrix with random values.\nvar m = matrixRandom(2, 3)\n// Display using a label.\nif barstate.islastconfirmedhistory\n    label.new(bar_index, high, str.tostring(m))"
        },
        {
          "kind": "Built-in Function",
          "name": "matrix.new<line>",
          "desc": "Create matrix from random values",
          "args": [
            {
              "name": "rows",
              "desc": "Initial row count of the matrix. Optional. The default value is 0.",
              "default": "0",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "columns",
              "desc": "Initial column count of the matrix. Optional. The default value is 0.",
              "default": "0",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "initial_value",
              "desc": "Initial value of all matrix elements. Optional. The default is 'na'.",
              "default": "na",
              "required": false,
              "displayType": "matrix<type>",
              "allowedTypeIDs": [],
              "possibleValues": null
            }
          ],
          "syntax": "matrix.new<line>(rows, columns, initial_value) → matrix<line>",
          "returns": "The ID of the new matrix object.",
          "seeAlso": [
            "[matrix.set](#fun_matrix.set)",
            "[matrix.fill](#fun_matrix.fill)",
            "[matrix.columns](#fun_matrix.columns)",
            "[matrix.rows](#fun_matrix.rows)",
            "[array.new<type>](#fun_array.new<type>)"
          ],
          "examples": "//@version=5\nindicator('`matrix.new<line>()` Example')\n// Function to create a matrix with random values (0.0 to 1.0).\nmatrixRandom(int rows, int columns)=>\n    result = matrix.new<float>(rows, columns)\n    for i = 0 to rows - 1\n        for j = 0 to columns - 1\n            matrix.set(result, i, j, math.random())\n    result\n// Create a 2x3 matrix with random values.\nvar m = matrixRandom(2, 3)\n// Display using a label.\nif barstate.islastconfirmedhistory\n    label.new(bar_index, high, str.tostring(m))"
        },
        {
          "kind": "Built-in Function",
          "name": "matrix.new<label>",
          "desc": "Create matrix from random values",
          "args": [
            {
              "name": "rows",
              "desc": "Initial row count of the matrix. Optional. The default value is 0.",
              "default": "0",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "columns",
              "desc": "Initial column count of the matrix. Optional. The default value is 0.",
              "default": "0",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "initial_value",
              "desc": "Initial value of all matrix elements. Optional. The default is 'na'.",
              "default": "na",
              "required": false,
              "displayType": "matrix<type>",
              "allowedTypeIDs": [],
              "possibleValues": null
            }
          ],
          "syntax": "matrix.new<label>(rows, columns, initial_value) → matrix<label>",
          "returns": "The ID of the new matrix object.",
          "seeAlso": [
            "[matrix.set](#fun_matrix.set)",
            "[matrix.fill](#fun_matrix.fill)",
            "[matrix.columns](#fun_matrix.columns)",
            "[matrix.rows](#fun_matrix.rows)",
            "[array.new<type>](#fun_array.new<type>)"
          ],
          "examples": "//@version=5\nindicator('`matrix.new<label>()` Example')\n// Function to create a matrix with random values (0.0 to 1.0).\nmatrixRandom(int rows, int columns)=>\n    result = matrix.new<float>(rows, columns)\n    for i = 0 to rows - 1\n        for j = 0 to columns - 1\n            matrix.set(result, i, j, math.random())\n    result\n// Create a 2x3 matrix with random values.\nvar m = matrixRandom(2, 3)\n// Display using a label.\nif barstate.islastconfirmedhistory\n    label.new(bar_index, high, str.tostring(m))"
        },
        {
          "kind": "Built-in Function",
          "name": "matrix.new<box>",
          "desc": "Create matrix from random values",
          "args": [
            {
              "name": "rows",
              "desc": "Initial row count of the matrix. Optional. The default value is 0.",
              "default": "0",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "columns",
              "desc": "Initial column count of the matrix. Optional. The default value is 0.",
              "default": "0",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "initial_value",
              "desc": "Initial value of all matrix elements. Optional. The default is 'na'.",
              "default": "na",
              "required": false,
              "displayType": "matrix<type>",
              "allowedTypeIDs": [],
              "possibleValues": null
            }
          ],
          "syntax": "matrix.new<box>(rows, columns, initial_value) → matrix<box>",
          "returns": "The ID of the new matrix object.",
          "seeAlso": [
            "[matrix.set](#fun_matrix.set)",
            "[matrix.fill](#fun_matrix.fill)",
            "[matrix.columns](#fun_matrix.columns)",
            "[matrix.rows](#fun_matrix.rows)",
            "[array.new<type>](#fun_array.new<type>)"
          ],
          "examples": "//@version=5\nindicator('`matrix.new<box>()` Example')\n// Function to create a matrix with random values (0.0 to 1.0).\nmatrixRandom(int rows, int columns)=>\n    result = matrix.new<float>(rows, columns)\n    for i = 0 to rows - 1\n        for j = 0 to columns - 1\n            matrix.set(result, i, j, math.random())\n    result\n// Create a 2x3 matrix with random values.\nvar m = matrixRandom(2, 3)\n// Display using a label.\nif barstate.islastconfirmedhistory\n    label.new(bar_index, high, str.tostring(m))"
        },
        {
          "kind": "Built-in Function",
          "name": "matrix.new<table>",
          "desc": "Create matrix from random values",
          "args": [
            {
              "name": "rows",
              "desc": "Initial row count of the matrix. Optional. The default value is 0.",
              "default": "0",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "columns",
              "desc": "Initial column count of the matrix. Optional. The default value is 0.",
              "default": "0",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "initial_value",
              "desc": "Initial value of all matrix elements. Optional. The default is 'na'.",
              "default": "na",
              "required": false,
              "displayType": "matrix<type>",
              "allowedTypeIDs": [],
              "possibleValues": null
            }
          ],
          "syntax": "matrix.new<table>(rows, columns, initial_value) → matrix<table>",
          "returns": "The ID of the new matrix object.",
          "seeAlso": [
            "[matrix.set](#fun_matrix.set)",
            "[matrix.fill](#fun_matrix.fill)",
            "[matrix.columns](#fun_matrix.columns)",
            "[matrix.rows](#fun_matrix.rows)",
            "[array.new<type>](#fun_array.new<type>)"
          ],
          "examples": "//@version=5\nindicator('`matrix.new<table>()` Example')\n// Function to create a matrix with random values (0.0 to 1.0).\nmatrixRandom(int rows, int columns)=>\n    result = matrix.new<float>(rows, columns)\n    for i = 0 to rows - 1\n        for j = 0 to columns - 1\n            matrix.set(result, i, j, math.random())\n    result\n// Create a 2x3 matrix with random values.\nvar m = matrixRandom(2, 3)\n// Display using a label.\nif barstate.islastconfirmedhistory\n    label.new(bar_index, high, str.tostring(m))"
        },
        {
          "kind": "Built-in Function",
          "name": "matrix.new<linefill>",
          "desc": "Create matrix from random values",
          "args": [
            {
              "name": "rows",
              "desc": "Initial row count of the matrix. Optional. The default value is 0.",
              "default": "0",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "columns",
              "desc": "Initial column count of the matrix. Optional. The default value is 0.",
              "default": "0",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "initial_value",
              "desc": "Initial value of all matrix elements. Optional. The default is 'na'.",
              "default": "na",
              "required": false,
              "displayType": "matrix<type>",
              "allowedTypeIDs": [],
              "possibleValues": null
            }
          ],
          "syntax": "matrix.new<linefill>(rows, columns, initial_value) → matrix<linefill>",
          "returns": "The ID of the new matrix object.",
          "seeAlso": [
            "[matrix.set](#fun_matrix.set)",
            "[matrix.fill](#fun_matrix.fill)",
            "[matrix.columns](#fun_matrix.columns)",
            "[matrix.rows](#fun_matrix.rows)",
            "[array.new<type>](#fun_array.new<type>)"
          ],
          "examples": "//@version=5\nindicator('`matrix.new<linefill>()` Example')\n// Function to create a matrix with random values (0.0 to 1.0).\nmatrixRandom(int rows, int columns)=>\n    result = matrix.new<float>(rows, columns)\n    for i = 0 to rows - 1\n        for j = 0 to columns - 1\n            matrix.set(result, i, j, math.random())\n    result\n// Create a 2x3 matrix with random values.\nvar m = matrixRandom(2, 3)\n// Display using a label.\nif barstate.islastconfirmedhistory\n    label.new(bar_index, high, str.tostring(m))"
        },
        {
          "kind": "Built-in Function",
          "name": "matrix.new<type>",
          "desc": "The function creates a new matrix object. A matrix is a two-dimensional data structure containing rows and columns. All elements in the matrix must be of the type specified in the type template (\"<type>\").",
          "args": [
            {
              "name": "rows",
              "desc": "Initial row count of the matrix. Optional. The default value is 0.",
              "default": "0",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "columns",
              "desc": "Initial column count of the matrix. Optional. The default value is 0.",
              "default": "0",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "initial_value",
              "desc": "Initial value of all matrix elements. Optional. The default is 'na'.",
              "default": "na",
              "required": false,
              "displayType": "matrix<type>",
              "allowedTypeIDs": [],
              "possibleValues": null
            }
          ],
          "syntax": "matrix.new<type>(rows, columns, initial_value) → matrix<type>",
          "returns": "The ID of the new matrix object.",
          "seeAlso": [
            "[matrix.set](#fun_matrix.set)",
            "[matrix.fill](#fun_matrix.fill)",
            "[matrix.columns](#fun_matrix.columns)",
            "[matrix.rows](#fun_matrix.rows)",
            "[array.new<type>](#fun_array.new<type>)"
          ],
          "detailedDesc": [
            {
              "desc": "Create a matrix of elements with the same initial value",
              "examples": "//@version=5\nindicator(\"`matrix.new<type>()` Example 1\")\n\n// Create a 2x3 (2 rows x 3 columns) \"int\" matrix with values zero.\nvar m = matrix.new<int>(2, 3, 0)\n\n// Display using a label.\nif barstate.islastconfirmedhistory\n\tlabel.new(bar_index, high, str.tostring(m))"
            },
            {
              "desc": "Create a matrix from array values",
              "examples": "//@version=5\nindicator(\"`matrix.new<type>()` Example 2\")\n\n// Function to create a matrix whose rows are filled with array values.\nmatrixFromArray(int rows, int columns, array<float> data) =>\n\tm = matrix.new<float>(rows, columns)\n\tfor i = 0 to rows <= 0 ? na : rows - 1\n\t\tfor j = 0 to columns <= 0 ? na : columns - 1\n\t\t\tmatrix.set(m, i, j, array.get(data, i * columns + j))\n\tm\n\t\n// Create a 3x3 matrix from an array of values.\nvar m1 = matrixFromArray(3, 3, array.from(1, 2, 3, 4, 5, 6, 7, 8, 9))\n// Display using a label.\nif barstate.islastconfirmedhistory\n\tlabel.new(bar_index, high, str.tostring(m1))"
            },
            {
              "desc": "Create a matrix from an `input.text_area()` field",
              "examples": "//@version=5\nindicator(\"`matrix.new<type>()` Example 3\")\n\n// Function to create a matrix from a text string.\n// Values in a row must be separated by a space. Each line is one row.\nmatrixFromInputArea(stringOfValues) =>\n\tvar rowsArray = str.split(stringOfValues, \"\\n\")\n\tvar rows = array.size(rowsArray)\n\tvar cols = array.size(str.split(array.get(rowsArray, 0), \" \"))\n\tvar matrix = matrix.new<float>(rows, cols, na) \n\trow = 0\n\tfor rowString in rowsArray\n\t\tcol = 0\n\t\tvalues = str.split(rowString, \" \")\n\t\tfor val in values\n\t\t\tmatrix.set(matrix, row, col, str.tonumber(val))\n\t\t\tcol += 1\n\t\trow += 1\n\tmatrix\n\n\nstringInput = input.text_area(\"1 2 3\\n4 5 6\\n7 8 9\")\nvar m = matrixFromInputArea(stringInput)    \n\n// Display using a label.\nif barstate.islastconfirmedhistory\n\tlabel.new(bar_index, high, str.tostring(m))"
            },
            {
              "desc": "Create matrix from random values",
              "examples": "//@version=5\nindicator(\"`matrix.new<type>()` Example 4\")\n\n// Function to create a matrix with random values (0.0 to 1.0).\nmatrixRandom(int rows, int columns)=>\n\tresult = matrix.new<float>(rows, columns)\n\tfor i = 0 to rows - 1\n\t\tfor j = 0 to columns - 1\n\t\t\tmatrix.set(result, i, j, math.random())\n\tresult\n\n// Create a 2x3 matrix with random values.\nvar m = matrixRandom(2, 3)\n\n// Display using a label.\nif barstate.islastconfirmedhistory\n\tlabel.new(bar_index, high, str.tostring(m))"
            }
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "matrix.row",
          "desc": "The function creates a one-dimensional array from the elements of a matrix row.",
          "args": [
            {
              "name": "id",
              "desc": "A matrix object.",
              "default": null,
              "required": true,
              "displayType": "matrix<any>",
              "allowedTypeIDs": "matrix",
              "possibleValues": null
            },
            {
              "name": "row",
              "desc": "Index of the required row.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            }
          ],
          "syntax": "matrix.row(id, row) → type[]",
          "remarks": "Indexing of rows starts at 0.",
          "returns": "An array ID containing the `row` values of the `id` matrix.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.get](#fun_matrix.get)",
            "[array.get](#fun_array.get)",
            "[matrix.col](#fun_matrix.col)",
            "[matrix.rows](#fun_matrix.rows)"
          ],
          "examples": "//@version=5\nindicator(\"`matrix.row()` Example\", \"\", true)\n\n// Create a 2x3 \"float\" matrix from `hlc3` values.\nm = matrix.new<float>(2, 3, hlc3)\n\n// Return an array with the values of the first row of the matrix.\na = matrix.row(m, 0)\n\n// Plot the first value from the array `a`.\nplot(array.get(a, 0))",
          "returnedType": "array",
          "returnedTypes": [
            "array"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "matrix.col",
          "desc": "The function creates a one-dimensional array from the elements of a matrix column.",
          "args": [
            {
              "name": "id",
              "desc": "A matrix object.",
              "default": null,
              "required": true,
              "displayType": "matrix<any>",
              "allowedTypeIDs": "matrix",
              "possibleValues": null
            },
            {
              "name": "column",
              "desc": "Index of the required column.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            }
          ],
          "syntax": "matrix.col(id, column) → type[]",
          "remarks": "Indexing of rows starts at 0.",
          "returns": "An array ID containing the `column` values of the `id` matrix.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.get](#fun_matrix.get)",
            "[array.get](#fun_array.get)",
            "[matrix.col](#fun_matrix.col)",
            "[matrix.columns](#fun_matrix.columns)"
          ],
          "examples": "//@version=5\nindicator(\"`matrix.col()` Example\", \"\", true)\n\n// Create a 2x3 \"float\" matrix from `hlc3` values.\nm = matrix.new<float>(2, 3, hlc3)\n\n// Return an array with the values of the first column of matrix `m`.\na = matrix.col(m, 0)\n\n// Plot the first value from the array `a`.\nplot(array.get(a, 0))",
          "returnedType": "array",
          "returnedTypes": [
            "array"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "matrix.reshape",
          "desc": "The function rebuilds the `id` matrix to `rows` x `cols` dimensions.",
          "args": [
            {
              "name": "id",
              "desc": "A matrix object.",
              "default": null,
              "required": true,
              "displayType": "matrix<any>",
              "allowedTypeIDs": "matrix",
              "possibleValues": null
            },
            {
              "name": "rows",
              "desc": "The number of rows of the reshaped matrix.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "columns",
              "desc": "The  of columns of the reshaped matrix.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "matrix.reshape(id, rows, columns) → void",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.get](#fun_matrix.get)",
            "[matrix.set](#fun_matrix.set)",
            "[matrix.add_row](#fun_matrix.add_row)",
            "[matrix.add_col](#fun_matrix.add_col)"
          ],
          "examples": "//@version=5\nindicator(\"`matrix.reshape()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x3 matrix.\n\tvar m1 = matrix.new<float>(2, 3)\n\t// Fill the matrix with values.\n\tmatrix.set(m1, 0, 0, 1)\n\tmatrix.set(m1, 0, 1, 2)\n\tmatrix.set(m1, 0, 2, 3)\n\tmatrix.set(m1, 1, 0, 4)\n\tmatrix.set(m1, 1, 1, 5)\n\tmatrix.set(m1, 1, 2, 6)\n\t\n\t// Copy the matrix to a new one.\n\tvar m2 = matrix.copy(m1)\n\t\n\t// Reshape the copy to a 3x2.\n\tmatrix.reshape(m2, 3, 2)\n\t\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Original matrix:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 0, \"Reshaped matrix:\")\n\ttable.cell(t, 1, 1, str.tostring(m2))",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "matrix.get",
          "desc": "The function returns the element with the specified index of the matrix.",
          "args": [
            {
              "name": "id",
              "desc": "A matrix object.",
              "default": null,
              "required": true,
              "displayType": "matrix<any>",
              "allowedTypeIDs": "matrix",
              "possibleValues": null
            },
            {
              "name": "row",
              "desc": "Index of the required row.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            },
            {
              "name": "column",
              "desc": "Index of the required column.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            }
          ],
          "syntax": "matrix.get(id, row, column) → <matrix_type>",
          "remarks": "Indexing of the rows and columns starts at zero.",
          "returns": "The value of the element at the `row` and `column` index of the `id` matrix.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.set](#fun_matrix.set)",
            "[matrix.columns](#fun_matrix.columns)",
            "[matrix.rows](#fun_matrix.rows)"
          ],
          "examples": "//@version=5\nindicator(\"`matrix.get()` Example\", \"\", true)\n\n// Create a 2x3 \"float\" matrix from the `hl2` values.\nm = matrix.new<float>(2, 3, hl2)\n\n// Return the value of the element at index [0, 0] of matrix `m`.\nx = matrix.get(m, 0, 0)\n\nplot(x)",
          "returnedType": [],
          "returnedTypes": []
        },
        {
          "kind": "Built-in Function",
          "name": "matrix.set",
          "desc": "The function assigns `value` to the element at the `row` and `column` of the `id` matrix.",
          "args": [
            {
              "name": "id",
              "desc": "A matrix object.",
              "default": null,
              "required": true,
              "displayType": "matrix<any>",
              "allowedTypeIDs": "matrix",
              "possibleValues": null
            },
            {
              "name": "row",
              "desc": "The row index of the element to be modified.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            },
            {
              "name": "column",
              "desc": "The column index of the element to be modified.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            },
            {
              "name": "value",
              "desc": "The new value to be set.",
              "default": null,
              "required": true,
              "displayType": "any",
              "allowedTypeIDs": [],
              "possibleValues": null
            }
          ],
          "syntax": "matrix.set(id, row, column, value) → void",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.get](#fun_matrix.get)",
            "[matrix.columns](#fun_matrix.columns)",
            "[matrix.rows](#fun_matrix.rows)"
          ],
          "examples": "//@version=5\nindicator(\"`matrix.set()` Example\")\n\n// Create a 2x3 \"int\" matrix containing values `4`.\nm = matrix.new<int>(2, 3, 4)\n\n// Replace the value of element at row 1 and column 2 with value `3`.\nmatrix.set(m, 0, 1, 3)\n\n// Display using a label.\nif barstate.islastconfirmedhistory\n\tlabel.new(bar_index, high, str.tostring(m))",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "matrix.add_row",
          "desc": "The function adds a row at the `row` index of the `id` matrix. The row can consist of `na` values, or an array can be used to provide values.",
          "args": [
            {
              "name": "id",
              "desc": "A matrix object.",
              "default": null,
              "required": true,
              "displayType": "matrix<any>",
              "allowedTypeIDs": "matrix",
              "possibleValues": null
            },
            {
              "name": "row",
              "desc": "The index of the row after which the new row will be inserted. Optional. The default value is [matrix.rows](#fun_matrix.rows).",
              "default": "matrix.rows()",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            },
            {
              "name": "array_id",
              "desc": "An array to be inserted. Optional.",
              "default": null,
              "required": true,
              "displayType": "any[]",
              "allowedTypeIDs": "array",
              "possibleValues": null
            }
          ],
          "syntax": "matrix.add_row(id, row, array_id) → void",
          "remarks": "Indexing of rows and columns starts at zero. Rather than add rows to an empty matrix, it is far more efficient to declare a matrix with explicit dimensions and fill it with values.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.get](#fun_matrix.get)",
            "[matrix.set](#fun_matrix.set)",
            "[matrix.columns](#fun_matrix.columns)",
            "[matrix.rows](#fun_matrix.rows)",
            "[matrix.add_col](#fun_matrix.add_col)"
          ],
          "returnedType": "void",
          "detailedDesc": [
            {
              "desc": "Adding a row to the matrix",
              "examples": "//@version=5\nindicator(\"`matrix.add_row()` Example 1\")\n\n// Create a 2x3 \"int\" matrix containing values `0`.\nm = matrix.new<int>(2, 3, 0)\n\n// Add a row with `na` values to the matrix.\nmatrix.add_row(m)\n\n// Display matrix elements.\nif barstate.islastconfirmedhistory\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Matrix elements:\")\n\ttable.cell(t, 0, 1, str.tostring(m))"
            },
            {
              "desc": "Adding an array as a row to the matrix",
              "examples": "//@version=5\nindicator(\"`matrix.add_row()` Example 2\")\n\nif barstate.islastconfirmedhistory\n\t// Create an empty matrix object. \n\tvar m = matrix.new<int>()\n\t\n\t// Create an array with values `1` and `2`.\n\tvar a = array.from(1, 2)\n\t\n\t// Add the `a` array as the first row of the empty matrix.\n\tmatrix.add_row(m, 0, a)\n\t\n\t// Display matrix elements.\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Matrix elements:\")\n\ttable.cell(t, 0, 1, str.tostring(m))"
            }
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "matrix.add_col",
          "desc": "The function adds a column at the `column` index of the `id` matrix. The column can consist of `na` values, or an array can be used to provide values.",
          "args": [
            {
              "name": "id",
              "desc": "A matrix object.",
              "default": null,
              "required": true,
              "displayType": "matrix<any>",
              "allowedTypeIDs": "matrix",
              "possibleValues": null
            },
            {
              "name": "column",
              "desc": "The index of the column after which the new column will be inserted. Optional. The default value is [matrix.columns](#fun_matrix.columns).",
              "default": "matrix.columns()",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            },
            {
              "name": "array_id",
              "desc": "An array to be inserted. Optional.",
              "default": null,
              "required": true,
              "displayType": "any[]",
              "allowedTypeIDs": "array",
              "possibleValues": null
            }
          ],
          "syntax": "matrix.add_col(id, column, array_id) → void",
          "remarks": "Rather than add columns to an empty matrix, it is far more efficient to declare a matrix with explicit dimensions and fill it with values.  \nAdding a column is also much slower than adding a row with the [matrix.add_row](#fun_matrix.add_row) function.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.get](#fun_matrix.get)",
            "[matrix.set](#fun_matrix.set)",
            "[matrix.columns](#fun_matrix.columns)",
            "[matrix.rows](#fun_matrix.rows)",
            "[matrix.add_row](#fun_matrix.add_row)"
          ],
          "returnedType": "void",
          "detailedDesc": [
            {
              "desc": "Adding a column to the matrix",
              "examples": "//@version=5\nindicator(\"`matrix.add_col()` Example 1\")\n\n// Create a 2x3 \"int\" matrix containing values `0`.\nm = matrix.new<int>(2, 3, 0)\n\n// Add a column  with `na` values to the matrix.\nmatrix.add_col(m)\n\n// Display matrix elements.\nif barstate.islastconfirmedhistory\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Matrix elements:\")\n\ttable.cell(t, 0, 1, str.tostring(m))"
            },
            {
              "desc": "Adding an array as a column to the matrix",
              "examples": "//@version=5\nindicator(\"`matrix.add_col()` Example 2\")\n\nif barstate.islastconfirmedhistory\n\t// Create an empty matrix object. \n\tvar m = matrix.new<int>()\n\t\n\t// Create an array with values `1` and `3`.\n\tvar a = array.from(1, 3)\n\t\n\t// Add the `a` array as the first column of the empty matrix.\n\tmatrix.add_col(m, 0, a)\n\t\n\t// Display matrix elements.\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Matrix elements:\")\n\ttable.cell(t, 0, 1, str.tostring(m))"
            }
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "matrix.remove_row",
          "desc": "The function removes the row at `row` index of the `id` matrix and returns an array containing the removed row\\`s values.",
          "args": [
            {
              "name": "id",
              "desc": "A matrix object.",
              "default": null,
              "required": true,
              "displayType": "matrix<any>",
              "allowedTypeIDs": "matrix",
              "possibleValues": null
            },
            {
              "name": "row",
              "desc": "The index of the row to be deleted. Optional. The default value is [matrix.rows](#fun_matrix.rows).",
              "default": "matrix.rows()",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            }
          ],
          "syntax": "matrix.remove_row(id, row) → type[]",
          "remarks": "Indexing of rows and columns starts at zero. It is far more efficient to declare matrices with explicit dimensions than to build them by adding or removing rows.",
          "returns": "An array containing the elements of the row removed from the `id` matrix.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.set](#fun_matrix.set)",
            "[matrix.copy](#fun_matrix.copy)",
            "[matrix.remove_col](#fun_matrix.remove_col)"
          ],
          "examples": "//@version=5\nindicator(\"matrix_remove_row\", overlay = true)\n\n// Create a 2x2 \"int\" matrix containing values `1`.\nvar matrixOrig = matrix.new<int>(2, 2, 1)\n\n// Set values to the 'matrixOrig' matrix.\nmatrix.set(matrixOrig, 0, 1, 2)\nmatrix.set(matrixOrig, 1, 0, 3)\nmatrix.set(matrixOrig, 1, 1, 4)\n\n// Create a copy of the 'matrixOrig' matrix.\nmatrixCopy = matrix.copy(matrixOrig)\n\n// Remove the first row from the matrix `matrixCopy`.\narr = matrix.remove_row(matrixCopy, 0)\n\n// Display matrix elements.\nif barstate.islastconfirmedhistory\n\tvar t = table.new(position.top_right, 3, 2, color.green)\n\ttable.cell(t, 0, 0, \"Original Matrix:\")\n\ttable.cell(t, 0, 1, str.tostring(matrixOrig))\n\ttable.cell(t, 1, 0, \"Removed Elements:\")\n\ttable.cell(t, 1, 1, str.tostring(arr))\n\ttable.cell(t, 2, 0, \"Result Matrix:\")\n\ttable.cell(t, 2, 1, str.tostring(matrixCopy))",
          "returnedType": "array",
          "returnedTypes": [
            "array"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "matrix.remove_col",
          "desc": "The function removes the column at `column` index of the `id` matrix and returns an array containing the removed column\\`s values.",
          "args": [
            {
              "name": "id",
              "desc": "A matrix object.",
              "default": null,
              "required": true,
              "displayType": "matrix<any>",
              "allowedTypeIDs": "matrix",
              "possibleValues": null
            },
            {
              "name": "column",
              "desc": "The index of the column to be removed. Optional. The default value is [matrix.columns](#fun_matrix.columns).",
              "default": "matrix.columns()",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            }
          ],
          "syntax": "matrix.remove_col(id, column) → type[]",
          "remarks": "Indexing of rows and columns starts at zero. It is far more efficient to declare matrices with explicit dimensions than to build them by adding or removing columns.  \nDeleting a column is also much slower than deleting a row with the [matrix.remove_row](#fun_matrix.remove_row) function.",
          "returns": "An array containing the elements of the column removed from the `id` matrix.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.set](#fun_matrix.set)",
            "[matrix.copy](#fun_matrix.copy)",
            "[matrix.remove_row](#fun_matrix.remove_row)"
          ],
          "examples": "//@version=5\nindicator(\"matrix_remove_col\", overlay = true)\n\n// Create a 2x2 matrix with ones.\nvar matrixOrig = matrix.new<int>(2, 2, 1)\n\n// Set values to the 'matrixOrig' matrix.\nmatrix.set(matrixOrig, 0, 1, 2)\nmatrix.set(matrixOrig, 1, 0, 3)\nmatrix.set(matrixOrig, 1, 1, 4)\n\n\n// Create a copy of the 'matrixOrig' matrix.\nmatrixCopy = matrix.copy(matrixOrig)\n\n// Remove the first column from the `matrixCopy` matrix.\narr = matrix.remove_col(matrixCopy, 0)\n\n// Display matrix elements.\nif barstate.islastconfirmedhistory\n\tvar t = table.new(position.top_right, 3, 2, color.green)\n\ttable.cell(t, 0, 0, \"Original Matrix:\")\n\ttable.cell(t, 0, 1, str.tostring(matrixOrig))\n\ttable.cell(t, 1, 0, \"Removed Elements:\")\n\ttable.cell(t, 1, 1, str.tostring(arr))\n\ttable.cell(t, 2, 0, \"Result Matrix:\")\n\ttable.cell(t, 2, 1, str.tostring(matrixCopy))",
          "returnedType": "array",
          "returnedTypes": [
            "array"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "matrix.fill",
          "desc": "The function fills a rectangular area of the `id` matrix defined by the indices `from_column` to `to_column` (not including it) and `from_row` to `to_row`(not including it) with the `value`.",
          "args": [
            {
              "name": "id",
              "desc": "A matrix object.",
              "default": null,
              "required": true,
              "displayType": "matrix<any>",
              "allowedTypeIDs": "matrix",
              "possibleValues": null
            },
            {
              "name": "value",
              "desc": "The value to fill with.",
              "default": null,
              "required": true,
              "displayType": "any",
              "allowedTypeIDs": [],
              "possibleValues": null
            },
            {
              "name": "from_row",
              "desc": "Row index from which the fill will begin (inclusive). Optional. The default value is 0.",
              "default": "0",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "to_row",
              "desc": "Row index where the fill will end (not inclusive). Optional. The default value is [matrix.rows](#fun_matrix.rows).",
              "default": "matrix.rows()",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "from_column",
              "desc": "Column index from which the fill will begin (inclusive). Optional. The default value is 0.",
              "default": "0",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "to_column",
              "desc": "Column index where the fill will end (non inclusive). Optional. The default value is [matrix.columns](#fun_matrix.columns).",
              "default": "matrix.columns()",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "matrix.fill(id, value, from_row, to_row, from_column, to_column) → void",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.get](#fun_matrix.get)",
            "[matrix.set](#fun_matrix.set)",
            "[matrix.columns](#fun_matrix.columns)",
            "[matrix.rows](#fun_matrix.rows)"
          ],
          "examples": "//@version=5\nindicator(\"`matrix.fill()` Example\")\n\n// Create a 4x5 \"int\" matrix containing values `0`.\nm = matrix.new<float>(4, 5, 0)\n\n// Fill the intersection of rows 1 to 2 and columns 2 to 3 of the matrix with `hl2` values.\nmatrix.fill(m, hl2, 0, 2, 1, 3)\n\n// Display using a label.\nif barstate.islastconfirmedhistory\n\tlabel.new(bar_index, high, str.tostring(m))",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "matrix.submatrix",
          "desc": "The function extracts a submatrix of the `id` matrix within the specified indices.",
          "args": [
            {
              "name": "id",
              "desc": "A matrix object.",
              "default": null,
              "required": true,
              "displayType": "matrix<any>",
              "allowedTypeIDs": "matrix",
              "possibleValues": null
            },
            {
              "name": "from_row",
              "desc": "Index of the row from which the extraction will begin (inclusive). Optional. The default value is 0.",
              "default": "0",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "to_row",
              "desc": "Index of the row where the extraction will end (non inclusive). Optional. The default value is [matrix.rows](#fun_matrix.rows).",
              "default": "matrix.rows()",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "from_column",
              "desc": "Index of the column from which the extraction will begin (inclusive). Optional. The default value is 0.",
              "default": "0",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "to_column",
              "desc": "Index of the column where the extraction will end (non inclusive). Optional. The default value is [matrix.columns](#fun_matrix.columns).",
              "default": "matrix.columns()",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "matrix.submatrix(id, from_row, to_row, from_column, to_column) → matrix<type>",
          "remarks": "Indexing of the rows and columns starts at zero.",
          "returns": "A new matrix object containing the submatrix of the `id` matrix defined by the `from_row`, `to_row`, `from_column` and `to_column` indices.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.set](#fun_matrix.set)",
            "[matrix.row](#fun_matrix.row)",
            "[matrix.col](#fun_matrix.col)",
            "[matrix.reshape](#fun_matrix.reshape)"
          ],
          "examples": "//@version=5\nindicator(\"`matrix.submatrix()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x3 matrix matrix with values `0`.\n\tvar m1 = matrix.new<int>(2, 3, 0)\n\t// Fill the matrix with values.\n\tmatrix.set(m1, 0, 0, 1)\n\tmatrix.set(m1, 0, 1, 2)\n\tmatrix.set(m1, 0, 2, 3)\n\tmatrix.set(m1, 1, 0, 4)\n\tmatrix.set(m1, 1, 1, 5)\n\tmatrix.set(m1, 1, 2, 6)\n\t\n\t// Create a 2x2 submatrix of the `m1` matrix.\n\tvar m2 = matrix.submatrix(m1, 0, 2, 1, 3)\n\t\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Original Matrix:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 0, \"Submatrix:\")\n\ttable.cell(t, 1, 1, str.tostring(m2))",
          "returnedType": "matrix",
          "returnedTypes": [
            "matrix"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "matrix.copy",
          "desc": "The function creates a new matrix which is a copy of the original.",
          "args": [
            {
              "name": "id",
              "desc": "A matrix object to copy.",
              "default": null,
              "required": true,
              "displayType": "matrix<any>",
              "allowedTypeIDs": "matrix",
              "possibleValues": null
            }
          ],
          "syntax": "matrix.copy(id) → matrix<type>",
          "returns": "A new matrix object of the copied `id` matrix.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.get](#fun_matrix.get)",
            "[matrix.set](#fun_matrix.set)",
            "[matrix.columns](#fun_matrix.columns)",
            "[matrix.rows](#fun_matrix.rows)"
          ],
          "examples": "//@version=5\nindicator(\"`matrix.copy()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x3 \"float\" matrix with `1` values.\n\tvar m1 = matrix.new<float>(2, 3, 1)\n\t\n\t// Copy the matrix to a new one.\n\t// Note that unlike what `matrix.copy()` does, \n\t// the simple assignment operation `m2 = m1`\n\t// would NOT create a new copy of the `m1` matrix.\n\t// It would merely create a copy of its ID referencing the same matrix.\n\tvar m2 = matrix.copy(m1)\n\t\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 5, 2, color.green)\n\ttable.cell(t, 0, 0, \"Original Matrix:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 0, \"Matrix Copy:\")\n\ttable.cell(t, 1, 1, str.tostring(m2))",
          "returnedType": "matrix",
          "returnedTypes": [
            "matrix"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "matrix.columns",
          "desc": "The function returns the number of columns in the matrix.",
          "args": [
            {
              "name": "id",
              "desc": "A matrix object.",
              "default": null,
              "required": true,
              "displayType": "matrix<any>",
              "allowedTypeIDs": "matrix",
              "possibleValues": null
            }
          ],
          "syntax": "matrix.columns(id) → series int",
          "returns": "The number of columns in the matrix `id`.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.get](#fun_matrix.get)",
            "[matrix.set](#fun_matrix.set)",
            "[matrix.col](#fun_matrix.col)",
            "[matrix.row](#fun_matrix.row)",
            "[matrix.rows](#fun_matrix.rows)"
          ],
          "examples": "//@version=5\nindicator(\"`matrix.columns()` Example\")\n\n// Create a 2x6 matrix with values `0`.\nvar m = matrix.new<int>(2, 6, 0)\n\n// Get the quantity of columns in matrix `m`.\nvar x = matrix.columns(m)\n\n// Display using a label.\nif barstate.islastconfirmedhistory\n\tlabel.new(bar_index, high, \"Columns: \" + str.tostring(x) + \"\\n\" + str.tostring(m))",
          "returnedType": "int",
          "returnedTypes": [
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "matrix.rows",
          "desc": "The function returns the number of rows in the matrix.",
          "args": [
            {
              "name": "id",
              "desc": "A matrix object.",
              "default": null,
              "required": true,
              "displayType": "matrix<any>",
              "allowedTypeIDs": "matrix",
              "possibleValues": null
            }
          ],
          "syntax": "matrix.rows(id) → series int",
          "returns": "The number of rows in the matrix `id`.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.get](#fun_matrix.get)",
            "[matrix.set](#fun_matrix.set)",
            "[matrix.columns](#fun_matrix.columns)",
            "[matrix.row](#fun_matrix.row)"
          ],
          "examples": "//@version=5\nindicator(\"`matrix.rows()` Example\")\n\n// Create a 2x6 matrix with values `0`.\nvar m = matrix.new<int>(2, 6, 0)\n\n// Get the quantity of rows in the matrix.\nvar x = matrix.rows(m)\n\n// Display using a label.\nif barstate.islastconfirmedhistory\n\tlabel.new(bar_index, high, \"Rows: \" + str.tostring(x) + \"\\n\" + str.tostring(m))",
          "returnedType": "int",
          "returnedTypes": [
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "matrix.elements_count",
          "desc": "The function returns the total number of all matrix elements.",
          "args": [
            {
              "name": "id",
              "desc": "A matrix object.",
              "default": null,
              "required": true,
              "displayType": "matrix<any>",
              "allowedTypeIDs": "matrix",
              "possibleValues": null
            }
          ],
          "syntax": "matrix.elements_count(id) → series int",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.columns](#fun_matrix.columns)",
            "[matrix.rows](#fun_matrix.rows)"
          ],
          "returnedType": "int",
          "returnedTypes": [
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "matrix.concat",
          "desc": "The function appends the `m2` matrix to the `m1` matrix.",
          "args": [
            {
              "name": "id1",
              "desc": "Matrix object to concatenate into.",
              "required": true,
              "displayType": "matrix<any>",
              "allowedTypeIDs": "matrix",
              "possibleValues": null
            },
            {
              "name": "id2",
              "desc": "Matrix object whose elements will be appended to `id1`.",
              "default": null,
              "required": true,
              "displayType": "matrix<any>",
              "allowedTypeIDs": "matrix",
              "possibleValues": null
            }
          ],
          "syntax": "matrix.concat(id1, id2) → matrix<type>",
          "remarks": "The number of columns in both matrices must be identical.",
          "returns": "Returns the `id1` matrix concatenated with the `id2` matrix.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.get](#fun_matrix.get)",
            "[matrix.set](#fun_matrix.set)",
            "[matrix.columns](#fun_matrix.columns)",
            "[matrix.rows](#fun_matrix.rows)"
          ],
          "examples": "//@version=5\nindicator(\"`matrix.concat()` Example\")\n\n// Create a 2x4 \"int\" matrix containing values `0`.\nm1 = matrix.new<int>(2, 4, 0)\n// Create a 2x4 \"int\" matrix containing values `1`.\nm2 = matrix.new<int>(2, 4, 1)\n\n// Append matrix `m2` to `m1`.\nmatrix.concat(m1, m2)\n\n// Display matrix elements.\nif barstate.islastconfirmedhistory\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Matrix Elements:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))",
          "returnedType": "matrix",
          "returnedTypes": [
            "matrix"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "matrix.swap_rows",
          "desc": "The function swaps the rows at the index `row1` and `row2` in the `id` matrix.",
          "args": [
            {
              "name": "id",
              "desc": "A matrix object.",
              "default": null,
              "required": true,
              "displayType": "matrix<any>",
              "allowedTypeIDs": "matrix",
              "possibleValues": null
            },
            {
              "name": "row1",
              "desc": "Index of the first row to be swapped.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "row2",
              "desc": "Index of the second row to be swapped.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "matrix.swap_rows(id, row1, row2) → void",
          "remarks": "Indexing of the rows and columns starts at zero.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.get](#fun_matrix.get)",
            "[matrix.set](#fun_matrix.set)",
            "[matrix.columns](#fun_matrix.columns)",
            "[matrix.swap_columns](#fun_matrix.swap_columns)"
          ],
          "examples": "//@version=5\nindicator(\"`matrix.swap_rows()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 3x2 matrix with ‘na’ values.\n\tvar m1 = matrix.new<int>(3, 2, na)\n\t// Fill the matrix with values.\n\tmatrix.set(m1, 0, 0, 1)\n\tmatrix.set(m1, 0, 1, 2)\n\tmatrix.set(m1, 1, 0, 3)\n\tmatrix.set(m1, 1, 1, 4)\n\tmatrix.set(m1, 2, 0, 5)\n\tmatrix.set(m1, 2, 1, 6)\n\t\n\t// Copy the matrix to a new one.\n\tvar m2 = matrix.copy(m1)\n\t\n\t// Swap the first and second rows of the matrix copy.\n\tmatrix.swap_rows(m2, 0, 1)\n\t\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Original matrix:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 0, \"Swapped rows in copy:\")\n\ttable.cell(t, 1, 1, str.tostring(m2))",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "matrix.swap_columns",
          "desc": "The function swaps the columns at the index `column1` and `column2` in the `id` matrix.",
          "args": [
            {
              "name": "id",
              "desc": "A matrix object.",
              "default": null,
              "required": true,
              "displayType": "matrix<any>",
              "allowedTypeIDs": "matrix",
              "possibleValues": null
            },
            {
              "name": "column1",
              "desc": "Index of the first column to be swapped.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "column2",
              "desc": "Index of the second column to be swapped.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "matrix.swap_columns(id, column1, column2) → void",
          "remarks": "Indexing of the rows and columns starts at zero.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.get](#fun_matrix.get)",
            "[matrix.set](#fun_matrix.set)",
            "[matrix.columns](#fun_matrix.columns)",
            "[matrix.rows](#fun_matrix.rows)"
          ],
          "examples": "//@version=5\nindicator(\"`matrix.swap_columns()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x2 matrix with ‘na’ values.\n\tvar m1 = matrix.new<int>(2, 2, na)    \n\t// Fill the matrix with values.\n\tmatrix.set(m1, 0, 0, 1)\n\tmatrix.set(m1, 0, 1, 2)\n\tmatrix.set(m1, 1, 0, 3)\n\tmatrix.set(m1, 1, 1, 4)\n\t\n\t// Copy the matrix to a new one.\n\tvar m2 = matrix.copy(m1)\n\t\n\t// Swap the first and second columns of the matrix copy.\n\tmatrix.swap_columns(m2, 0, 1)\n\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Original matrix:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 0, \"Swapped columns in copy:\")\n\ttable.cell(t, 1, 1, str.tostring(m2))",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "matrix.reverse",
          "desc": "The function reverses the order of rows and columns in the matrix `id`. The first row and first column become the last, and the last become the first.",
          "args": [
            {
              "name": "id",
              "desc": "A matrix object.",
              "default": null,
              "required": true,
              "displayType": "matrix<any>",
              "allowedTypeIDs": "matrix",
              "possibleValues": null
            }
          ],
          "syntax": "matrix.reverse(id) → void",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.set](#fun_matrix.set)",
            "[matrix.columns](#fun_matrix.columns)",
            "[matrix.rows](#fun_matrix.rows)",
            "[matrix.reshape](#fun_matrix.reshape)"
          ],
          "examples": "//@version=5\nindicator(\"`matrix.reverse()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Copy the matrix to a new one.\n\tvar m1 = matrix.new<int>(2, 2, na)\n\t// Fill the matrix with values.\n\tmatrix.set(m1, 0, 0, 1)\n\tmatrix.set(m1, 0, 1, 2)\n\tmatrix.set(m1, 1, 0, 3)\n\tmatrix.set(m1, 1, 1, 4)\n\t\n\t// Copy matrix elements to a new matrix.\n\tvar m2 = matrix.copy(m1)\n\t\n\t// Reverse the `m2` copy of the original matrix. \n\tmatrix.reverse(m2)\n\t\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Original matrix:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 0, \"Reversed matrix:\")\n\ttable.cell(t, 1, 1, str.tostring(m2))",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "matrix.sort",
          "desc": "The function rearranges the rows in the `id` matrix following the sorted order of the values in the `column`.",
          "args": [
            {
              "name": "id",
              "desc": "A matrix object to be sorted.",
              "default": null,
              "required": true,
              "displayType": "matrix<int|float|string>",
              "allowedTypeIDs": [
                "matrix<int>",
                "matrix<float>",
                "matrix<string>"
              ],
              "possibleValues": null
            },
            {
              "name": "column",
              "desc": "Index of the column whose sorted values determine the new order of rows. Optional. The default value is 0.",
              "default": "0",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            },
            {
              "name": "order",
              "desc": "The sort order.  \nPossible values: [order.ascending](#var_order.ascending) (default), [order.descending](#var_order.descending).",
              "default": "order.ascending",
              "required": false,
              "displayType": "simple sort_order",
              "allowedTypeIDs": [
                "simple sort_order"
              ],
              "possibleValues": [
                "order.ascending",
                "order.descending"
              ]
            }
          ],
          "syntax": "matrix.sort(id, column, order) → void",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.max](#fun_matrix.max)",
            "[matrix.min](#fun_matrix.min)",
            "[matrix.avg](#fun_matrix.avg)"
          ],
          "examples": "//@version=5\nindicator(\"`matrix.sort()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x2 matrix. \n\tvar m1 = matrix.new<float>(2, 2, na)\n\t// Fill the matrix with values.\n\tmatrix.set(m1, 0, 0, 3)\n\tmatrix.set(m1, 0, 1, 4)\n\tmatrix.set(m1, 1, 0, 1)\n\tmatrix.set(m1, 1, 1, 2)\n\t\n\t// Copy the matrix to a new one.\n\tvar m2 = matrix.copy(m1)\n\t// Sort the rows of `m2` using the default arguments (first column and ascending order).\n\tmatrix.sort(m2)\n\t\n\t// Display using a table.\n\tif barstate.islastconfirmedhistory\n\t\tvar t = table.new(position.top_right, 2, 2, color.green)\n\t\ttable.cell(t, 0, 0, \"Original matrix:\")\n\t\ttable.cell(t, 0, 1, str.tostring(m1))\n\t\ttable.cell(t, 1, 0, \"Sorted matrix:\")\n\t\ttable.cell(t, 1, 1, str.tostring(m2))",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "matrix.det",
          "desc": "The function returns the [determinant](https://en.wikipedia.org/wiki/Determinant) of a square matrix.",
          "args": [
            {
              "name": "id",
              "desc": "A matrix object.",
              "default": null,
              "required": true,
              "displayType": "matrix<float|int>",
              "allowedTypeIDs": [
                "matrix<float>",
                "matrix<int>"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "matrix.det(id) → series float|int",
          "remarks": "Function calculation based on the [LU decomposition](https://en.wikipedia.org/wiki/LU_decomposition) algorithm.",
          "returns": "The determinant value of the `id` matrix.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.set](#fun_matrix.set)",
            "[matrix.is_square](#fun_matrix.is_square)"
          ],
          "examples": "//@version=5\nindicator(\"`matrix.det` Example\")\n\n// Create a 2x2 matrix.\nvar m = matrix.new<float>(2, 2, na)\n// Fill the matrix with values.\nmatrix.set(m, 0, 0,  3)\nmatrix.set(m, 0, 1,  7)\nmatrix.set(m, 1, 0,  1)\nmatrix.set(m, 1, 1, -4)\n\n// Get the determinant of the matrix. \nvar x = matrix.det(m)\n\nplot(x, 'Matrix determinant')",
          "returnedType": [
            "float",
            "int"
          ],
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float",
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "matrix.min",
          "desc": "The function returns the smallest value from the matrix elements.",
          "args": [
            {
              "name": "id",
              "desc": "A matrix object.",
              "default": null,
              "required": true,
              "displayType": "matrix<float|int>",
              "allowedTypeIDs": [
                "matrix<float>",
                "matrix<int>"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "matrix.min(id) → series float|int",
          "returns": "The smallest value from the `id` matrix.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.max](#fun_matrix.max)",
            "[matrix.avg](#fun_matrix.avg)",
            "[matrix.sort](#fun_matrix.sort)"
          ],
          "examples": "//@version=5\nindicator(\"`matrix.min()` Example\")\n\n// Create a 2x2 matrix.\nvar m = matrix.new<int>(2, 2, na)\n// Fill the matrix with values.\nmatrix.set(m, 0, 0, 1)\nmatrix.set(m, 0, 1, 2)\nmatrix.set(m, 1, 0, 3)\nmatrix.set(m, 1, 1, 4)\n\n// Get the minimum value from the matrix.\nvar x = matrix.min(m)\n\nplot(x, 'Matrix minimum value')",
          "returnedType": [
            "float",
            "int"
          ],
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float",
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "matrix.max",
          "desc": "The function returns the largest value from the matrix elements.",
          "args": [
            {
              "name": "id",
              "desc": "A matrix object.",
              "default": null,
              "required": true,
              "displayType": "matrix<float|int>",
              "allowedTypeIDs": [
                "matrix<float>",
                "matrix<int>"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "matrix.max(id) → series float|int",
          "returns": "The maximum value from the `id` matrix.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.min](#fun_matrix.min)",
            "[matrix.avg](#fun_matrix.avg)",
            "[matrix.sort](#fun_matrix.sort)"
          ],
          "examples": "//@version=5\nindicator(\"`matrix.max()` Example\")\n\n// Create a 2x2 matrix.\nvar m = matrix.new<int>(2, 2, na)\n// Fill the matrix with values.\nmatrix.set(m, 0, 0, 1)\nmatrix.set(m, 0, 1, 2)\nmatrix.set(m, 1, 0, 3)\nmatrix.set(m, 1, 1, 4)\n\n// Get the maximum value in the matrix.\nvar x = matrix.max(m)\n\nplot(x, 'Matrix maximum value')",
          "returnedType": [
            "float",
            "int"
          ],
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float",
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "matrix.avg",
          "desc": "The function calculates the average of all elements in the matrix.",
          "args": [
            {
              "name": "id",
              "desc": "A matrix object.",
              "default": null,
              "required": true,
              "displayType": "matrix<float|int>",
              "allowedTypeIDs": [
                "matrix<float>",
                "matrix<int>"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "matrix.avg(id) → series float|int",
          "returns": "The average value from the `id` matrix.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.get](#fun_matrix.get)",
            "[matrix.set](#fun_matrix.set)",
            "[matrix.columns](#fun_matrix.columns)",
            "[matrix.rows](#fun_matrix.rows)"
          ],
          "examples": "//@version=5\nindicator(\"`matrix.avg()` Example\")\n\n// Create a 2x2 matrix.\nvar m = matrix.new<int>(2, 2, na)\n// Fill the matrix with values.\nmatrix.set(m, 0, 0, 1)\nmatrix.set(m, 0, 1, 2)\nmatrix.set(m, 1, 0, 3)\nmatrix.set(m, 1, 1, 4)\n\n// Get the average value of the matrix.\nvar x = matrix.avg(m)\n\nplot(x, 'Matrix average value')",
          "returnedType": [
            "float",
            "int"
          ],
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float",
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "matrix.median",
          "desc": "The function calculates the [median](https://en.wikipedia.org/wiki/Median) (\"the middle\" value) of matrix elements.",
          "args": [
            {
              "name": "id",
              "desc": "A matrix object.",
              "default": null,
              "required": true,
              "displayType": "matrix<float|int>",
              "allowedTypeIDs": [
                "matrix<float>",
                "matrix<int>"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "matrix.median(id) → series float|int",
          "remarks": "Note that [na](#var_na) elements of the matrix are not considered when calculating the median.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.mode](#fun_matrix.mode)",
            "[matrix.sort](#fun_matrix.sort)",
            "[matrix.avg](#fun_matrix.avg)"
          ],
          "examples": "//@version=5\nindicator(\"`matrix.median()` Example\")\n\n// Create a 2x2 matrix.\nm = matrix.new<int>(2, 2, na)\n// Fill the matrix with values.\nmatrix.set(m, 0, 0, 1)\nmatrix.set(m, 0, 1, 2)\nmatrix.set(m, 1, 0, 3)\nmatrix.set(m, 1, 1, 4)\n\n// Get the median of the matrix.\nx = matrix.median(m)\n\nplot(x, 'Median of the matrix')",
          "returnedType": [
            "float",
            "int"
          ],
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float",
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "matrix.mode",
          "desc": "The function calculates the [mode](https://en.wikipedia.org/wiki/Mode_(statistics)) of the matrix, which is the most frequently occurring value from the matrix elements.  \nWhen there are multiple values occurring equally frequently, the function returns the smallest of those values.",
          "args": [
            {
              "name": "id",
              "desc": "A matrix object.",
              "default": null,
              "required": true,
              "displayType": "matrix<float|int>",
              "allowedTypeIDs": [
                "matrix<float>",
                "matrix<int>"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "matrix.mode(id) → series float|int",
          "remarks": "Note that [na](#var_na) elements of the matrix are not considered when calculating the mode.",
          "returns": "The most frequently occurring value from the `id` matrix. If none exists, returns the smallest value instead.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.set](#fun_matrix.set)",
            "[matrix.median](#fun_matrix.median)",
            "[matrix.sort](#fun_matrix.sort)",
            "[matrix.avg](#fun_matrix.avg)"
          ],
          "examples": "//@version=5\nindicator(\"`matrix.mode()` Example\")\n\n// Create a 2x2 matrix.\nvar m = matrix.new<int>(2, 2, na)\n// Fill the matrix with values.\nmatrix.set(m, 0, 0, 0)\nmatrix.set(m, 0, 1, 0)\nmatrix.set(m, 1, 0, 1)\nmatrix.set(m, 1, 1, 1)\n\n// Get the mode of the matrix.\nvar x = matrix.mode(m)\n\nplot(x, 'Mode of the matrix')",
          "returnedType": [
            "float",
            "int"
          ],
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float",
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "matrix.transpose",
          "desc": "The function creates a new, [transposed](https://en.wikipedia.org/wiki/Transpose#Transpose_of_a_matrix) version of the `id`.  \nThis interchanges the row and column index of each element.",
          "args": [
            {
              "name": "id",
              "desc": "A matrix object.",
              "default": null,
              "required": true,
              "displayType": "matrix<any>",
              "allowedTypeIDs": "matrix",
              "possibleValues": null
            }
          ],
          "syntax": "matrix.transpose(id) → matrix<type>",
          "returns": "A new matrix containing the transposed version of the `id` matrix.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.set](#fun_matrix.set)",
            "[matrix.columns](#fun_matrix.columns)",
            "[matrix.rows](#fun_matrix.rows)",
            "[matrix.reshape](#fun_matrix.reshape)",
            "[matrix.reverse](#fun_matrix.reverse)"
          ],
          "examples": "//@version=5\nindicator(\"`matrix.transpose()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x2 matrix. \n\tvar m1 = matrix.new<float>(2, 2, na)\n\t// Fill the matrix with values.\n\tmatrix.set(m1, 0, 0, 1)\n\tmatrix.set(m1, 0, 1, 2)\n\tmatrix.set(m1, 1, 0, 3)\n\tmatrix.set(m1, 1, 1, 4)\n\t\n\t// Create a transpose of the matrix.\n\tvar m2 = matrix.transpose(m1)\n\t\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Original matrix:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 0, \"Transposed matrix:\")\n\ttable.cell(t, 1, 1, str.tostring(m2))",
          "returnedType": "matrix",
          "returnedTypes": [
            "matrix"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "matrix.sum",
          "desc": "The function returns a new matrix resulting from the [sum](https://en.wikipedia.org/wiki/Matrix_addition) of two matrices `id1` and `id2`, or of an `id1` matrix and an `id2` scalar (a numerical value).",
          "args": [
            {
              "name": "id1",
              "desc": "First matrix object.",
              "required": true,
              "displayType": "matrix<int|float>",
              "allowedTypeIDs": [
                "matrix<int>",
                "matrix<float>"
              ],
              "possibleValues": null
            },
            {
              "name": "id2",
              "desc": "Second matrix object, or scalar value.",
              "default": null,
              "required": true,
              "displayType": "series int|float|matrix<int|float>",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float",
                "matrix<int>",
                "matrix<float>"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "matrix.sum(id1, id2) → matrix<int|float>",
          "returns": "A new matrix object containing the sum of `id2` and `id1`.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.get](#fun_matrix.get)",
            "[matrix.set](#fun_matrix.set)",
            "[matrix.columns](#fun_matrix.columns)",
            "[matrix.rows](#fun_matrix.rows)"
          ],
          "returnedType": [
            "matrix<float>",
            "matrix<int>"
          ],
          "detailedDesc": [
            {
              "desc": "Sum of two matrices",
              "examples": "//@version=5\nindicator(\"`matrix.sum()` Example 1\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x3 matrix containing values `5`.\n\tvar m1 = matrix.new<float>(2, 3, 5) \n\t// Create a 2x3 matrix containing values `4`.\n\tvar m2 = matrix.new<float>(2, 3, 4) \n\t// Create a new matrix that sums matrices `m1` and `m2`.\n\tvar m3 = matrix.sum(m1, m2) \n\t\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 1, 2, color.green)\n\ttable.cell(t, 0, 0, \"Sum of two matrices:\")\n\ttable.cell(t, 0, 1, str.tostring(m3))"
            },
            {
              "desc": "Sum of a matrix and scalar",
              "examples": "//@version=5\nindicator(\"`matrix.sum()` Example 2\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x3 matrix with values `4`.\n\tvar m1 = matrix.new<float>(2, 3, 4)\n\t\n\t// Create a new matrix containing the sum of the `m1` matrix with the \"int\" value `1`.\n\tvar m2 = matrix.sum(m1, 1)\n\t\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 1, 2, color.green)\n\ttable.cell(t, 0, 0, \"Sum of a matrix and a scalar:\")\n\ttable.cell(t, 0, 1, str.tostring(m2))"
            }
          ],
          "returnedTypes": [
            "matrix<int>",
            "matrix<float>"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "matrix.diff",
          "desc": "The function returns a new matrix resulting from the subtraction between matrices `id1` and `id2`, or of matrix `id1` and an `id2` scalar (a numerical value).",
          "args": [
            {
              "name": "id1",
              "desc": "Matrix to subtract from.",
              "default": null,
              "required": true,
              "displayType": "matrix<int|float>",
              "allowedTypeIDs": [
                "matrix<int>",
                "matrix<float>"
              ],
              "possibleValues": null
            },
            {
              "name": "id2",
              "desc": "Matrix object or a scalar value to be subtracted.",
              "default": null,
              "required": true,
              "displayType": "series int|float|matrix<int|float>",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float",
                "matrix<int>",
                "matrix<float>"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "matrix.diff(id1, id2) → matrix<int|float>",
          "returns": "A new matrix object containing the difference between `id2` and `id1`.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.get](#fun_matrix.get)",
            "[matrix.set](#fun_matrix.set)",
            "[matrix.columns](#fun_matrix.columns)",
            "[matrix.rows](#fun_matrix.rows)"
          ],
          "returnedType": [
            "matrix<float>",
            "matrix<int>"
          ],
          "detailedDesc": [
            {
              "desc": "Difference between two matrices",
              "examples": "//@version=5\nindicator(\"`matrix.diff()` Example 1\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x3 matrix containing values `5`.\n\tvar m1 = matrix.new<float>(2, 3, 5) \n\t// Create a 2x3 matrix containing values `4`.\n\tvar m2 = matrix.new<float>(2, 3, 4) \n\t// Create a new matrix containing the difference between matrices `m1` and `m2`.\n\tvar m3 = matrix.diff(m1, m2) \n\t\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 1, 2, color.green)\n\ttable.cell(t, 0, 0, \"Difference between two matrices:\")\n\ttable.cell(t, 0, 1, str.tostring(m3))"
            },
            {
              "desc": "Difference between a matrix and a scalar value",
              "examples": "//@version=5\nindicator(\"`matrix.diff()` Example 2\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x3 matrix with values `4`.\n\tvar m1 = matrix.new<float>(2, 3, 4)\n\t\n\t// Create a new matrix containing the difference between the `m1` matrix and the \"int\" value `1`.\n\tvar m2 = matrix.diff(m1, 1)\n\t\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 1, 2, color.green)\n\ttable.cell(t,  0, 0, \"Difference between a matrix and a scalar:\")\n\ttable.cell(t,  0, 1, str.tostring(m2))"
            }
          ],
          "returnedTypes": [
            "matrix<int>",
            "matrix<float>"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "matrix.mult",
          "desc": "The function returns a new matrix resulting from the [product](https://en.wikipedia.org/wiki/Matrix_multiplication) between the matrices `id1` and `id2`, or between an `id1` matrix and an `id2` scalar (a numerical value), or between an `id1` matrix and an `id2` vector (an array of values).",
          "args": [
            {
              "name": "id1",
              "desc": "First matrix object.",
              "required": true,
              "displayType": "matrix<int|float>",
              "allowedTypeIDs": [
                "matrix<int>",
                "matrix<float>"
              ],
              "possibleValues": null
            },
            {
              "name": "id2",
              "desc": "Second matrix object, value or array.",
              "default": null,
              "required": true,
              "displayType": "series int|float|matrix<int|float>|array<int|float>",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float",
                "matrix<int>",
                "matrix<float>",
                "array<int>",
                "array<float>"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "matrix.mult(id1, id2) → array|matrix<int|float>",
          "returns": "A new matrix object containing the product of `id2` and `id1`.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.sum](#fun_matrix.sum)",
            "[matrix.diff](#fun_matrix.diff)"
          ],
          "returnedType": [
            "array<float>",
            "array<int>",
            "matrix<float>",
            "matrix<int>"
          ],
          "detailedDesc": [
            {
              "desc": "Product of two matrices",
              "examples": "//@version=5\nindicator(\"`matrix.mult()` Example 1\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 6x2 matrix containing values `5`.\n\tvar m1 = matrix.new<float>(6, 2, 5) \n\t// Create a 2x3 matrix containing values `4`.\n\t// Note that it must have the same quantity of rows as there are columns in the first matrix.\n\tvar m2 = matrix.new<float>(2, 3, 4) \n\t// Create a new matrix from the multiplication of the two matrices.\n\tvar m3 = matrix.mult(m1, m2) \n\t\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 1, 2, color.green)\n\ttable.cell(t, 0, 0, \"Product of two matrices:\")\n\ttable.cell(t, 0, 1, str.tostring(m3))"
            },
            {
              "desc": "Product of a matrix and a scalar",
              "examples": "//@version=5\nindicator(\"`matrix.mult()` Example 2\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x3 matrix containing values `4`.\n\tvar m1 = matrix.new<float>(2, 3, 4) \n\t\n\t// Create a new matrix from the product of the two matrices.\n\tscalar = 5\n\tvar m2 = matrix.mult(m1, scalar) \n\t\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 5, 2, color.green)\n\ttable.cell(t, 0, 0, \"Matrix 1:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 1, \"x\")\n\ttable.cell(t, 2, 0, \"Scalar:\")\n\ttable.cell(t, 2, 1, str.tostring(scalar))\n\ttable.cell(t, 3, 1, \"=\")\n\ttable.cell(t, 4, 0, \"Matrix 2:\")\n\ttable.cell(t, 4, 1, str.tostring(m2))"
            },
            {
              "desc": "Product of a matrix and an array vector",
              "examples": "//@version=5\nindicator(\"`matrix.mult()` Example 3\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x3 matrix containing values `4`.\n\tvar m1 = matrix.new<int>(2, 3, 4)\n\t\n\t// Create an array of three elements.\n\tvar array<int> a = array.from(1, 1, 1)\n\t\n\t// Create a new matrix containing the product of the `m1` matrix and the `a` array.\n\tvar m3 = matrix.mult(m1, a) \n\t\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 5, 2, color.green)\n\ttable.cell(t, 0, 0, \"Matrix 1:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 1, \"x\")\n\ttable.cell(t, 2, 0, \"Value:\")\n\ttable.cell(t, 2, 1, str.tostring(a, \" \"))\n\ttable.cell(t, 3, 1, \"=\")\n\ttable.cell(t, 4, 0, \"Matrix 3:\")\n\ttable.cell(t, 4, 1, str.tostring(m3))"
            }
          ],
          "returnedTypes": [
            "matrix<int>",
            "matrix<float>",
            "array<int>",
            "array<float>"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "matrix.pinv",
          "desc": "The function returns the [pseudoinverse](https://en.wikipedia.org/wiki/Moore%E2%80%93Penrose_inverse) of a matrix.",
          "args": [
            {
              "name": "id",
              "desc": "A matrix object.",
              "default": null,
              "required": true,
              "displayType": "matrix<float|int>",
              "allowedTypeIDs": [
                "matrix<float>",
                "matrix<int>"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "matrix.pinv(id) → matrix<float|int>",
          "remarks": "The function is calculated using a [Moore–Penrose](https://en.wikipedia.org/wiki/Moore%E2%80%93Penrose_inverse#Definition) inverse formula based on singular-value decomposition of a matrix.  \nFor non-singular square matrices this function returns the result of [matrix.inv](#fun_matrix.inv).",
          "returns": "A new matrix containing the pseudoinverse of the `id` matrix.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.set](#fun_matrix.set)",
            "[matrix.inv](#fun_matrix.inv)"
          ],
          "examples": "//@version=5\nindicator(\"`matrix.pinv()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x2 matrix. \n\tvar m1 = matrix.new<int>(2, 2, na)\n\t// Fill the matrix with values.\n\tmatrix.set(m1, 0, 0, 1)\n\tmatrix.set(m1, 0, 1, 2)\n\tmatrix.set(m1, 1, 0, 3)\n\tmatrix.set(m1, 1, 1, 4)\n\t\n\t// Pseudoinverse of the matrix.\n\tvar m2 = matrix.pinv(m1)\n\t\n\t// Display matrix elements.\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Original Matrix:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 0, \"Pseudoinverse matrix:\")\n\ttable.cell(t, 1, 1, str.tostring(m2))",
          "returnedType": [
            "matrix<float>",
            "matrix<int>"
          ],
          "returnedTypes": [
            "matrix<float>",
            "matrix<int>"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "matrix.inv",
          "desc": "The function returns the [inverse](https://en.wikipedia.org/wiki/Invertible_matrix) of a square matrix.",
          "args": [
            {
              "name": "id",
              "desc": "A matrix object.",
              "default": null,
              "required": true,
              "displayType": "matrix<float|int>",
              "allowedTypeIDs": [
                "matrix<float>",
                "matrix<int>"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "matrix.inv(id) → matrix<float|int>",
          "remarks": "The function is calculated using the [LU decomposition](https://en.wikipedia.org/wiki/LU_decomposition) algorithm.",
          "returns": "A new matrix, which is the inverse of the `id` matrix.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.set](#fun_matrix.set)",
            "[matrix.pinv](#fun_matrix.pinv)",
            "[matrix.copy](#fun_matrix.copy)",
            "[str.tostring](#fun_str.tostring)"
          ],
          "examples": "//@version=5\nindicator(\"`matrix.inv()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x2 matrix. \n\tvar m1 = matrix.new<int>(2, 2, na)\n\t// Fill the matrix with values.\n\tmatrix.set(m1, 0, 0, 1)\n\tmatrix.set(m1, 0, 1, 2)\n\tmatrix.set(m1, 1, 0, 3)\n\tmatrix.set(m1, 1, 1, 4)\n\t\n\t// Inverse of the matrix.\n\tvar m2 = matrix.inv(m1)\n\t\n\t// Display matrix elements.\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Original Matrix:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 0, \"Inverse matrix:\")\n\ttable.cell(t, 1, 1, str.tostring(m2))",
          "returnedType": [
            "matrix<float>",
            "matrix<int>"
          ],
          "returnedTypes": [
            "matrix<float>",
            "matrix<int>"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "matrix.rank",
          "desc": "The function calculates the [rank](https://en.wikipedia.org/wiki/Rank_(linear_algebra)) of the matrix.",
          "args": [
            {
              "name": "id",
              "desc": "A matrix object.",
              "default": null,
              "required": true,
              "displayType": "matrix<any>",
              "allowedTypeIDs": "matrix",
              "possibleValues": null
            }
          ],
          "syntax": "matrix.rank(id) → series int",
          "returns": "The rank of the `id` matrix.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.set](#fun_matrix.set)",
            "[str.tostring](#fun_str.tostring)"
          ],
          "examples": "//@version=5\nindicator(\"`matrix.rank()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x2 matrix. \n\tvar m1 = matrix.new<int>(2, 2, na)\n\t// Fill the matrix with values.\n\tmatrix.set(m1, 0, 0, 1)\n\tmatrix.set(m1, 0, 1, 2)\n\tmatrix.set(m1, 1, 0, 3)\n\tmatrix.set(m1, 1, 1, 4)\n\t\n\t// Get the rank of the matrix. \n\tr = matrix.rank(m1)\n\t\n\t// Display matrix elements.\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Matrix elements:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 0, \"Rank of the matrix:\")\n\ttable.cell(t, 1, 1, str.tostring(r)) ",
          "returnedType": "int",
          "returnedTypes": [
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "matrix.trace",
          "desc": "The function calculates the [trace](https://en.wikipedia.org/wiki/Trace_(linear_algebra)) of a matrix (the sum of the main diagonal\\`s elements).",
          "args": [
            {
              "name": "id",
              "desc": "A matrix object.",
              "default": null,
              "required": true,
              "displayType": "matrix<float|int>",
              "allowedTypeIDs": [
                "matrix<float>",
                "matrix<int>"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "matrix.trace(id) → series float|int",
          "returns": "The trace of the `id` matrix.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.get](#fun_matrix.get)",
            "[matrix.set](#fun_matrix.set)",
            "[matrix.columns](#fun_matrix.columns)",
            "[matrix.rows](#fun_matrix.rows)"
          ],
          "examples": "//@version=5\nindicator(\"`matrix.trace()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x2 matrix. \n\tvar m1 = matrix.new<int>(2, 2, na)\n\t// Fill the matrix with values.\n\tmatrix.set(m1, 0, 0, 1)\n\tmatrix.set(m1, 0, 1, 2)\n\tmatrix.set(m1, 1, 0, 3)\n\tmatrix.set(m1, 1, 1, 4)\n\t\n\t// Get the trace of the matrix.\n\ttr = matrix.trace(m1)\n\t\n\t// Display matrix elements.\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Matrix elements:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 0, \"Trace of the matrix:\")\n\ttable.cell(t, 1, 1, str.tostring(tr))",
          "returnedType": [
            "float",
            "int"
          ],
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float",
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "matrix.eigenvalues",
          "desc": "The function returns an array containing the [eigenvalues](https://en.wikipedia.org/wiki/Eigenvalues_and_eigenvectors) of a square matrix.",
          "args": [
            {
              "name": "id",
              "desc": "A matrix object.",
              "default": null,
              "required": true,
              "displayType": "matrix<float|int>",
              "allowedTypeIDs": [
                "matrix<float>",
                "matrix<int>"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "matrix.eigenvalues(id) → array<float|int>",
          "remarks": "The function is calculated using \"The Implicit QL Algorithm\".",
          "returns": "An array containing the eigenvalues of the `id` matrix.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.set](#fun_matrix.set)",
            "[matrix.eigenvectors](#fun_matrix.eigenvectors)"
          ],
          "examples": "//@version=5\nindicator(\"`matrix.eigenvalues()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x2 matrix. \n\tvar m1 = matrix.new<int>(2, 2, na)\n\t// Fill the matrix with values.\n\tmatrix.set(m1, 0, 0, 2)\n\tmatrix.set(m1, 0, 1, 4)\n\tmatrix.set(m1, 1, 0, 6)\n\tmatrix.set(m1, 1, 1, 8)\n\t\n\t// Get the eigenvalues of the matrix.\n\ttr = matrix.eigenvalues(m1)\n\t\n\t// Display matrix elements.\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Matrix elements:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 0, \"Array of Eigenvalues:\")\n\ttable.cell(t, 1, 1, str.tostring(tr)) ",
          "returnedType": [
            "array<int>",
            "array<float>"
          ],
          "returnedTypes": [
            "array<float>",
            "array<int>"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "matrix.eigenvectors",
          "desc": "Returns a matrix of [eigenvectors](https://en.wikipedia.org/wiki/Eigenvalues_and_eigenvectors), in which each column is an eigenvector of the `id` matrix.",
          "args": [
            {
              "name": "id",
              "desc": "A matrix object.",
              "default": null,
              "required": true,
              "displayType": "matrix<float|int>",
              "allowedTypeIDs": [
                "matrix<float>",
                "matrix<int>"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "matrix.eigenvectors(id) → matrix<float|int>",
          "remarks": "The function is calculated using \"The Implicit QL Algorithm\".",
          "returns": "A new matrix containing the eigenvectors of the `id` matrix.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.get](#fun_matrix.get)",
            "[matrix.set](#fun_matrix.set)",
            "[matrix.eigenvalues](#fun_matrix.eigenvalues)"
          ],
          "examples": "//@version=5\nindicator(\"`matrix.eigenvectors()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x2 matrix \n\tvar m1 = matrix.new<int>(2, 2, 1)\n\t// Fill the matrix with values.\n\tmatrix.set(m1, 0, 0, 2)\n\tmatrix.set(m1, 0, 1, 4)\n\tmatrix.set(m1, 1, 0, 6)\n\tmatrix.set(m1, 1, 1, 8)\n\t\n\t// Get the eigenvectors of the matrix.\n\tm2 = matrix.eigenvectors(m1)\n\t\n\t// Display matrix elements.\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Matrix Elements:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 0, \"Matrix Eigenvectors:\")\n\ttable.cell(t, 1, 1, str.tostring(m2))  ",
          "returnedType": [
            "matrix<float>",
            "matrix<int>"
          ],
          "returnedTypes": [
            "matrix<float>",
            "matrix<int>"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "matrix.kron",
          "desc": "The function returns the [Kronecker product](https://en.wikipedia.org/wiki/Kronecker_product) for the `id1` and `id2` matrices.",
          "args": [
            {
              "name": "id1",
              "desc": "First matrix object.",
              "required": true,
              "displayType": "matrix<float|int>",
              "allowedTypeIDs": [
                "matrix<float>",
                "matrix<int>"
              ],
              "possibleValues": null
            },
            {
              "name": "id2",
              "desc": "Second matrix object.",
              "default": null,
              "required": true,
              "displayType": "matrix<float|int>",
              "allowedTypeIDs": [
                "matrix<float>",
                "matrix<int>"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "matrix.kron(id1, id2) → matrix<float|int>",
          "returns": "A new matrix containing the [Kronecker product](https://en.wikipedia.org/wiki/Kronecker_product) of `id1` and `id2`.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.mult](#fun_matrix.mult)",
            "[str.tostring](#fun_str.tostring)",
            "[table.new](#fun_table.new)"
          ],
          "examples": "//@version=5\nindicator(\"`matrix.kron()` Example\")\n\n// Display using a table.\nif barstate.islastconfirmedhistory\n\t// Create two matrices with default values `1` and `2`. \n\tvar m1 = matrix.new<float>(2, 2, 1) \n\tvar m2 = matrix.new<float>(2, 2, 2) \n\t\n\t// Calculate the Kronecker product of the matrices.\n\tvar m3 = matrix.kron(m1, m2) \n\t\n\t// Display matrix elements.\n\tvar t = table.new(position.top_right, 5, 2, color.green)\n\ttable.cell(t, 0, 0, \"Matrix 1:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 1, \"⊗\")\n\ttable.cell(t, 2, 0, \"Matrix 2:\")\n\ttable.cell(t, 2, 1, str.tostring(m2))\n\ttable.cell(t, 3, 1, \"=\")\n\ttable.cell(t, 4, 0, \"Kronecker product:\")\n\ttable.cell(t, 4, 1, str.tostring(m3))",
          "returnedType": [
            "matrix<float>",
            "matrix<int>"
          ],
          "returnedTypes": [
            "matrix<float>",
            "matrix<int>"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "matrix.pow",
          "desc": "The function calculates the product of the matrix by itself `power` times.",
          "args": [
            {
              "name": "id",
              "desc": "A matrix object.",
              "default": null,
              "required": true,
              "displayType": "matrix<float|int>",
              "allowedTypeIDs": [
                "matrix<float>",
                "matrix<int>"
              ],
              "possibleValues": null
            },
            {
              "name": "power",
              "desc": "The number of times the matrix will be multiplied by itself.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "matrix.pow(id, power) → matrix<float|int>",
          "returns": "The product of the `id` matrix by itself `power` times.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.set](#fun_matrix.set)",
            "[matrix.mult](#fun_matrix.mult)"
          ],
          "examples": "//@version=5\nindicator(\"`matrix.pow()` Example\")\n\n// Display using a table.\nif barstate.islastconfirmedhistory\n\t// Create a 2x2 matrix. \n\tvar m1 = matrix.new<int>(2, 2, 2)\n\t// Calculate the power of three of the matrix.\n\tvar m2 = matrix.pow(m1, 3)\n\t\n\t// Display matrix elements.\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Original Matrix:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 0, \"Matrix³:\")\n\ttable.cell(t, 1, 1, str.tostring(m2))",
          "returnedType": [
            "matrix<float>",
            "matrix<int>"
          ],
          "returnedTypes": [
            "matrix<float>",
            "matrix<int>"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "matrix.is_zero",
          "desc": "The function determines if all elements of the matrix are zero.",
          "args": [
            {
              "name": "id",
              "desc": "Matrix object to check.",
              "default": null,
              "required": true,
              "displayType": "matrix<float|int>",
              "allowedTypeIDs": [
                "matrix<float>",
                "matrix<int>"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "matrix.is_zero(id) → series bool",
          "returns": "Returns true if all elements of the `id` matrix are zero, false otherwise.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.get](#fun_matrix.get)",
            "[matrix.set](#fun_matrix.set)"
          ],
          "returnedType": "bool",
          "returnedTypes": [
            "series bool",
            "simple bool",
            "input bool",
            "const bool"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "matrix.is_identity",
          "desc": "The function determines if a matrix is an [identity matrix](https://en.wikipedia.org/wiki/Identity_matrix) (elements with ones on the [main diagonal](https://en.wikipedia.org/wiki/Main_diagonal) and zeros elsewhere).",
          "args": [
            {
              "name": "id",
              "desc": "Matrix object to test.",
              "default": null,
              "required": true,
              "displayType": "matrix<float|int>",
              "allowedTypeIDs": [
                "matrix<float>",
                "matrix<int>"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "matrix.is_identity(id) → series bool",
          "remarks": "Returns false with non-square matrices.",
          "returns": "Returns true if `id` is an identity matrix, false otherwise.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.is_square](#fun_matrix.is_square)",
            "[matrix.is_diagonal](#fun_matrix.is_diagonal)"
          ],
          "returnedType": "bool",
          "returnedTypes": [
            "series bool",
            "simple bool",
            "input bool",
            "const bool"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "matrix.is_binary",
          "desc": "The function determines if the matrix is [binary](https://en.wikipedia.org/wiki/Logical_matrix) (when all elements of the matrix are 0 or 1).",
          "args": [
            {
              "name": "id",
              "desc": "Matrix object to test.",
              "default": null,
              "required": true,
              "displayType": "matrix<float|int>",
              "allowedTypeIDs": [
                "matrix<float>",
                "matrix<int>"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "matrix.is_binary(id) → series bool",
          "returns": "Returns true if the `id` matrix is binary, false otherwise.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.get](#fun_matrix.get)",
            "[matrix.set](#fun_matrix.set)"
          ],
          "returnedType": "bool",
          "returnedTypes": [
            "series bool",
            "simple bool",
            "input bool",
            "const bool"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "matrix.is_symmetric",
          "desc": "The function determines if a [square matrix](https://en.wikipedia.org/wiki/Square_matrix) is [symmetric](https://en.wikipedia.org/wiki/Symmetric_matrix) (elements are symmetric with respect to the [main diagonal](https://en.wikipedia.org/wiki/Main_diagonal)).",
          "args": [
            {
              "name": "id",
              "desc": "Matrix object to test.",
              "default": null,
              "required": true,
              "displayType": "matrix<float|int>",
              "allowedTypeIDs": [
                "matrix<float>",
                "matrix<int>"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "matrix.is_symmetric(id) → series bool",
          "remarks": "Returns false with non-square matrices.",
          "returns": "Returns true if the `id` matrix is symmetric, false otherwise.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.get](#fun_matrix.get)",
            "[matrix.set](#fun_matrix.set)",
            "[matrix.is_square](#fun_matrix.is_square)"
          ],
          "returnedType": "bool",
          "returnedTypes": [
            "series bool",
            "simple bool",
            "input bool",
            "const bool"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "matrix.is_antisymmetric",
          "desc": "The function determines if a matrix is [antisymmetric](https://en.wikipedia.org/wiki/Skew-symmetric_matrix) (its [transpose](https://en.wikipedia.org/wiki/Transpose) equals its negative).",
          "args": [
            {
              "name": "id",
              "desc": "Matrix object to test.",
              "default": null,
              "required": true,
              "displayType": "matrix<float|int>",
              "allowedTypeIDs": [
                "matrix<float>",
                "matrix<int>"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "matrix.is_antisymmetric(id) → series bool",
          "remarks": "Returns false with non-square matrices.",
          "returns": "Returns true, if the `id` matrix is antisymmetric, false otherwise.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.get](#fun_matrix.get)",
            "[matrix.set](#fun_matrix.set)",
            "[matrix.is_square](#fun_matrix.is_square)"
          ],
          "returnedType": "bool",
          "returnedTypes": [
            "series bool",
            "simple bool",
            "input bool",
            "const bool"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "matrix.is_diagonal",
          "desc": "The function determines if the matrix is [diagonal](https://en.wikipedia.org/wiki/Diagonal_matrix) (all elements outside the main diagonal are zero).",
          "args": [
            {
              "name": "id",
              "desc": "Matrix object to test.",
              "default": null,
              "required": true,
              "displayType": "matrix<float|int>",
              "allowedTypeIDs": [
                "matrix<float>",
                "matrix<int>"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "matrix.is_diagonal(id) → series bool",
          "remarks": "Returns false with non-square matrices.",
          "returns": "Returns true if the `id` matrix is diagonal, false otherwise.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.set](#fun_matrix.set)",
            "[matrix.is_square](#fun_matrix.is_square)",
            "[matrix.is_identity](#fun_matrix.is_identity)",
            "[matrix.is_antidiagonal](#fun_matrix.is_antidiagonal)"
          ],
          "returnedType": "bool",
          "returnedTypes": [
            "series bool",
            "simple bool",
            "input bool",
            "const bool"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "matrix.is_antidiagonal",
          "desc": "The function determines if the matrix is [anti-diagonal](https://en.wikipedia.org/wiki/Anti-diagonal_matrix) (all elements outside the secondary diagonal are zero).",
          "args": [
            {
              "name": "id",
              "desc": "Matrix object to test.",
              "default": null,
              "required": true,
              "displayType": "matrix<float|int>",
              "allowedTypeIDs": [
                "matrix<float>",
                "matrix<int>"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "matrix.is_antidiagonal(id) → series bool",
          "remarks": "Returns false with non-square matrices.",
          "returns": "Returns true if the `id` matrix is ​​anti-diagonal, false otherwise.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.set](#fun_matrix.set)",
            "[matrix.is_square](#fun_matrix.is_square)",
            "[matrix.is_identity](#fun_matrix.is_identity)",
            "[matrix.is_diagonal](#fun_matrix.is_diagonal)"
          ],
          "returnedType": "bool",
          "returnedTypes": [
            "series bool",
            "simple bool",
            "input bool",
            "const bool"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "matrix.is_triangular",
          "desc": "The function determines if the matrix is [triangular](https://en.wikipedia.org/wiki/Triangular_matrix) (if all elements above or below the [main diagonal](https://en.wikipedia.org/wiki/Main_diagonal) are zero).",
          "args": [
            {
              "name": "id",
              "desc": "Matrix object to test.",
              "default": null,
              "required": true,
              "displayType": "matrix<float|int>",
              "allowedTypeIDs": [
                "matrix<float>",
                "matrix<int>"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "matrix.is_triangular(id) → series bool",
          "remarks": "Returns false with non-square matrices.",
          "returns": "Returns true if the `id` matrix is triangular, false otherwise.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.set](#fun_matrix.set)",
            "[matrix.is_square](#fun_matrix.is_square)"
          ],
          "returnedType": "bool",
          "returnedTypes": [
            "series bool",
            "simple bool",
            "input bool",
            "const bool"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "matrix.is_stochastic",
          "desc": "The function determines if the matrix is [stochastic](https://en.wikipedia.org/wiki/Stochastic_matrix).",
          "args": [
            {
              "name": "id",
              "desc": "Matrix object to test.",
              "default": null,
              "required": true,
              "displayType": "matrix<float|int>",
              "allowedTypeIDs": [
                "matrix<float>",
                "matrix<int>"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "matrix.is_stochastic(id) → series bool",
          "returns": "Returns true if the `id` matrix is stochastic, false otherwise.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.set](#fun_matrix.set)"
          ],
          "returnedType": "bool",
          "returnedTypes": [
            "series bool",
            "simple bool",
            "input bool",
            "const bool"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "matrix.is_square",
          "desc": "The function determines if the matrix is [square](https://en.wikipedia.org/wiki/Square_matrix) (it has the same number of rows and columns).",
          "args": [
            {
              "name": "id",
              "desc": "Matrix object to test.",
              "default": null,
              "required": true,
              "displayType": "matrix<any>",
              "allowedTypeIDs": "matrix",
              "possibleValues": null
            }
          ],
          "syntax": "matrix.is_square(id) → series bool",
          "returns": "Returns true if the `id` matrix is square, false otherwise.",
          "seeAlso": [
            "[matrix.new<type>](#fun_matrix.new%3Ctype%3E)",
            "[matrix.get](#fun_matrix.get)",
            "[matrix.set](#fun_matrix.set)",
            "[matrix.columns](#fun_matrix.columns)",
            "[matrix.rows](#fun_matrix.rows)"
          ],
          "returnedType": "bool",
          "returnedTypes": [
            "series bool",
            "simple bool",
            "input bool",
            "const bool"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "table.merge_cells",
          "desc": "The function merges a sequence of cells in the table into one cell. The cells are merged in a rectangle shape where the start_column and start_row specify the top-left corner, and end_column and end_row specify the bottom-right corner.",
          "args": [
            {
              "name": "table_id",
              "desc": "A table object.",
              "default": null,
              "required": true,
              "displayType": "series table",
              "allowedTypeIDs": [
                "series table"
              ],
              "possibleValues": null
            },
            {
              "name": "start_column",
              "desc": "The index of the column of the first cell to merge. Numbering starts at 0.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "start_row",
              "desc": "The index of the row of the first cell to merge. Numbering starts at 0.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "end_column",
              "desc": "The index of the column of the last cell to merge. Numbering starts at 0.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "end_row",
              "desc": "The index of the row of the last cell to merge. Numbering starts at 0.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "table.merge_cells(table_id, start_column, start_row, end_column, end_row) → void",
          "remarks": "This function will merge cells, even if their properties are not yet defined with [table.cell](#fun_table.cell).\nThe resulting merged cell inherits all of its values from the cell located at `start_column`:`start_row`, except width and height.  \nThe width and height of the resulting merged cell are based on the width/height of other cells in the neighboring columns/rows and cannot be set manually.\nTo modify the merged cell with any of the `table.cell_set_*` functions, target the cell at the `start_column`:`start_row` coordinates.\nAn attempt to merge a cell that has already been merged will result in an error.",
          "seeAlso": [
            "[table.delete](#fun_table.delete)",
            "[table.new](#fun_table.new)"
          ],
          "examples": "//@version=5\nindicator(\"table.merge_cells example\")\nSMA50  = ta.sma(close, 50)\nSMA100 = ta.sma(close, 100)\nSMA200 = ta.sma(close, 200)\nif barstate.islast\n\tmaTable = table.new(position.bottom_right, 3, 3, bgcolor = color.gray, border_width = 1, border_color = color.black)\n\t// Header\n\ttable.cell(maTable, 0, 0, text = \"SMA Table\")\n\ttable.merge_cells(maTable, 0, 0, 2, 0)\n\t// Cell Titles\n\ttable.cell(maTable, 0, 1, text = \"SMA 50\")\n\ttable.cell(maTable, 1, 1, text = \"SMA 100\")\n\ttable.cell(maTable, 2, 1, text = \"SMA 200\")\n\t// Values\n\ttable.cell(maTable, 0, 2, bgcolor = color.white, text = str.tostring(SMA50))\n\ttable.cell(maTable, 1, 2, bgcolor = color.white, text = str.tostring(SMA100))\n\ttable.cell(maTable, 2, 2, bgcolor = color.white, text = str.tostring(SMA200))",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "strategy.closedtrades.max_drawdown_percent",
          "desc": "Returns the maximum drawdown of the closed trade, i.e., the maximum possible loss during the trade, expressed as a percentage and calculated by formula: `Lowest Value During Trade  / (Entry Price x Quantity) * 100`.",
          "args": [
            {
              "name": "trade_num",
              "desc": "The trade number of the closed trade. The number of the first trade is zero.",
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            }
          ],
          "kind": "Built-in Function",
          "syntax": "strategy.closedtrades.max_drawdown_percent(trade_num) → series float",
          "seeAlso": [
            "[strategy.closedtrades.max_drawdown](#fun_strategy.closedtrades.max_drawdown)",
            "[strategy.max_drawdown](#var_strategy.max_drawdown)"
          ],
          "returnedTypes": "series float"
        },
        {
          "name": "strategy.closedtrades.max_runup_percent",
          "desc": "Returns the maximum run-up of the closed trade, i.e., the maximum possible profit during the trade, expressed as a percentage and calculated by formula: `Highest Value During Trade / (Entry Price x Quantity) * 100`.",
          "args": [
            {
              "name": "trade_num",
              "desc": "The trade number of the closed trade. The number of the first trade is zero.",
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            }
          ],
          "kind": "Built-in Function",
          "syntax": "strategy.closedtrades.max_runup_percent(trade_num) → series float",
          "seeAlso": [
            "[strategy.closedtrades.max_runup](#fun_strategy.closedtrades.max_runup)",
            "[strategy.max_runup](#var_strategy.max_runup)"
          ],
          "returnedTypes": "series float"
        },
        {
          "name": "strategy.closedtrades.profit_percent",
          "desc": "Returns the profit/loss value of the closed trade, expressed as a percentage. Losses are expressed as negative values.",
          "args": [
            {
              "name": "trade_num",
              "desc": "The trade number of the closed trade. The number of the first trade is zero.",
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            }
          ],
          "kind": "Built-in Function",
          "syntax": "strategy.closedtrades.profit_percent(trade_num) → series float",
          "seeAlso": "[strategy.closedtrades.profit](#fun_strategy.closedtrades.profit)",
          "returnedTypes": "series float"
        },
        {
          "name": "strategy.opentrades.max_drawdown_percent",
          "desc": "Returns the maximum drawdown of the open trade, i.e., the maximum possible loss during the trade, expressed as a percentage and calculated by formula: `Lowest Value During Trade  / (Entry Price x Quantity) * 100`.",
          "args": [
            {
              "name": "trade_num",
              "desc": "The trade number of the closed trade. The number of the first trade is zero.",
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            }
          ],
          "kind": "Built-in Function",
          "syntax": "strategy.opentrades.max_drawdown_percent(trade_num) → series float",
          "seeAlso": [
            "[strategy.opentrades.max_drawdown](#fun_strategy.opentrades.max_drawdown)",
            "[strategy.max_drawdown](#var_strategy.max_drawdown)"
          ],
          "returnedTypes": "series float"
        },
        {
          "name": "strategy.opentrades.max_runup_percent",
          "desc": "Returns the maximum run-up of the open trade, i.e., the maximum possible profit during the trade, expressed as a percentage and calculated by formula: `Highest Value During Trade / (Entry Price x Quantity) * 100`.",
          "args": [
            {
              "name": "trade_num",
              "desc": "The trade number of the closed trade. The number of the first trade is zero.",
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            }
          ],
          "kind": "Built-in Function",
          "syntax": "strategy.opentrades.max_runup_percent(trade_num) → series float",
          "seeAlso": [
            "[strategy.opentrades.max_runup](#fun_strategy.opentrades.max_runup)",
            "[strategy.max_runup](#var_strategy.max_runup)"
          ],
          "returnedTypes": "series float"
        },
        {
          "name": "strategy.opentrades.profit_percent",
          "desc": "Returns the profit/loss of the open trade, expressed as a percentage. Losses are expressed as negative values.",
          "args": [
            {
              "name": "trade_num",
              "desc": "The trade number of the closed trade. The number of the first trade is zero.",
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            }
          ],
          "kind": "Built-in Function",
          "syntax": "strategy.opentrades.profit_percent(trade_num) → series float",
          "seeAlso": "[strategy.opentrades.profit](#fun_strategy.opentrades.profit)",
          "returnedTypes": "series float"
        },
        {
          "name": "strategy.default_entry_qty",
          "desc": "Calculates the default quantity, in units, of an entry order from [strategy.entry](#fun_strategy.entry) or [strategy.order](#fun_strategy.order) if it were to fill at the specified `fill_price` value. The calculation depends on several strategy properties, including `default_qty_type`, `default_qty_value`, `currency`, and other parameters in the [strategy](#fun_strategy) function and their representation in the 'Properties' tab of the strategy\\'s settings.",
          "args": [
            {
              "name": "fill_price",
              "desc": "The fill price for which to calculate the default order quantity.",
              "required": true,
              "displayType": "series int/float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            }
          ],
          "kind": "Built-in Function",
          "syntax": "strategy.default_entry_qty(fill_price) → series float",
          "remarks": [
            "This function does not consider open positions simulated by a strategy. For example, if a strategy script has an open position from a long order with a `qty` of 10 units, using the [strategy.entry](#fun_strategy.entry) function to simulate a short order with a `qty` of 5 will prompt the script to sell 15 units to reverse the position. This function will still return 5 in such a case since it doesn't consider an open trade.",
            "This value represents the default calculated quantity of an order.",
            "Order placement commands can override the default value by explicitly passing a new `qty` value in the function call."
          ],
          "examples": "//@version=5\nstrategy('Supertrend Strategy', overlay = true, default_qty_type = strategy.percent_of_equity, default_qty_value = 15)\n\n//@variable The length of the ATR calculation.\natrPeriod = input(10, 'ATR Length')\n//@variable The ATR multiplier.\nfactor = input.float(3.0, 'Factor', step = 0.01)\n//@variable The tick offset of the stop order.\nstopOffsetInput = input.int(100, 'Tick offset for entry stop')\n\n// Get the direction of the SuperTrend.\n[_, direction] = ta.supertrend(factor, atrPeriod)\n\nif ta.change(direction) < 0\n\t//@variable The stop price of the entry order.\n\tstopPrice = close + syminfo.mintick * stopOffsetInput\n\t//@variable The expected default fill quantity at the `stopPrice`. This value may not reflect actual qty of the filled order, because fill price may be different.\n\tcalculatedQty = strategy.default_entry_qty(stopPrice)\n\tstrategy.entry('My Long Entry Id', strategy.long, stop = stopPrice)\n\tlabel.new(bar_index, stopPrice, str.format('Stop set at {0}\\nExpected qty at {0}: {1}', math.round_to_mintick(stopPrice), calculatedQty))\n\nif ta.change(direction) > 0\n\tstrategy.close_all()",
          "returnedTypes": "series float"
        },
        {
          "kind": "Built-in Function",
          "name": "strategy.closedtrades.entry_price",
          "desc": "Rnumbereturns the price of the closed trade\\`s entry.",
          "args": [
            {
              "name": "trade_num",
              "desc": "The trade number of the closed trade. The number of the first trade is zero.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "strategy.closedtrades.entry_price(trade_num) → series float",
          "seeAlso": [
            "[strategy.closedtrades.entry_price](#fun_strategy.closedtrades.entry_price)",
            "[strategy.closedtrades.exit_price](#fun_strategy.closedtrades.exit_price)",
            "[strategy.closedtrades.size](#fun_strategy.closedtrades.size)",
            "[strategy.closedtrades](#var_strategy.closedtrades), "
          ],
          "returnedType": "float",
          "detailedDesc": [
            {
              "desc": "",
              "examples": "//@version=5\nstrategy(\"strategy.closedtrades.entry_price Example 1\")\n\n// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.\nif bar_index % 15 == 0\n    strategy.entry(\"Long\", strategy.long)\nif bar_index % 20 == 0\n    strategy.close(\"Long\")\n\n// Return the entry price for the latest  entry.\nentryPrice = strategy.closedtrades.entry_price(strategy.closedtrades - 1)\n\nplot(entryPrice, \"Long entry price\")"
            },
            {
              "desc": "",
              "examples": "// Calculates the average profit percentage for all closed trades.\n//@version=5\nstrategy(\"strategy.closedtrades.entry_price Example 2\")\n\n// Strategy calls to create single short and long trades\nif bar_index == last_bar_index - 15\n    strategy.entry(\"Long Entry\",  strategy.long)\nelse if bar_index == last_bar_index - 10\n    strategy.close(\"Long Entry\")\n    strategy.entry(\"Short\", strategy.short)\nelse if bar_index == last_bar_index - 5\n    strategy.close(\"Short\")\n\n// Calculate profit for both closed trades.\nprofitPct = 0.0\nfor tradeNo = 0 to strategy.closedtrades - 1\n    entryP = strategy.closedtrades.entry_price(tradeNo)\n    exitP = strategy.closedtrades.exit_price(tradeNo)\n    profitPct += (exitP - entryP) / entryP * strategy.closedtrades.size(tradeNo) * 100\n    \n// Calculate average profit percent for both closed trades.\navgProfitPct = nz(profitPct / strategy.closedtrades)\n\nplot(avgProfitPct)"
            }
          ],
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "strategy.closedtrades.entry_bar_index",
          "desc": "Returns the bar_index of the closed trade\\`s entry.",
          "args": [
            {
              "name": "trade_num",
              "desc": "The trade number of the closed trade. The number of the first trade is zero.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "strategy.closedtrades.entry_bar_index(trade_num) → series int",
          "seeAlso": [
            "[strategy.closedtrades.exit_bar_index](#fun_strategy.closedtrades.exit_bar_index)",
            "[strategy.opentrades.entry_bar_index](#fun_strategy.opentrades.entry_bar_index)"
          ],
          "examples": "//@version=5\nstrategy(\"strategy.closedtrades.entry_bar_index Example\")\n// Enter long trades on three rising bars; exit on two falling bars.\nif ta.rising(close, 3)\n    strategy.entry(\"Long\", strategy.long)\nif ta.falling(close, 2)\n    strategy.close(\"Long\")\n// Function that calculates the average amount of bars in a trade.\navgBarsPerTrade() =>\n\tsumBarsPerTrade = 0\n\tfor tradeNo = 0 to strategy.closedtrades - 1\n\t\t// Loop through all closed trades, starting with the oldest.\n\t\tsumBarsPerTrade += strategy.closedtrades.exit_bar_index(tradeNo) - strategy.closedtrades.entry_bar_index(tradeNo) + 1\n\tresult = nz(sumBarsPerTrade / strategy.closedtrades)\nplot(avgBarsPerTrade())",
          "returnedType": "int",
          "returnedTypes": [
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "strategy.closedtrades.entry_time",
          "desc": "Returns the UNIX time of the closed trade\\`s entry.",
          "args": [
            {
              "name": "trade_num",
              "desc": "The trade number of the closed trade. The number of the first trade is zero.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "strategy.closedtrades.entry_time(trade_num) → series int",
          "seeAlso": [
            "[strategy.opentrades.entry_time](#fun_strategy.opentrades.entry_time)",
            "[strategy.closedtrades.exit_time](#fun_strategy.closedtrades.exit_time)",
            "[time](#var_time)"
          ],
          "examples": "//@version=5\nstrategy(\"strategy.closedtrades.entry_time Example\", overlay = true)\n\n// Enter long trades on three rising bars; exit on two falling bars.\nif ta.rising(close, 3)\n    strategy.entry(\"Long\", strategy.long)\nif ta.falling(close, 2)\n    strategy.close(\"Long\")\n\n// Calculate the average trade duration \navgTradeDuration() =>\n    sumTradeDuration = 0\n    for i = 0 to strategy.closedtrades - 1\n        sumTradeDuration += strategy.closedtrades.exit_time(i) - strategy.closedtrades.entry_time(i)\n    result = nz(sumTradeDuration / strategy.closedtrades)\n\n// Display average duration converted to seconds and formatted using 2 decimal points\nif barstate.islastconfirmedhistory\n    label.new(bar_index, high, str.tostring(avgTradeDuration() / 1000, \"#.##\") + \" seconds\")",
          "returnedType": "int",
          "returnedTypes": [
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "strategy.closedtrades.exit_price",
          "desc": "Returns the price of the closed trade\\`s exit.",
          "args": [
            {
              "name": "trade_num",
              "desc": "The trade number of the closed trade. The number of the first trade is zero.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "strategy.closedtrades.exit_price(trade_num) → series float",
          "seeAlso": [
            "[strategy.closedtrades.entry_price](#fun_strategy.closedtrades.entry_price)"
          ],
          "returnedType": "float",
          "detailedDesc": [
            {
              "desc": "",
              "examples": "//@version=5\nstrategy(\"strategy.closedtrades.exit_price Example 1\")\n\n// We are creating a long trade every 5 bars\nif bar_index % 5 == 0\n    strategy.entry(\"Long\",  strategy.long)\nstrategy.close(\"Long\")\n\n// Return the exit price from the latest closed trade.\nexitPrice = strategy.closedtrades.exit_price(strategy.closedtrades - 1)\n\nplot(exitPrice, \"Long exit price\")"
            },
            {
              "desc": "",
              "examples": "// Calculates the average profit percentage for all closed trades.\n//@version=5\nstrategy(\"strategy.closedtrades.exit_price Example 2\")\n\n// Strategy calls to create single short and long trades.\nif bar_index == last_bar_index - 15\n    strategy.entry(\"Long Entry\",  strategy.long)\nelse if bar_index == last_bar_index - 10\n    strategy.close(\"Long Entry\")\n    strategy.entry(\"Short\", strategy.short)\nelse if bar_index == last_bar_index - 5\n    strategy.close(\"Short\")\n\n// Calculate profit for both closed trades.\nprofitPct = 0.0\nfor tradeNo = 0 to strategy.closedtrades - 1\n    entryP = strategy.closedtrades.entry_price(tradeNo)\n    exitP = strategy.closedtrades.exit_price(tradeNo)\n    profitPct += (exitP - entryP) / entryP * strategy.closedtrades.size(tradeNo) * 100\n    \n// Calculate average profit percent for both closed trades.\navgProfitPct = nz(profitPct / strategy.closedtrades)\n\nplot(avgProfitPct)"
            }
          ],
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "strategy.closedtrades.exit_bar_index",
          "desc": "Returns the bar_index of the closed trade\\`s exit.",
          "args": [
            {
              "name": "trade_num",
              "desc": "The trade number of the closed trade. The number of the first trade is zero.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "strategy.closedtrades.exit_bar_index(trade_num) → series int",
          "seeAlso": [
            "[bar_index](#var_bar_index)",
            "[last_bar_index](#var_last_bar_index)"
          ],
          "returnedType": "int",
          "detailedDesc": [
            {
              "desc": "",
              "examples": "//@version=5\nstrategy(\"strategy.closedtrades.exit_bar_index Example 1\")\n\n// Strategy calls to place a single short trade. We enter the trade at the first bar and exit the trade at 10 bars before the last chart bar.\nif bar_index == 0\n    strategy.entry(\"Short\",  strategy.short)\nif bar_index == last_bar_index - 10\n    strategy.close(\"Short\")\n\n// Calculate the amount of bars since the last closed trade.\nbarsSinceClosed = strategy.closedtrades > 0 ? bar_index - strategy.closedtrades.exit_bar_index(strategy.closedtrades - 1) : na\n\nplot(barsSinceClosed, \"Bars since last closed trade\")"
            },
            {
              "desc": "",
              "examples": "// Calculates the average amount of bars per trade.\n//@version=5\nstrategy(\"strategy.closedtrades.exit_bar_index Example 2\")\n\n// Enter long trades on three rising bars; exit on two falling bars.\nif ta.rising(close, 3)\n    strategy.entry(\"Long\", strategy.long)\nif ta.falling(close, 2)\n    strategy.close(\"Long\")\n\n// Function that calculates the average amount of bars per trade.\navgBarsPerTrade() =>\n    sumBarsPerTrade = 0\n    for tradeNo = 0 to strategy.closedtrades - 1\n        // Loop through all closed trades, starting with the oldest.\n        sumBarsPerTrade += strategy.closedtrades.exit_bar_index(tradeNo) - strategy.closedtrades.entry_bar_index(tradeNo) + 1\n    result = nz(sumBarsPerTrade / strategy.closedtrades)\n\nplot(avgBarsPerTrade())"
            }
          ],
          "returnedTypes": [
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "strategy.closedtrades.exit_time",
          "desc": "Returns the UNIX time of the closed trade\\`s exit.",
          "args": [
            {
              "name": "trade_num",
              "desc": "The trade number of the closed trade. The number of the first trade is zero.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "strategy.closedtrades.exit_time(trade_num) → series int",
          "seeAlso": [
            "[strategy.closedtrades.entry_time](#fun_strategy.closedtrades.entry_time)"
          ],
          "returnedType": "int",
          "detailedDesc": [
            {
              "desc": "",
              "examples": "//@version=5\nstrategy(\"strategy.closedtrades.exit_time Example 1\")\n\n// Enter long trades on three rising bars; exit on two falling bars.\nif ta.rising(close, 3)\n    strategy.entry(\"Long\", strategy.long)\nif ta.falling(close, 2)\n    strategy.close(\"Long\")\n\n// Calculate the average trade duration. \navgTradeDuration() =>\n    sumTradeDuration = 0\n    for i = 0 to strategy.closedtrades - 1\n        sumTradeDuration += strategy.closedtrades.exit_time(i) - strategy.closedtrades.entry_time(i)\n    result = nz(sumTradeDuration / strategy.closedtrades)\n\n// Display average duration converted to seconds and formatted using 2 decimal points.\nif barstate.islastconfirmedhistory\n    label.new(bar_index, high, str.tostring(avgTradeDuration() / 1000, \"#.##\") + \" seconds\")"
            },
            {
              "desc": "",
              "examples": "// Reopens a closed trade after X seconds.\n//@version=5\nstrategy(\"strategy.closedtrades.exit_time Example 2\")\n\n// Strategy calls to emulate a single long trade at the first bar.\nif bar_index == 0\n    strategy.entry(\"Long\", strategy.long)\n\nreopenPositionAfter(timeSec) =>\n    if strategy.closedtrades > 0\n        if time - strategy.closedtrades.exit_time(strategy.closedtrades - 1) >= timeSec * 1000\n            strategy.entry(\"Long\", strategy.long)\n\n// Reopen last closed position after 120 sec.                \nreopenPositionAfter(120)\n\nif ta.change(strategy.opentrades)\n    strategy.exit(\"Long\", stop = low * 0.9, profit = high * 2.5)"
            }
          ],
          "returnedTypes": [
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "strategy.closedtrades.size",
          "desc": "Returns the direction and the number of contracts traded in the closed trade. If the value is > 0, the market position was long. If the value is < 0, the market position was short.",
          "args": [
            {
              "name": "trade_num",
              "desc": "The trade number of the closed trade. The number of the first trade is zero.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "strategy.closedtrades.size(trade_num) → series float",
          "seeAlso": [
            "[strategy.opentrades.size](#fun_strategy.opentrades.size)",
            "[strategy.position_size](#var_strategy.position_size)",
            "[strategy.closedtrades](#var_strategy.closedtrades)",
            "[strategy.opentrades](#var_strategy.opentrades)"
          ],
          "returnedType": "float",
          "detailedDesc": [
            {
              "desc": "",
              "examples": "//@version=5\nstrategy(\"`strategy.closedtrades.size` Example 1\")\n\n// We calculate the max amt of shares we can buy.\namtShares = math.floor(strategy.equity / close)\n// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars\nif bar_index % 15 == 0\n    strategy.entry(\"Long\", strategy.long, qty = amtShares)\nif bar_index % 20 == 0\n    strategy.close(\"Long\")\n\n// Plot the number of contracts traded in the last closed trade.     \nplot(strategy.closedtrades.size(strategy.closedtrades - 1), \"Number of contracts traded\")"
            },
            {
              "desc": "",
              "examples": "// Calculates the average profit percentage for all closed trades.\n//@version=5\nstrategy(\"`strategy.closedtrades.size` Example 2\")\n\n// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.\nif bar_index % 15 == 0\n    strategy.entry(\"Long\", strategy.long)\nif bar_index % 20 == 0\n    strategy.close(\"Long\")\n\n\n// Calculate profit for both closed trades.\nprofitPct = 0.0\nfor tradeNo = 0 to strategy.closedtrades - 1\n    entryP = strategy.closedtrades.entry_price(tradeNo)\n    exitP = strategy.closedtrades.exit_price(tradeNo)\n    profitPct += (exitP - entryP) / entryP * strategy.closedtrades.size(tradeNo) * 100\n    \n// Calculate average profit percent for both closed trades.\navgProfitPct = nz(profitPct / strategy.closedtrades)\n\nplot(avgProfitPct)"
            }
          ],
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "strategy.closedtrades.profit",
          "desc": "Returns the profit/loss of the closed trade. Losses are expressed as negative values.",
          "args": [
            {
              "name": "trade_num",
              "desc": "The trade number of the closed trade. The number of the first trade is zero.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "strategy.closedtrades.profit(trade_num) → series float",
          "seeAlso": [
            "[strategy.opentrades.profit](#fun_strategy.opentrades.profit)",
            "[strategy.closedtrades.commission](#fun_strategy.closedtrades.commission)"
          ],
          "examples": "//@version=5\nstrategy(\"`strategy.closedtrades.profit` Example\")\n\n// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.\nif bar_index % 15 == 0\n    strategy.entry(\"Long\", strategy.long)\nif bar_index % 20 == 0\n    strategy.close(\"Long\")\n\n// Calculate average gross profit by adding the difference between gross profit and commission.\navgGrossProfit() =>\n    sumGrossProfit = 0.0\n    for tradeNo = 0 to strategy.closedtrades - 1\n        sumGrossProfit += strategy.closedtrades.profit(tradeNo) - strategy.closedtrades.commission(tradeNo)\n    result = nz(sumGrossProfit / strategy.closedtrades)\n    \nplot(avgGrossProfit(), \"Average gross profit\")",
          "returnedType": "float",
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "strategy.closedtrades.commission",
          "desc": "Returns the sum of entry and exit fees paid in the closed trade.",
          "args": [
            {
              "name": "trade_num",
              "desc": "The trade number of the closed trade. The number of the first trade is zero.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "strategy.closedtrades.commission(trade_num) → series float",
          "seeAlso": [
            "[strategy](#fun_strategy)",
            "[strategy.opentrades.commission](#fun_strategy.opentrades.commission)"
          ],
          "examples": "//@version=5\nstrategy(\"`strategy.closedtrades.commission` Example\", commission_type = strategy.commission.percent, commission_value = 0.1)\n\n// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.\nif bar_index % 15 == 0\n    strategy.entry(\"Long\", strategy.long)\nif bar_index % 20 == 0\n    strategy.close(\"Long\")\n\n// Plot total fees for the latest closed trade.\nplot(strategy.closedtrades.commission(strategy.closedtrades - 1))",
          "returnedType": "float",
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "strategy.closedtrades.max_runup",
          "desc": "Returns the maximum run up of the closed trade, i.e., the maximum possible profit during the trade.",
          "args": [
            {
              "name": "trade_num",
              "desc": "The trade number of the closed trade. The number of the first trade is zero.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "strategy.closedtrades.max_runup(trade_num) → series float",
          "seeAlso": [
            "[strategy.opentrades.max_runup](#fun_strategy.opentrades.max_runup)",
            "[strategy.max_drawdown](#fun_strategy.max_drawdown)"
          ],
          "examples": "//@version=5\nstrategy(\"`strategy.closedtrades.max_runup` Example\")\n\n// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.\nif bar_index % 15 == 0\n    strategy.entry(\"Long\", strategy.long)\nif bar_index % 20 == 0\n    strategy.close(\"Long\")\n\n// Get the biggest max trade runup value from all of the closed trades.\nmaxTradeRunUp() =>\n    maxRunup = 0.0\n    for tradeNo = 0 to strategy.closedtrades - 1\n        maxRunup := math.max(maxRunup, strategy.closedtrades.max_runup(tradeNo))\n    result = maxRunup\n\nplot(maxTradeRunUp(), \"Max trade runup\")",
          "returnedType": "float",
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "strategy.closedtrades.max_drawdown",
          "desc": "Returns the maximum drawdown of the closed trade, i.e., the maximum possible loss during the trade.",
          "args": [
            {
              "name": "trade_num",
              "desc": "The trade number of the closed trade. The number of the first trade is zero.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "strategy.closedtrades.max_drawdown(trade_num) → series float",
          "remarks": "The function returns na if trade_num is not in the range: 0 to strategy.closedtrades - 1.",
          "seeAlso": [
            "[strategy.opentrades.max_drawdown](#fun_strategy.opentrades.max_drawdown)",
            "[strategy.max_drawdown](#fun_strategy.max_drawdown)"
          ],
          "examples": "//@version=5\nstrategy(\"`strategy.closedtrades.max_drawdown` Example\")\n\n// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.\nif bar_index % 15 == 0\n    strategy.entry(\"Long\", strategy.long)\nif bar_index % 20 == 0\n    strategy.close(\"Long\")\n\n// Get the biggest max trade drawdown value from all of the closed trades.\nmaxTradeDrawDown() =>\n    maxDrawdown = 0.0\n    for tradeNo = 0 to strategy.closedtrades - 1\n        maxDrawdown := math.max(maxDrawdown, strategy.closedtrades.max_drawdown(tradeNo))\n    result = maxDrawdown\n\nplot(maxTradeDrawDown(), \"Biggest max drawdown\")",
          "returnedType": "float",
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "strategy.closedtrades.entry_id",
          "desc": "Returns the id of the closed trade\\`s entry.",
          "args": [
            {
              "name": "trade_num",
              "desc": "The trade number of the closed trade. The number of the first trade is zero.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "strategy.closedtrades.entry_id(trade_num) → series string",
          "remarks": "The function returns na if trade_num is not in the range: 0 to strategy.closedtrades-1.",
          "returns": "Returns the id of the closed trade\\`s entry.",
          "seeAlso": [
            "[strategy.closedtrades.entry_bar_index](#fun_strategy.closedtrades.entry_bar_index)",
            "[strategy.closedtrades.entry_price](#fun_strategy.closedtrades.entry_price)",
            "[strategy.closedtrades.entry_time](#fun_strategy.closedtrades.entry_time)"
          ],
          "examples": "//@version=5\nstrategy(\"strategy.closedtrades.entry_id Example\", overlay = true)\n\n// Enter a short position and close at the previous to last bar.\nif bar_index == 1\n    strategy.entry(\"Short at bar #\" + str.tostring(bar_index), strategy.short)\nif bar_index == last_bar_index - 2\n    strategy.close_all()\n    \n// Display ID of the last entry position.\nif barstate.islastconfirmedhistory\n    label.new(last_bar_index, high, \"Last Entry ID is: \" + strategy.closedtrades.entry_id(strategy.closedtrades - 1))",
          "returnedType": "string",
          "returnedTypes": [
            "series string",
            "simple string",
            "input string",
            "const string"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "strategy.closedtrades.exit_id",
          "desc": "Returns the id of the closed trade\\`s exit.",
          "args": [
            {
              "name": "trade_num",
              "desc": "The trade number of the closed trade. The number of the first trade is zero.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "strategy.closedtrades.exit_id(trade_num) → series string",
          "remarks": "The function returns na if trade_num is not in the range: 0 to strategy.closedtrades-1.",
          "returns": "Returns the id of the closed trade\\`s exit.",
          "seeAlso": [
            "[strategy.closedtrades.exit_bar_index](#fun_strategy.closedtrades.exit_bar_index)",
            "[strategy.closedtrades.exit_price](#fun_strategy.closedtrades.exit_price)",
            "[strategy.closedtrades.exit_time](#fun_strategy.closedtrades.exit_time)"
          ],
          "examples": "//@version=5\nstrategy(\"strategy.closedtrades.exit_id Example\", overlay = true)\n\n// Strategy calls to create single short and long trades\nif bar_index == last_bar_index - 15\n    strategy.entry(\"Long Entry\",  strategy.long)\nelse if bar_index == last_bar_index - 10\n    strategy.entry(\"Short Entry\", strategy.short)\n    \n// When a new open trade is detected then we create the exit strategy corresponding with the matching entry id\n// We detect the correct entry id by determining if a position is long or short based on the position quantity\nif ta.change(strategy.opentrades)\n    posSign = strategy.opentrades.size(strategy.opentrades - 1)\n    strategy.exit(posSign > 0 ? \"SL Long Exit\" : \"SL Short Exit\", strategy.opentrades.entry_id(strategy.opentrades - 1), stop = posSign > 0 ? high - ta.tr : low + ta.tr)\n\n// When a new closed trade is detected then we place a label above the bar with the exit info\nif ta.change(strategy.closedtrades)\n    msg = \"Trade closed by: \" + strategy.closedtrades.exit_id(strategy.closedtrades - 1)\n    label.new(bar_index, high + (3 * ta.tr), msg)",
          "returnedType": "string",
          "returnedTypes": [
            "series string",
            "simple string",
            "input string",
            "const string"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "strategy.opentrades.entry_comment",
          "desc": "Returns the comment message of the open trade\\`s entry, or\n[na](#var_na) if there is no entry with this `trade_num`.",
          "args": [
            {
              "name": "trade_num",
              "desc": "The trade number of the open trade. The number of the first trade is zero.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "strategy.opentrades.entry_comment(trade_num) → series string",
          "seeAlso": [
            "[strategy](#fun_strategy)",
            "[strategy.entry](#fun_strategy.entry)",
            "[strategy.opentrades](#var_strategy.opentrades)"
          ],
          "examples": "//@version=5\nstrategy(\"`strategy.opentrades.entry_comment()` Example\", overlay = true)\n\nstopPrice = open * 1.01\n\nlongCondition = ta.crossover(ta.sma(close, 14), ta.sma(close, 28))\n\nif (longCondition)\n    strategy.entry(\"Long\", strategy.long, stop = stopPrice, comment = str.tostring(stopPrice, \"#.####\"))\n\nvar testTable = table.new(position.top_right, 1, 3, color.orange, border_width = 1)\n\nif barstate.islastconfirmedhistory or barstate.isrealtime\n    table.cell(testTable, 0, 0, 'Last entry stats')\n    table.cell(testTable, 0, 1, \"Order stop price value: \" + strategy.opentrades.entry_comment(strategy.opentrades - 1))\n    table.cell(testTable, 0, 2, \"Actual Entry Price: \" + str.tostring(strategy.opentrades.entry_price(strategy.opentrades - 1)))",
          "returnedType": "string",
          "returnedTypes": [
            "series string",
            "simple string",
            "input string",
            "const string"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "strategy.closedtrades.entry_comment",
          "desc": "Returns the comment message of the closed trade\\`s entry, or [na](#var_na)\nif there is no entry with this `trade_num`.",
          "args": [
            {
              "name": "trade_num",
              "desc": "The trade number of the closed trade. The number of the first trade is zero.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "strategy.closedtrades.entry_comment(trade_num) → series string",
          "seeAlso": [
            "[strategy](#fun_strategy)",
            "[strategy.entry](#fun_strategy.entry)",
            "[strategy.closedtrades](#var_strategy.closedtrades)"
          ],
          "examples": "//@version=5\nstrategy(\"`strategy.closedtrades.entry_comment()` Example\", overlay = true)\n\nstopPrice = open * 1.01\n\nlongCondition = ta.crossover(ta.sma(close, 14), ta.sma(close, 28))\n\nif (longCondition)\n    strategy.entry(\"Long\", strategy.long, stop = stopPrice, comment = str.tostring(stopPrice, \"#.####\"))\n    strategy.exit(\"EXIT\", trail_points = 1000, trail_offset = 0)\n\nvar testTable = table.new(position.top_right, 1, 3, color.orange, border_width = 1)\n\nif barstate.islastconfirmedhistory or barstate.isrealtime\n    table.cell(testTable, 0, 0, 'Last closed trade:')\n    table.cell(testTable, 0, 1, \"Order stop price value: \" + strategy.closedtrades.entry_comment(strategy.closedtrades - 1))\n    table.cell(testTable, 0, 2, \"Actual Entry Price: \" + str.tostring(strategy.closedtrades.entry_price(strategy.closedtrades - 1)))",
          "returnedType": "string",
          "returnedTypes": [
            "series string",
            "simple string",
            "input string",
            "const string"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "strategy.closedtrades.exit_comment",
          "desc": "Returns the comment message of the closed trade\\`s exit, or\n[na](#var_na) if there is no entry with this `trade_num`.",
          "args": [
            {
              "name": "trade_num",
              "desc": "The trade number of the closed trade. The number of the first trade is zero.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "strategy.closedtrades.exit_comment(trade_num) → series string",
          "seeAlso": [
            "[strategy](#fun_strategy)",
            "[strategy.exit](#fun_strategy.exit)",
            "[strategy.close](#fun_strategy.close)",
            "[strategy.closedtrades](#fun_strategy.closedtrades)"
          ],
          "examples": "//@version=5\nstrategy(\"`strategy.closedtrades.exit_comment()` Example\", overlay = true)\n\nlongCondition = ta.crossover(ta.sma(close, 14), ta.sma(close, 28))\nif (longCondition)\n    strategy.entry(\"Long\", strategy.long)\n    strategy.exit(\"Exit\", stop = open * 0.95, limit = close * 1.05, trail_points = 100, trail_offset = 0, comment_profit = \"TP\", comment_loss = \"SL\", comment_trailing = \"TRAIL\")\n\nexitStats() =>\n    int slCount = 0\n    int tpCount = 0\n    int trailCount = 0\n\t\n    if strategy.closedtrades > 0\n        for i = 0 to strategy.closedtrades - 1\n            switch strategy.closedtrades.exit_comment(i)\n                \"TP\"    => tpCount    += 1\n                \"SL\"    => slCount    += 1\n                \"TRAIL\" => trailCount += 1\n    [slCount, tpCount, trailCount]\n\nvar testTable = table.new(position.top_right, 1, 4, color.orange, border_width = 1)\n\nif barstate.islastconfirmedhistory\n    [slCount, tpCount, trailCount] = exitStats()\n    table.cell(testTable, 0, 0, \"Closed trades (\" + str.tostring(strategy.closedtrades) +\") stats:\")\n    table.cell(testTable, 0, 1, \"Stop Loss: \" + str.tostring(slCount))\n    table.cell(testTable, 0, 2, \"Take Profit: \" + str.tostring(tpCount))\n    table.cell(testTable, 0, 3, \"Trailing Stop: \" + str.tostring(trailCount))",
          "returnedType": "string",
          "returnedTypes": [
            "series string",
            "simple string",
            "input string",
            "const string"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "strategy.opentrades.entry_price",
          "desc": "Returns the price of the open trade\\`s entry.",
          "args": [
            {
              "name": "trade_num",
              "desc": "The trade number of the open trade. The number of the first trade is zero.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "strategy.opentrades.entry_price(trade_num) → series float",
          "seeAlso": [
            "[strategy.closedtrades.exit_price](#fun_strategy.closedtrades.exit_price)"
          ],
          "returnedType": "float",
          "detailedDesc": [
            {
              "desc": "",
              "examples": "//@version=5\nstrategy(\"strategy.opentrades.entry_price Example 1\", overlay = true)\n\n// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.\nif ta.crossover(close, ta.sma(close, 14))\n\tstrategy.entry(\"Long\", strategy.long)\n\n// Return the entry price for the latest closed trade.\ncurrEntryPrice = strategy.opentrades.entry_price(strategy.opentrades - 1)\ncurrExitPrice = currEntryPrice * 1.05\n\nif high >= currExitPrice\n\tstrategy.close(\"Long\")\n\nplot(currEntryPrice, \"Long entry price\", style = plot.style_linebr)\nplot(currExitPrice, \"Long exit price\", color.green, style = plot.style_linebr)"
            },
            {
              "desc": "",
              "examples": "// Calculates the average price for the open position.\n//@version=5\nstrategy(\"strategy.opentrades.entry_price Example 2\", pyramiding = 2)\n\n// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.\nif bar_index % 15 == 0\n    strategy.entry(\"Long\", strategy.long)\nif bar_index % 20 == 0\n    strategy.close(\"Long\")\n\n// Calculates the average price for the open position.\navgOpenPositionPrice() =>\n    sumOpenPositionPrice = 0.0\n    for tradeNo = 0 to strategy.opentrades - 1\n        sumOpenPositionPrice += strategy.opentrades.entry_price(tradeNo) * strategy.opentrades.size(tradeNo) / strategy.position_size\n    result = nz(sumOpenPositionPrice / strategy.opentrades)\n\nplot(avgOpenPositionPrice())"
            }
          ],
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "strategy.opentrades.entry_bar_index",
          "desc": "Returns the bar_index of the open trade\\`s entry.",
          "args": [
            {
              "name": "trade_num",
              "desc": "The trade number of the open trade. The number of the first trade is zero.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "strategy.opentrades.entry_bar_index(trade_num) → series int",
          "seeAlso": [
            "[strategy.closedtrades.entry_bar_index](#fun_strategy.closedtrades.entry_bar_index)",
            "[strategy.closedtrades.exit_bar_index](#fun_strategy.closedtrades.exit_bar_index)"
          ],
          "returnedType": "int",
          "detailedDesc": [
            {
              "desc": "",
              "examples": "// Wait 10 bars and then close the position.\n//@version=5\nstrategy(\"`strategy.opentrades.entry_bar_index` Example\")\n\nbarsSinceLastEntry() =>\n    strategy.opentrades > 0 ? bar_index - strategy.opentrades.entry_bar_index(strategy.opentrades - 1) : na\n\n// Enter a long position if there are no open positions.\nif strategy.opentrades == 0\n    strategy.entry(\"Long\",  strategy.long)\n\n// Close the long position after 10 bars. \nif barsSinceLastEntry() >= 10\n    strategy.close(\"Long\")"
            }
          ],
          "returnedTypes": [
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "strategy.opentrades.entry_time",
          "desc": "Returns the UNIX time of the open trade\\`s entry.",
          "args": [
            {
              "name": "trade_num",
              "desc": "The trade number of the open trade. The number of the first trade is zero.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "strategy.opentrades.entry_time(trade_num) → series int",
          "seeAlso": [
            "[strategy.closedtrades.entry_time](#fun_strategy.closedtrades.entry_time)",
            "[strategy.closedtrades.exit_time](#fun_strategy.closedtrades.exit_time)"
          ],
          "examples": "//@version=5\nstrategy(\"strategy.opentrades.entry_time Example\")\n\n// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.\nif bar_index % 15 == 0\n    strategy.entry(\"Long\", strategy.long)\nif bar_index % 20 == 0\n    strategy.close(\"Long\")\n\n// Calculates duration in milliseconds since the last position was opened.\ntimeSinceLastEntry()=>\n    strategy.opentrades > 0 ? (time - strategy.opentrades.entry_time(strategy.opentrades - 1)) : na\n\nplot(timeSinceLastEntry() / 1000 * 60 * 60 * 24, \"Days since last entry\")",
          "returnedType": "int",
          "returnedTypes": [
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "strategy.opentrades.size",
          "desc": "Returns the direction and the number of contracts traded in the open trade. If the value is > 0, the market position was long. If the value is < 0, the market position was short.",
          "args": [
            {
              "name": "trade_num",
              "desc": "The trade number of the open trade. The number of the first trade is zero.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "strategy.opentrades.size(trade_num) → series float",
          "seeAlso": [
            "[strategy.closedtrades.size](#fun_strategy.closedtrades.size)",
            "[strategy.position_size](#var_strategy.position_size)",
            "[strategy.opentrades](#var_strategy.opentrades)",
            "[strategy.closedtrades](#var_strategy.closedtrades)"
          ],
          "returnedType": "float",
          "detailedDesc": [
            {
              "desc": "",
              "examples": "//@version=5\nstrategy(\"`strategy.opentrades.size` Example 1\")\n\n// We calculate the max amt of shares we can buy.\namtShares = math.floor(strategy.equity / close)\n// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars\nif bar_index % 15 == 0\n    strategy.entry(\"Long\", strategy.long, qty = amtShares)\nif bar_index % 20 == 0\n    strategy.close(\"Long\")\n\n// Plot the number of contracts in the latest open trade.\nplot(strategy.opentrades.size(strategy.opentrades - 1), \"Amount of contracts in latest open trade\")"
            },
            {
              "desc": "",
              "examples": "// Calculates the average profit percentage for all open trades.\n//@version=5\nstrategy(\"`strategy.opentrades.size` Example 2\")\n\n// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.\nif bar_index % 15 == 0\n    strategy.entry(\"Long\", strategy.long)\nif bar_index % 20 == 0\n    strategy.close(\"Long\")\n\n// Calculate profit for all open trades.\nprofitPct = 0.0\nfor tradeNo = 0 to strategy.opentrades - 1\n    entryP = strategy.opentrades.entry_price(tradeNo)\n    exitP = close\n    profitPct += (exitP - entryP) / entryP * strategy.opentrades.size(tradeNo) * 100\n    \n// Calculate average profit percent for all open trades.\navgProfitPct = nz(profitPct / strategy.opentrades)\nplot(avgProfitPct)"
            }
          ],
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "strategy.opentrades.profit",
          "desc": "Returns the profit/loss of the open trade. Losses are expressed as negative values.",
          "args": [
            {
              "name": "trade_num",
              "desc": "The trade number of the open trade. The number of the first trade is zero.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "strategy.opentrades.profit(trade_num) → series float",
          "seeAlso": [
            "[strategy.closedtrades.profit](#fun_strategy.closedtrades.profit)",
            "[strategy.openprofit](#var_strategy.openprofit)",
            "[strategy.netprofit](#var_strategy.netprofit)",
            "[strategy.grossprofit](#var_strategy.grossprofit)"
          ],
          "returnedType": "float",
          "detailedDesc": [
            {
              "desc": "",
              "examples": "// Returns the profit of the last open trade.\n//@version=5\nstrategy(\"`strategy.opentrades.profit` Example 1\", commission_type = strategy.commission.percent, commission_value = 0.1)\n\n// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.\nif bar_index % 15 == 0\n    strategy.entry(\"Long\", strategy.long)\nif bar_index % 20 == 0\n    strategy.close(\"Long\")\n\nplot(strategy.opentrades.profit(strategy.opentrades - 1), \"Profit of the latest open trade\")"
            },
            {
              "desc": "",
              "examples": "// Calculates the profit for all open trades.\n//@version=5\nstrategy(\"`strategy.opentrades.profit` Example 2\", pyramiding = 5)\n\n// Strategy calls to enter 5 long positions every 2 bars.\nif bar_index % 2 == 0\n    strategy.entry(\"Long\", strategy.long, qty = 5)\n\n// Calculate open profit or loss for the open positions.\ntradeOpenPL() =>\n    sumProfit = 0.0\n    for tradeNo = 0 to strategy.opentrades - 1\n        sumProfit += strategy.opentrades.profit(tradeNo)\n    result = sumProfit\n    \nplot(tradeOpenPL(), \"Profit of all open trades\")"
            }
          ],
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "strategy.opentrades.commission",
          "desc": "Returns the sum of entry and exit fees paid in the open trade.",
          "args": [
            {
              "name": "trade_num",
              "desc": "The trade number of the open trade. The number of the first trade is zero.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "strategy.opentrades.commission(trade_num) → series float",
          "seeAlso": [
            "[strategy](#fun_strategy)",
            "[strategy.closedtrades.commission](#fun_strategy.closedtrades.commission)"
          ],
          "returnedType": "float",
          "detailedDesc": [
            {
              "desc": "",
              "examples": "// Calculates the gross profit or loss for the current open position.\n//@version=5\nstrategy(\"`strategy.opentrades.commission` Example\", commission_type = strategy.commission.percent, commission_value = 0.1)\n\n// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.\nif bar_index % 15 == 0\n    strategy.entry(\"Long\", strategy.long)\nif bar_index % 20 == 0\n    strategy.close(\"Long\")\n\n// Calculate gross profit or loss for open positions only.\ntradeOpenGrossPL() =>\n    sumOpenGrossPL = 0.0\n    for tradeNo = 0 to strategy.opentrades - 1\n        sumOpenGrossPL += strategy.opentrades.profit(tradeNo) - strategy.opentrades.commission(tradeNo)\n    result = sumOpenGrossPL\n    \nplot(tradeOpenGrossPL())"
            }
          ],
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "strategy.opentrades.max_runup",
          "desc": "Returns the maximum run up of the open trade, i.e., the maximum possible profit during the trade.",
          "args": [
            {
              "name": "trade_num",
              "desc": "The trade number of the open trade. The number of the first trade is zero.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "strategy.opentrades.max_runup(trade_num) → series float",
          "seeAlso": [
            "[strategy.closedtrades.max_runup](#fun_strategy.closedtrades.max_runup)",
            "[strategy.max_drawdown](#var_strategy.max_drawdown)"
          ],
          "returnedType": "float",
          "detailedDesc": [
            {
              "desc": "",
              "examples": "//@version=5\nstrategy(\"strategy.opentrades.max_runup Example 1\")\n\n// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.\nif bar_index % 15 == 0\n    strategy.entry(\"Long\", strategy.long)\nif bar_index % 20 == 0\n    strategy.close(\"Long\")\n\n// Plot the max runup of the latest open trade.\nplot(strategy.opentrades.max_runup(strategy.opentrades - 1), \"Max runup of the latest open trade\")"
            },
            {
              "desc": "",
              "examples": "// Calculates the max trade runup value for all open trades.\n//@version=5\nstrategy(\"strategy.opentrades.max_runup Example 2\", pyramiding = 100)\n\n// Enter a long position every 30 bars.\nif bar_index % 30 == 0\n    strategy.entry(\"Long\", strategy.long)\n\n// Calculate biggest max trade runup value from all of the open trades.\nmaxOpenTradeRunUp() =>\n    maxRunup = 0.0\n    for tradeNo = 0 to strategy.opentrades - 1\n        maxRunup := math.max(maxRunup, strategy.opentrades.max_runup(tradeNo))\n    result = maxRunup\n\nplot(maxOpenTradeRunUp(), \"Biggest max runup of all open trades\")"
            }
          ],
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "strategy.opentrades.max_drawdown",
          "desc": "Returns the maximum drawdown of the open trade, i.e., the maximum possible loss during the trade.",
          "args": [
            {
              "name": "trade_num",
              "desc": "The trade number of the open trade. The number of the first trade is zero.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "strategy.opentrades.max_drawdown(trade_num) → series float",
          "remarks": "The function returns na if trade_num is not in the range: 0 to strategy.closedtrades - 1.",
          "seeAlso": [
            "[strategy.closedtrades.max_drawdown](#fun_strategy.closedtrades.max_drawdown)",
            "[strategy.max_drawdown](#var_strategy.max_drawdown)"
          ],
          "returnedType": "float",
          "detailedDesc": [
            {
              "desc": "",
              "examples": "//@version=5\nstrategy(\"strategy.opentrades.max_drawdown Example 1\")\n\n// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.\nif bar_index % 15 == 0\n    strategy.entry(\"Long\", strategy.long)\nif bar_index % 20 == 0\n    strategy.close(\"Long\")\n\n// Plot the max drawdown of the latest open trade.\nplot(strategy.opentrades.max_drawdown(strategy.opentrades - 1), \"Max drawdown of the latest open trade\")"
            },
            {
              "desc": "",
              "examples": "// Calculates the max trade drawdown value for all open trades.\n//@version=5\nstrategy(\"`strategy.opentrades.max_drawdown` Example 2\", pyramiding = 100)\n\n// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.\nif bar_index % 15 == 0\n    strategy.entry(\"Long\", strategy.long)\nif bar_index % 20 == 0\n    strategy.close(\"Long\")\n\n// Get the biggest max trade drawdown value from all of the open trades.\nmaxTradeDrawDown() =>\n    maxDrawdown = 0.0\n    for tradeNo = 0 to strategy.opentrades - 1\n        maxDrawdown := math.max(maxDrawdown, strategy.opentrades.max_drawdown(tradeNo))\n    result = maxDrawdown\n\nplot(maxTradeDrawDown(), \"Biggest max drawdown\")"
            }
          ],
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "strategy.opentrades.entry_id",
          "desc": "Returns the id of the open trade\\`s entry.",
          "args": [
            {
              "name": "trade_num",
              "desc": "The trade number of the open trade. The number of the first trade is zero.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "strategy.opentrades.entry_id(trade_num) → series string",
          "remarks": "The function returns na if trade_num is not in the range: 0 to strategy.opentrades-1.",
          "returns": "Returns the id of the open trade\\`s entry.",
          "seeAlso": [
            "[strategy.opentrades.entry_bar_index](#fun_strategy.opentrades.entry_bar_index)",
            "[strategy.opentrades.entry_price](#fun_strategy.opentrades.entry_price)",
            "[strategy.opentrades.entry_time](#fun_strategy.opentrades.entry_time)"
          ],
          "examples": "//@version=5\nstrategy(\"`strategy.opentrades.entry_id` Example\", overlay = true)\n\n// We enter a long position when 14 period sma crosses over 28 period sma.\n// We enter a short position when 14 period sma crosses under 28 period sma.\nlongCondition = ta.crossover(ta.sma(close, 14), ta.sma(close, 28))\nshortCondition = ta.crossunder(ta.sma(close, 14), ta.sma(close, 28))\n\n// Strategy calls to enter a long or short position when the corresponding condition is met.\nif longCondition\n    strategy.entry(\"Long entry at bar #\" + str.tostring(bar_index), strategy.long)\nif shortCondition\n    strategy.entry(\"Short entry at bar #\" + str.tostring(bar_index), strategy.short)\n\n// Display ID of the latest open position.\nif barstate.islastconfirmedhistory\n    label.new(bar_index, high + (2 * ta.tr),  \"Last opened position is \\n \" + strategy.opentrades.entry_id(strategy.opentrades - 1))",
          "returnedType": "string",
          "returnedTypes": [
            "series string",
            "simple string",
            "input string",
            "const string"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "strategy.convert_to_account",
          "desc": "Converts the value from the currency that the symbol on the chart is traded in ([syminfo.currency](#var_syminfo.currency)) to the currency used by the strategy ([strategy.account_currency](#var_strategy.account_currency)).",
          "args": [
            {
              "name": "value",
              "desc": "The value to be converted.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "strategy.convert_to_account(value) → series float",
          "seeAlso": [
            "[strategy](#fun_strategy)",
            "[strategy.convert_to_symbol](#fun_strategy.convert_to_symbol)"
          ],
          "returnedType": "float",
          "detailedDesc": [
            {
              "desc": "",
              "examples": "//@version=5\nstrategy(\"`strategy.convert_to_account` Example 1\", currency = currency.EUR)\n\nplot(close, \"Close price using default currency\")\nplot(strategy.convert_to_account(close), \"Close price converted to strategy currency\")"
            },
            {
              "desc": "",
              "examples": "// Calculates the \"Buy and hold return\" using your account\\`s currency.\n//@version=5\nstrategy(\"`strategy.convert_to_account` Example 2\", currency = currency.EUR)\n\ndateInput = input.time(timestamp(\"20 Jul 2021 00:00 +0300\"), \"From Date\", confirm = true)\n\nbuyAndHoldReturnPct(fromDate) =>\n    if time >= fromDate\n        money = close * syminfo.pointvalue\n        var initialBal = strategy.convert_to_account(money)\n        (strategy.convert_to_account(money) - initialBal) / initialBal * 100\n        \nplot(buyAndHoldReturnPct(dateInput))"
            }
          ],
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "strategy.convert_to_symbol",
          "desc": "Converts the value from the currency used by the strategy ([strategy.account_currency](#var_strategy.account_currency)) to the currency that the symbol on the chart is traded in ([syminfo.currency](#var_syminfo.currency)).",
          "args": [
            {
              "name": "value",
              "desc": "The value to be converted.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "strategy.convert_to_symbol(value) → series float",
          "seeAlso": [
            "[strategy](#fun_strategy)",
            "[strategy.convert_to_account](#fun_strategy.convert_to_account)"
          ],
          "examples": "//@version=5\nstrategy(\"`strategy.convert_to_symbol` Example\", currency = currency.EUR)\n\n// Calculate the max qty we can buy using current chart\\`s currency.\ncalcContracts(accountMoney) =>\n    math.floor(strategy.convert_to_symbol(accountMoney) / syminfo.pointvalue / close)\n\n// Return max qty we can buy using 300 euros\nqt = calcContracts(300)\n\n// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars using our custom qty.\nif bar_index % 15 == 0\n    strategy.entry(\"Long\", strategy.long, qty = qt)\nif bar_index % 20 == 0\n    strategy.close(\"Long\")",
          "returnedType": "float",
          "returnedTypes": [
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "name": "chart.point.new",
          "desc": "Creates a new [chart.point](#op_chart.point) object with the specified `time`, `index`, and `price`.",
          "args": [
            {
              "name": "time",
              "desc": "The x-coordinate of the point, expressed as a UNIX time value.",
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "time",
                "time_close"
              ]
            },
            {
              "name": "index",
              "desc": "The x-coordinate of the point, expressed as a bar index value.",
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "bar_index",
                "last_bar_index"
              ]
            },
            {
              "name": "price",
              "desc": "The y-coordinate of the point.",
              "required": true,
              "displayType": "series int/float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "high",
                "low",
                "open",
                "close",
                "close[1]"
              ]
            }
          ],
          "kind": "Built-in Function",
          "syntax": "chart.point.new(time, index, price) → chart.point",
          "seeAlso": "[polyline.new](#fun_polyline.new)",
          "remarks": [
            "Whether a drawing object uses a point's `time` or `index` field as an x-coordinate depends on the `xloc` type used in the function call that returned the drawing.",
            "It's important to note that this function does not verify that the `time` and `index` values refer to the same bar. "
          ],
          "returnedTypes": "chart.point"
        },
        {
          "kind": "Built-in Function",
          "name": "chart.point.from_index",
          "desc": "Returns a [chart.point](#op_chart.point) object with `index` as its x-coordinate and `price` as its y-coordinate.",
          "args": [
            {
              "name": "index",
              "desc": "The x-coordinate of the point, expressed as a bar index value.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "price",
              "desc": "The y-coordinate of the point.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "chart.point.from_index(index, price) → chart.point",
          "remarks": "The `time` field values of [chart.point](#op_chart.point) instances returned from this function will be [na](#var_na), meaning drawing objects with `xloc` values set to `xloc.bar_time` will not work with them.",
          "returnedType": "chart.point",
          "returnedTypes": [
            "chart.point"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "chart.point.copy",
          "desc": "Creates a copy of a [chart.point](#op_chart.point) object with the specified `id`.",
          "args": [
            {
              "name": "id",
              "desc": "A [chart.point](#op_chart.point) object.",
              "default": null,
              "required": true,
              "displayType": "chart.point",
              "allowedTypeIDs": [
                "chart.point"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "chart.point.copy(id) → chart.point",
          "returnedType": "chart.point",
          "returnedTypes": [
            "chart.point"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "chart.point.from_time",
          "desc": "Returns a [chart.point](#op_chart.point) object with `time` as its x-coordinate and `price` as its y-coordinate.",
          "args": [
            {
              "name": "time",
              "desc": "The x-coordinate of the point, expressed as a UNIX time value.",
              "default": null,
              "required": true,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": null
            },
            {
              "name": "price",
              "desc": "The y-coordinate of the point.",
              "default": null,
              "required": true,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "chart.point.from_time(time, price) → chart.point",
          "remarks": "The `index` field values of [chart.point](#op_chart.point) instances returned from this function will be [na](#var_na), meaning drawing objects with `xloc` values set to `xloc.bar_index` will not work with them.",
          "returnedType": "chart.point",
          "returnedTypes": [
            "chart.point"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "chart.point.now",
          "desc": "Returns a [chart.point](#op_chart.point) object with `price` as the y-coordinate",
          "args": [
            {
              "name": "price",
              "desc": "The y-coordinate of the point. Optional. The default is [close](#var_close).",
              "default": "close",
              "required": false,
              "displayType": "series int|float",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "possibleValues": [
                "close",
                "open",
                "high",
                "low",
                "volume"
              ]
            }
          ],
          "syntax": "chart.point.now(price) → chart.point",
          "remarks": "The [chart.point](#op_chart.point) instance returned from this function records values for its `index` and `time` fields on the bar it executed on, making it suitable for use with drawing objects of any `xloc` type.",
          "returnedType": "chart.point",
          "returnedTypes": [
            "chart.point"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "line.set_first_point",
          "desc": "Sets the first point of the `id` line to `point`.",
          "args": [
            {
              "name": "id",
              "desc": "A [line](#op_line) object.",
              "default": null,
              "required": true,
              "displayType": "series line",
              "allowedTypeIDs": [
                "series line"
              ],
              "possibleValues": null
            },
            {
              "name": "point",
              "desc": "A [chart.point](#op_chart.point) object.",
              "default": null,
              "required": true,
              "displayType": "chart.point",
              "allowedTypeIDs": [
                "chart.point"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "line.set_first_point(id, point) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "line.set_second_point",
          "desc": "Sets the second point of the `id` line to `point`.",
          "args": [
            {
              "name": "id",
              "desc": "A [line](#op_line) object.",
              "default": null,
              "required": true,
              "displayType": "series line",
              "allowedTypeIDs": [
                "series line"
              ],
              "possibleValues": null
            },
            {
              "name": "point",
              "desc": "A [chart.point](#op_chart.point) object.",
              "default": null,
              "required": true,
              "displayType": "chart.point",
              "allowedTypeIDs": [
                "chart.point"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "line.set_second_point(id, point) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "label.set_point",
          "desc": "Sets the location of the `id` label to `point`.",
          "args": [
            {
              "name": "id",
              "desc": "A [label](#op_label) object.",
              "default": null,
              "required": true,
              "displayType": "series label",
              "allowedTypeIDs": [
                "series label"
              ],
              "possibleValues": null
            },
            {
              "name": "point",
              "desc": "A [chart.point](#op_chart.point) object.",
              "default": null,
              "required": true,
              "displayType": "chart.point",
              "allowedTypeIDs": [
                "chart.point"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "label.set_point(id, point) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "box.set_top_left_point",
          "desc": "Sets the top-left corner location of the `id` box to `point`.",
          "args": [
            {
              "name": "id",
              "desc": "A [box](#op_box) object.",
              "default": null,
              "required": true,
              "displayType": "series box",
              "allowedTypeIDs": [
                "series box"
              ],
              "possibleValues": null
            },
            {
              "name": "point",
              "desc": "A [chart.point](#op_chart.point) object.",
              "default": null,
              "required": true,
              "displayType": "chart.point",
              "allowedTypeIDs": [
                "chart.point"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "box.set_top_left_point(id, point) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "box.set_bottom_right_point",
          "desc": "Sets the bottom-right corner location of the `id` box to `point`.",
          "args": [
            {
              "name": "id",
              "desc": "A [box](#op_box) object.",
              "default": null,
              "required": true,
              "displayType": "series box",
              "allowedTypeIDs": [
                "series box"
              ],
              "possibleValues": null
            },
            {
              "name": "point",
              "desc": "A [chart.point](#op_chart.point) object.",
              "default": null,
              "required": true,
              "displayType": "chart.point",
              "allowedTypeIDs": [
                "chart.point"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "box.set_bottom_right_point(id, point) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "library",
          "desc": "Declaration statement identifying a script as a [library](https://www.tradingview.com/pine-script-docs/en/v5/concepts/Libraries.html).",
          "args": [
            {
              "name": "title",
              "desc": "The title of the library and its identifier. It cannot contain spaces, special characters or begin with a digit.  \nIt is used as the publication\\`s default title, and to uniquely identify the library in the [import](#op_import) statement, when another script uses it.  \nIt is also used as the script\\`s name on the chart.",
              "default": null,
              "required": true,
              "displayType": "const string",
              "allowedTypeIDs": [
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "overlay",
              "desc": "If true, the library will be added over the chart. If false, it will be added in a separate pane.  \nOptional. The default is false.",
              "default": "false",
              "required": false,
              "displayType": "const bool",
              "allowedTypeIDs": [
                "const bool"
              ],
              "possibleValues": [
                "true",
                "false"
              ]
            }
          ],
          "syntax": "library(title, overlay) → void",
          "seeAlso": [
            "[indicator](#fun_indicator)",
            "[strategy](#fun_strategy)"
          ],
          "examples": "//@version=5\n// @description Math library\nlibrary(\"num_methods\", overlay = true)\n// Calculate \"sinh()\" from the float parameter `x`\nexport sinh(float x) =>\n\t(math.exp(x) - math.exp(-x)) / 2.0\nplot(sinh(0))",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "runtime.error",
          "desc": "When called, causes a runtime error with the error message specified in the `message` argument.",
          "args": [
            {
              "name": "message",
              "desc": "Error message.",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "runtime.error(message) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "log.info",
          "desc": [
            "Converts the formatting string and value(s) into a formatted string, and sends the result to the \"Pine Logs\" menu tagged with the \"info\" debug level.",
            "The formatting string can contain literal text and one placeholder in curly braces {} for each value to be formatted. Each placeholder consists of the index of the required argument (beginning at 0) that will replace it, and an optional format specifier. The index represents the position of that argument in the function\\`s argument list."
          ],
          "args": [
            {
              "name": "formatString",
              "desc": "Format string.",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "message",
              "desc": "Log message.",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "arg0, arg1, ...",
              "desc": "Values to format.",
              "required": true,
              "displayType": "series int|float|bool|string|array<int|float|bool|string>|na",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float",
                "series bool",
                "simple bool",
                "input bool",
                "const bool",
                "series string",
                "simple string",
                "input string",
                "const string",
                "array<int>",
                "array<float>",
                "array<bool>",
                "array<string>"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "log.info(message) → void\nlog.info(formatString, arg0, arg1, ...) → void",
          "remarks": [
            "Any curly braces within an unquoted pattern must be balanced. For example, \"ab {0} de\" and \"ab '}' de\" are valid patterns, but \"ab {0'}' de\", \"ab } de\" and \"''{''\" are not.",
            "The function can apply additional formatting to some values inside of the `{}`. The list of additional formatting options can be found in the EXAMPLE section of the [str.format](#fun_str.format) article.",
            "The \"Pine Logs...\" button is accessible from the \"More\" dropdown in the Pine Editor and from the \"More\" dropdown in the status line of any script that uses `log.*()` functions."
          ],
          "returns": "The formatted string.",
          "examples": "//@version=5\nstrategy(\"My strategy\", overlay = true, margin_long = 100, margin_short = 100, process_orders_on_close = true)\nbracketTickSizeInput = input.int(1000, \"Stoploss/Take-Profit distance (in ticks)\")\n\nlongCondition = ta.crossover(ta.sma(close, 14), ta.sma(close, 28))\nif (longCondition)\n\tlimitLevel = close * 1.01\n\tlog.info(\"Long limit order has been placed at {0}\", limitLevel)\n\tstrategy.order(\"My Long Entry Id\", strategy.long, limit = limitLevel)\n\n\tlog.info(\"Exit orders have been placed: Take-profit at {0}, Stop-loss at {1}\", close)\n\tstrategy.exit(\"Exit\", \"My Long Entry Id\", profit = bracketTickSizeInput, loss = bracketTickSizeInput)\n\nif strategy.opentrades > 10\n\tlog.warning(\"{0} positions opened in the same direction in a row. Try adjusting `bracketTickSizeInput`\", strategy.opentrades)\n\nlast10Perc = strategy.initial_capital / 10 > strategy.equity\nif (last10Perc and not last10Perc[1])\n\tlog.error(\"The strategy has lost 90% of the initial capital!\")",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "log.warning",
          "desc": [
            "Converts the formatting string and value(s) into a formatted string, and sends the result to the \"Pine Logs\" menu tagged with the \"warning\" debug level.",
            "The formatting string can contain literal text and one placeholder in curly braces {} for each value to be formatted. Each placeholder consists of the index of the required argument (beginning at 0) that will replace it, and an optional format specifier. The index represents the position of that argument in the function\\`s argument list."
          ],
          "args": [
            {
              "name": "formatString",
              "desc": "Format string.",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "message",
              "desc": "Log message.",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "arg0, arg1, ...",
              "desc": "Values to format.",
              "required": true,
              "displayType": "series int|float|bool|string|array<int|float|bool|string>|na",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float",
                "series bool",
                "simple bool",
                "input bool",
                "const bool",
                "series string",
                "simple string",
                "input string",
                "const string",
                "array<int>",
                "array<float>",
                "array<bool>",
                "array<string>"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "log.warning(message) → void\nlog.warning(formatString, arg0, arg1, ...) → void",
          "remarks": [
            "Any curly braces within an unquoted pattern must be balanced. For example, \"ab {0} de\" and \"ab '}' de\" are valid patterns, but \"ab {0'}' de\", \"ab } de\" and \"''{''\" are not.",
            "The function can apply additional formatting to some values inside of the `{}`. The list of additional formatting options can be found in the EXAMPLE section of the [str.format](#fun_str.format) article.",
            "The \"Pine Logs...\" button is accessible from the \"More\" dropdown in the Pine Editor and from the \"More\" dropdown in the status line of any script that uses `log.*()` functions."
          ],
          "returns": "The formatted string.",
          "examples": "//@version=5\nstrategy(\"My strategy\", overlay = true, margin_long = 100, margin_short = 100, process_orders_on_close = true)\nbracketTickSizeInput = input.int(1000, \"Stoploss/Take-Profit distance (in ticks)\")\n\nlongCondition = ta.crossover(ta.sma(close, 14), ta.sma(close, 28))\nif (longCondition)\n\tlimitLevel = close * 1.01\n\tlog.info(\"Long limit order has been placed at {0}\", limitLevel)\n\tstrategy.order(\"My Long Entry Id\", strategy.long, limit = limitLevel)\n\n\tlog.info(\"Exit orders have been placed: Take-profit at {0}, Stop-loss at {1}\", close)\n\tstrategy.exit(\"Exit\", \"My Long Entry Id\", profit = bracketTickSizeInput, loss = bracketTickSizeInput)\n\nif strategy.opentrades > 10\n\tlog.warning(\"{0} positions opened in the same direction in a row. Try adjusting `bracketTickSizeInput`\", strategy.opentrades)\n\nlast10Perc = strategy.initial_capital / 10 > strategy.equity\nif (last10Perc and not last10Perc[1])\n\tlog.error(\"The strategy has lost 90% of the initial capital!\")",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "log.error",
          "desc": [
            "Converts the formatting string and value(s) into a formatted string, and sends the result to the \"Pine Logs\" menu tagged with the \"error\" debug level.",
            "The formatting string can contain literal text and one placeholder in curly braces {} for each value to be formatted. Each placeholder consists of the index of the required argument (beginning at 0) that will replace it, and an optional format specifier. The index represents the position of that argument in the function\\`s argument list."
          ],
          "args": [
            {
              "name": "formatString",
              "desc": "Format string.",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "message",
              "desc": "Log message.",
              "default": null,
              "required": true,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": null
            },
            {
              "name": "arg0, arg1, ...",
              "desc": "Values to format.",
              "required": true,
              "displayType": "series int|float|bool|string|array<int|float|bool|string>|na",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float",
                "series bool",
                "simple bool",
                "input bool",
                "const bool",
                "series string",
                "simple string",
                "input string",
                "const string",
                "array<int>",
                "array<float>",
                "array<bool>",
                "array<string>"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "log.error(message) → void\nlog.error(formatString, arg0, arg1, ...) → void",
          "remarks": [
            "Any curly braces within an unquoted pattern must be balanced. For example, \"ab {0} de\" and \"ab '}' de\" are valid patterns, but \"ab {0'}' de\", \"ab } de\" and \"''{''\" are not.",
            "",
            "The function can apply additional formatting to some values inside of the `{}`. The list of additional formatting options can be found in the EXAMPLE section of the [str.format](#fun_str.format) article.",
            "",
            "The \"Pine Logs...\" button is accessible from the \"More\" dropdown in the Pine Editor and from the \"More\" dropdown in the status line of any script that uses `log.*()` functions."
          ],
          "returns": "The formatted string.",
          "examples": "//@version=5\nstrategy(\"My strategy\", overlay = true, margin_long = 100, margin_short = 100, process_orders_on_close = true)\nbracketTickSizeInput = input.int(1000, \"Stoploss/Take-Profit distance (in ticks)\")\n\nlongCondition = ta.crossover(ta.sma(close, 14), ta.sma(close, 28))\nif (longCondition)\n\tlimitLevel = close * 1.01\n\tlog.info(\"Long limit order has been placed at {0}\", limitLevel)\n\tstrategy.order(\"My Long Entry Id\", strategy.long, limit = limitLevel)\n\n\tlog.info(\"Exit orders have been placed: Take-profit at {0}, Stop-loss at {1}\", close)\n\tstrategy.exit(\"Exit\", \"My Long Entry Id\", profit = bracketTickSizeInput, loss = bracketTickSizeInput)\n\nif strategy.opentrades > 10\n\tlog.warning(\"{0} positions opened in the same direction in a row. Try adjusting `bracketTickSizeInput`\", strategy.opentrades)\n\nlast10Perc = strategy.initial_capital / 10 > strategy.equity\nif (last10Perc and not last10Perc[1])\n\tlog.error(\"The strategy has lost 90% of the initial capital!\")",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "map.new<type,type>",
          "desc": "Creates a new map object: a collection that consists of key-value pairs, where all keys are of the `keyType`, and all values are of the `valueType`.\n`keyType` can only be a primitive type, i.e., one of the following: [int](#op_int), [float](#op_float), [bool](#op_bool), [string](#op_string), [color](#op_color).\n`valueType` can be of any type except `array`, `matrix`, and `map`.  \nUser-defined types are allowed, even if they have `array`, `matrix`, or `map` as one of their fields.",
          "args": [],
          "syntax": "map.new<keyType, valueType>() → map<keyType, valueType>",
          "remarks": [
            "Each key is unique and can only appear once. When adding a new value with a key that the map already contains, that value replaces the old value associated with the key.",
            "Maps maintain insertion order. Note that the order does not change when inserting a pair with a `key` that\\`s already in the map. The new pair replaces the existing pair with the `key` in such cases."
          ],
          "returnedType": "map<keyType, valueType>",
          "returns": "The ID of a map object which may be used in other map.*() functions.",
          "seeAlso": [
            "[map.put](#fun_map.put)",
            "[map.keys](#fun_map.keys)",
            "[map.values](#fun_map.values)",
            "[map.get](#fun_map.get)",
            "[array.new<type>](#fun_array.new<type>)"
          ],
          "examples": "//@version=5\nindicator(\"map.new<string, int> example\")\na = map.new<string, int>()\na.put(\"example\", 1)\nlabel.new(bar_index, close, str.tostring(a.get(\"example\")))"
        },
        {
          "kind": "Built-in Function",
          "name": "map.copy",
          "desc": "Creates a copy of an existing map.",
          "args": [
            {
              "name": "id",
              "desc": "A map object to copy.",
              "default": null,
              "required": true,
              "displayType": "map<type>",
              "allowedTypeIDs": "map",
              "possibleValues": null
            }
          ],
          "syntax": "map.copy(id) → map<keyType, valueType>",
          "returns": "A copy of the `id` map.",
          "seeAlso": [
            "[map.new<type,type>](#fun_map.new%3Ctype,type%3E)",
            "[map.put](#fun_map.put)",
            "[map.keys](#fun_map.keys)",
            "[map.values](#fun_map.values)",
            "[map.get](#fun_map.get)",
            "[map.size](#fun_map.size)"
          ],
          "examples": "//@version=5\nindicator(\"map.copy example\")\na = map.new<string, int>()\na.put(\"example\", 1)\nb = map.copy(a)\na := map.new<string, int>()\na.put(\"example\", 2)\nplot(a.get(\"example\"))\nplot(b.get(\"example\"))"
        },
        {
          "kind": "Built-in Function",
          "name": "map.size",
          "desc": "Returns the number of key-value pairs in the `id` map.",
          "args": [
            {
              "name": "id",
              "desc": "A map object.",
              "default": null,
              "required": true,
              "displayType": "map<type>",
              "allowedTypeIDs": "map",
              "possibleValues": null
            }
          ],
          "syntax": "map.size(id) → series int",
          "seeAlso": [
            "[map.new<type,type>](#fun_map.new%3Ctype,type%3E)",
            "[map.put](#fun_map.put)",
            "[map.keys](#fun_map.keys)",
            "[map.values](#fun_map.values)",
            "[map.get](#fun_map.get)"
          ],
          "examples": "//@version=5\nindicator(\"map.size example\")\na = map.new<int, int>()\nsize = 10\nfor i = 0 to size\n\ta.put(i, size-i)\nplot(map.size(a))",
          "returnedType": "int",
          "returnedTypes": [
            "series int",
            "simple int",
            "input int",
            "const int"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "map.get",
          "desc": "Returns the value associated with the specified `key` in the `id` map.",
          "args": [
            {
              "name": "id",
              "desc": "A map object.",
              "default": null,
              "required": true,
              "displayType": "map<type>",
              "allowedTypeIDs": "map",
              "possibleValues": null
            },
            {
              "name": "key",
              "desc": "The key of the value to retrieve.",
              "default": null,
              "required": true,
              "displayType": "map<type>",
              "allowedTypeIDs": [],
              "possibleValues": null
            }
          ],
          "syntax": "map.get(id, key) → series valueType",
          "seeAlso": [
            "[map.new<type,type>](#fun_map.new%3Ctype,type%3E)",
            "[map.put](#fun_map.put)",
            "[map.keys](#fun_map.keys)",
            "[map.values](#fun_map.values)",
            "[map.contains](#fun_map.contains)"
          ],
          "examples": "//@version=5\nindicator(\"map.get example\")\na = map.new<int, int>()\nsize = 10\nfor i = 0 to size\n\ta.put(i, size-i)\nplot(map.get(a, 1))",
          "returnedType": [],
          "returnedTypes": []
        },
        {
          "kind": "Built-in Function",
          "name": "map.contains",
          "desc": "Returns [true](#op_true) if the `key` was found in the `id` map, [false](#op_false) otherwise.",
          "args": [
            {
              "name": "id",
              "desc": "A map object.",
              "default": null,
              "required": true,
              "displayType": "map<type>",
              "allowedTypeIDs": "map",
              "possibleValues": null
            },
            {
              "name": "key",
              "desc": "The key to search in the map.",
              "default": null,
              "required": true,
              "displayType": "map<type>",
              "allowedTypeIDs": [],
              "possibleValues": null
            }
          ],
          "syntax": "map.contains(id, key) → series bool",
          "seeAlso": [
            "[map.new<type,type>](#fun_map.new%3Ctype,type%3E)",
            "[map.put](#fun_map.put)",
            "[map.keys](#fun_map.keys)",
            "[map.values](#fun_map.values)",
            "[map.size](#fun_map.size)"
          ],
          "examples": "//@version=5\nindicator(\"map.includes example\")\na = map.new<string, float>()\na.put(\"open\", open)\np = close\nif map.contains(a, \"open\")\n\tp := a.get(\"open\")\nplot(p)",
          "returnedType": "bool",
          "returnedTypes": [
            "series bool",
            "simple bool",
            "input bool",
            "const bool"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "map.keys",
          "desc": "Returns an array of all the keys in the `id` map. The resulting array is a copy and any changes to it are not reflected in the original map.",
          "args": [
            {
              "name": "id",
              "desc": "A map object.",
              "default": null,
              "required": true,
              "displayType": "map<type>",
              "allowedTypeIDs": "map",
              "possibleValues": null
            }
          ],
          "syntax": "map.keys(id) → type[]",
          "remarks": "Maps maintain insertion order. The elements within the array returned by this function will also be in the insertion order.",
          "seeAlso": [
            "[map.new<type,type>](#fun_map.new%3Ctype,type%3E)",
            "[map.put](#fun_map.put)",
            "[map.get](#fun_map.get)",
            "[map.values](#fun_map.values)",
            "[map.size](#fun_map.size)"
          ],
          "examples": "//@version=5\nindicator(\"map.keys example\")\na = map.new<string, float>()\na.put(\"open\", open)\na.put(\"high\", high)\na.put(\"low\", low)\na.put(\"close\", close)\nkeys = map.keys(a)\nohlc = 0.0\nfor key in keys\n\tohlc += a.get(key)\nplot(ohlc/4)",
          "returnedType": "array",
          "returnedTypes": [
            "array"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "map.values",
          "desc": "Returns an array of all the values in the `id` map. The resulting array is a copy and any changes to it are not reflected in the original map.",
          "args": [
            {
              "name": "id",
              "desc": "A map object.",
              "default": null,
              "required": true,
              "displayType": "map<type>",
              "allowedTypeIDs": "map",
              "possibleValues": null
            }
          ],
          "syntax": "map.values(id) → type[]",
          "remarks": "Maps maintain insertion order. The elements within the array returned by this function will also be in the insertion order.",
          "seeAlso": [
            "[map.new<type,type>](#fun_map.new%3Ctype,type%3E)",
            "[map.put](#fun_map.put)",
            "[map.get](#fun_map.get)",
            "[map.keys](#fun_map.keys)",
            "[map.size](#fun_map.size)"
          ],
          "examples": "//@version=5\nindicator(\"map.values example\")\na = map.new<string, float>()\na.put(\"open\", open)\na.put(\"high\", high)\na.put(\"low\", low)\na.put(\"close\", close)\nvalues = map.values(a)\nohlc = 0.0\nfor value in values\n\tohlc += value\nplot(ohlc/4)",
          "returnedType": "array",
          "returnedTypes": [
            "array"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "map.put",
          "desc": "Puts a new key-value pair into the `id` map.",
          "args": [
            {
              "name": "id",
              "desc": "A map object.",
              "default": null,
              "required": true,
              "displayType": "map<type>",
              "allowedTypeIDs": "map",
              "possibleValues": null
            },
            {
              "name": "key",
              "desc": "The key to put into the map.",
              "default": null,
              "required": true,
              "displayType": "map<type>",
              "allowedTypeIDs": [],
              "possibleValues": null
            },
            {
              "name": "value",
              "desc": "The key value to put into the map.",
              "default": null,
              "required": true,
              "displayType": "map<type>",
              "allowedTypeIDs": [],
              "possibleValues": null
            }
          ],
          "syntax": "map.put(id, key, value) → series valueType",
          "remarks": "Maps maintain insertion order. Note that the order does not change when inserting a pair with a `key` that\\`s already in the map.  \nThe new pair replaces the existing pair with the `key` in such cases.",
          "returns": "The previous value associated with `key` if the key was already present in the map, or [na](#var_na) if the key is new.",
          "seeAlso": [
            "[map.new<type,type>](#fun_map.new%3Ctype,type%3E)",
            "[map.put_all](#fun_map.put_all)",
            "[map.keys](#fun_map.keys)",
            "[map.values](#fun_map.values)",
            "[map.remove](#fun_map.remove)"
          ],
          "examples": "//@version=5\nindicator(\"map.put example\")\na = map.new<string, float>()\nmap.put(a, \"first\", 10)\nmap.put(a, \"second\", 15)\nprevFirst = map.put(a, \"first\", 20)\ncurrFirst = a.get(\"first\")\nplot(prevFirst)\nplot(currFirst)",
          "returnedType": [],
          "returnedTypes": []
        },
        {
          "kind": "Built-in Function",
          "name": "map.put_all",
          "desc": "Puts all key-value pairs from the `id2` map into the `id` map.",
          "args": [
            {
              "name": "id",
              "desc": "A map object to append to.",
              "default": null,
              "required": true,
              "displayType": "map<type>",
              "allowedTypeIDs": "map",
              "possibleValues": null
            },
            {
              "name": "id2",
              "desc": "A map object to be appended.",
              "default": null,
              "required": true,
              "displayType": "map<type>",
              "allowedTypeIDs": "map",
              "possibleValues": null
            }
          ],
          "syntax": "map.put_all(id, id2) → void",
          "seeAlso": [
            "[map.new<type,type>](#fun_map.new%3Ctype,type%3E)",
            "[map.put](#fun_map.put)",
            "[map.keys](#fun_map.keys)",
            "[map.values](#fun_map.values)",
            "[map.remove](#fun_map.remove)"
          ],
          "examples": "//@version=5\nindicator(\"map.put_all example\")\na = map.new<string, float>()\nb = map.new<string, float>()\na.put(\"first\", 10)\na.put(\"second\", 15)\nb.put(\"third\", 20)\nmap.put_all(a, b)\nplot(a.get(\"third\"))",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "map.remove",
          "desc": "Removes a key-value pair from the `id` map.",
          "args": [
            {
              "name": "id",
              "desc": "A map object.",
              "default": null,
              "required": true,
              "displayType": "map<type>",
              "allowedTypeIDs": "map",
              "possibleValues": null
            },
            {
              "name": "key",
              "desc": "The key of the pair to remove from the map.",
              "default": null,
              "required": true,
              "displayType": "map<type>",
              "allowedTypeIDs": [],
              "possibleValues": null
            }
          ],
          "syntax": "map.remove(id, key) → series valueType",
          "returns": "The previous value associated with `key` if the key was present in the map, or [na](#var_na) if there was no such key.",
          "seeAlso": [
            "[map.new<type,type>](#fun_map.new%3Ctype,type%3E)",
            "[map.put](#fun_map.put)",
            "[map.keys](#fun_map.keys)",
            "[map.values](#fun_map.values)",
            "[map.clear](#fun_map.clear)"
          ],
          "examples": "//@version=5\nindicator(\"map.remove example\")\na = map.new<string, color>()\na.put(\"firstColor\", color.green)\noldColorValue = map.remove(a, \"firstColor\")\nplot(close, color = oldColorValue)",
          "returnedType": [],
          "returnedTypes": []
        },
        {
          "kind": "Built-in Function",
          "name": "map.clear",
          "desc": "Clears the map, removing all key-value pairs from it.",
          "args": [
            {
              "name": "id",
              "desc": "A map object.",
              "default": null,
              "required": true,
              "displayType": "map<type>",
              "allowedTypeIDs": "map",
              "possibleValues": null
            }
          ],
          "syntax": "map.clear(id) → void",
          "seeAlso": [
            "[map.new<type,type>](#fun_map.new%3Ctype,type%3E)",
            "[map.put_all](#fun_map.put_all)",
            "[map.keys](#fun_map.keys)",
            "[map.values](#fun_map.values)",
            "[map.remove](#fun_map.remove)"
          ],
          "examples": "//@version=5\nindicator(\"map.clear example\")\noddMap = map.new<int, bool>()\noddMap.put(1, true)\noddMap.put(2, false)\noddMap.put(3, true)\nmap.clear(oddMap)\nplot(oddMap.size())",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "polyline.new",
          "desc": "Creates a new [polyline](#op_polyline) instance and displays it on the chart, sequentially connecting all of the points in the `points` array with line segments. The segments in the drawing can be straight or curved depending on the `curved` parameter.",
          "args": [
            {
              "name": "points",
              "desc": "An array of [chart.point](#op_chart.point) objects for the drawing to sequentially connect.",
              "default": null,
              "required": true,
              "displayType": "chart.point[]",
              "allowedTypeIDs": [
                "chart.point[]"
              ],
              "possibleValues": null
            },
            {
              "name": "curved",
              "desc": "If [true](#op_true), the drawing will connect all points from the `points` array using curved line segments. Optional. The default is [false](#op_false).",
              "default": "false",
              "required": false,
              "displayType": "series bool",
              "allowedTypeIDs": [
                "series bool",
                "simple bool",
                "input bool",
                "const bool"
              ],
              "possibleValues": [
                "true",
                "false"
              ]
            },
            {
              "name": "closed",
              "desc": "If [true](#op_true), the drawing will also connect the first point to the last point from the `points` array, resulting in a closed polyline. Optional. The default is [false](#op_false).",
              "default": "false",
              "required": false,
              "displayType": "series bool",
              "allowedTypeIDs": [
                "series bool",
                "simple bool",
                "input bool",
                "const bool"
              ],
              "possibleValues": [
                "true",
                "false"
              ]
            },
            {
              "name": "xloc",
              "desc": "Determines the field of the [chart.point](#op_chart.point) objects in the `points` array that the polyline will use for its x-coordinates. If [xloc.bar_index](#var_xloc.bar_index), the polyline will use the `index` field from each point. If [xloc.bar_time](#var_xloc.bar_time), it will use the `time` field. Optional. The default is [xloc.bar_index](#var_xloc.bar_index).",
              "default": "xloc.bar_index",
              "required": false,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "xloc.bar_index",
                "xloc.bar_time"
              ]
            },
            {
              "name": "line_color",
              "desc": "The color of the line segments. Optional. The default is [color.blue](#var_color.blue).",
              "default": "color.blue",
              "required": false,
              "displayType": "series color",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "possibleValues": [
                "colors"
              ]
            },
            {
              "name": "fill_color",
              "desc": "The fill color of the polyline. Optional. The default is [na](#var_na).",
              "default": "na",
              "required": false,
              "displayType": "series color",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "possibleValues": [
                "colors"
              ]
            },
            {
              "name": "line_style",
              "desc": "The style of the polyline.  \nPossible values: [line.style_solid](#var_line.style_solid), [line.style_dotted](#var_line.style_dotted), [line.style_dashed](#var_line.style_dashed), [line.style_arrow_left](#var_line.style_arrow_left), [line.style_arrow_right](#var_line.style_arrow_right), [line.style_arrow_both](#var_line.style_arrow_both). Optional. The default is {mdInternalRef1}.",
              "default": "line.style_solid",
              "required": false,
              "displayType": "series string",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "possibleValues": [
                "line.style_solid",
                "line.style_dotted",
                "line.style_dashed",
                "line.style_arrow_left",
                "line.style_arrow_right",
                "line.style_arrow_both"
              ]
            },
            {
              "name": "line_width",
              "desc": "The width of the line segments, expressed in pixels. Optional. The default is 1.",
              "default": "1",
              "required": false,
              "displayType": "series int",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "possibleValues": [
                "1",
                "2",
                "3",
                "4",
                "5"
              ]
            }
          ],
          "syntax": "polyline.new(points, curved, closed, xloc, line_color, fill_color, line_style, line_width) → series polyline",
          "returns": "The ID of a new polyline object that a script can use in other `polyline.*()` functions.",
          "seeAlso": [
            "[chart.point.new](#fun_chart.point.new)"
          ],
          "examples": "//@version=5\nindicator(\"Polylines example\", overlay = true)\n\n//@variable If `true`, connects all points in the polyline with curved line segments. \nbool curvedInput = input.bool(false, \"Curve Polyline\")\n//@variable If `true`, connects the first point in the polyline to the last point.\nbool closedInput = input.bool(true,  \"Close Polyline\")\n//@variable The color of the space filled by the polyline.\ncolor fillcolor = input.color(color.new(color.blue, 90), \"Fill Color\")\n\n// Time and price inputs for the polyline's points. \np1x = input.time(0,  \"p1\", confirm = true, inline = \"p1\")\np1y = input.price(0, \"  \", confirm = true, inline = \"p1\")\np2x = input.time(0,  \"p2\", confirm = true, inline = \"p2\")\np2y = input.price(0, \"  \", confirm = true, inline = \"p2\")\np3x = input.time(0,  \"p3\", confirm = true, inline = \"p3\")\np3y = input.price(0, \"  \", confirm = true, inline = \"p3\")\np4x = input.time(0,  \"p4\", confirm = true, inline = \"p4\")\np4y = input.price(0, \"  \", confirm = true, inline = \"p4\")\np5x = input.time(0,  \"p5\", confirm = true, inline = \"p5\")\np5y = input.price(0, \"  \", confirm = true, inline = \"p5\")\n\nif barstate.islastconfirmedhistory\n\t//@variable An array of `chart.point` objects for the new polyline.\n\tvar points = array.new<chart.point>()\n\t// Push new `chart.point` instances into the `points` array.\n\tpoints.push(chart.point.from_time(p1x, p1y))\n\tpoints.push(chart.point.from_time(p2x, p2y))\n\tpoints.push(chart.point.from_time(p3x, p3y))\n\tpoints.push(chart.point.from_time(p4x, p4y))\n\tpoints.push(chart.point.from_time(p5x, p5y))\n\t// Add labels for each `chart.point` in `points`.\n\tl1p1 = label.new(points.get(0), text = \"p1\", xloc = xloc.bar_time, color = na)\n\tl1p2 = label.new(points.get(1), text = \"p2\", xloc = xloc.bar_time, color = na)\n\tl2p1 = label.new(points.get(2), text = \"p3\", xloc = xloc.bar_time, color = na)\n\tl2p2 = label.new(points.get(3), text = \"p4\", xloc = xloc.bar_time, color = na)\n\t// Create a new polyline that connects each `chart.point` in the `points` array, starting from the first.\n\tpolyline.new(points, curved = curvedInput, closed = closedInput, fill_color = fillcolor, xloc = xloc.bar_time",
          "returnedType": "polyline",
          "returnedTypes": [
            "series polyline"
          ]
        },
        {
          "kind": "Built-in Function",
          "name": "polyline.delete",
          "desc": "Deletes the specified [polyline](#op_polyline) object. It has no effect if the `id` doesn't exist.",
          "args": [
            {
              "name": "id",
              "desc": "The polyline ID to delete.",
              "default": null,
              "required": true,
              "displayType": "series polyline",
              "allowedTypeIDs": [
                "series polyline"
              ],
              "possibleValues": null
            }
          ],
          "syntax": "polyline.delete(id) → void",
          "returnedType": "void",
          "returnedTypes": [
            "void"
          ]
        }
      ],
      "title": "Built-in Function"
    }
  ],
  "operators": [
    {
      "docs": [
        {
          "name": "?:",
          "desc": "Ternary conditional operator.",
          "kind": "Language Operator",
          "syntax": "expr1 ? expr2 : expr3",
          "returns": "expr2 if expr1 is evaluated to true, expr3 otherwise. Zero value (0 and also NaN, +Infinity, -Infinity) is considered to be false, any other value is true.",
          "remarks": [
            "Use [na](#var_na) for 'else' branch if you do not need it.",
            "You can combine two or more [?:](#op_?:) operators to achieve the equivalent of a 'switch'-like statement (see examples above).",
            "You may use arithmetic operators with numbers as well as with series variables. In case of usage with series the operators are applied elementwise."
          ],
          "seeAlso": "[na](#var_na)",
          "examples": "//@version=5\nindicator(\"?:\")\n// Draw circles at the bars where open crosses close\ns2 = ta.cross(open, close) ? math.avg(open,close) : na\nplot(s2, style=plot.style_circles, linewidth=2, color=color.red)\n\n// Combination of ?: operators for 'switch'-like logic\nc = timeframe.isintraday ? color.red : timeframe.isdaily ? color.green : timeframe.isweekly ? color.blue : color.gray\nplot(hl2, color=c)"
        },
        {
          "name": "+",
          "desc": "Addition or unary plus. Applicable to numerical expressions or strings.",
          "kind": "Language Operator",
          "syntax": "expr1 + expr2",
          "returns": [
            "Binary `+` for strings returns concatenation of expr1 and expr2",
            "For numbers returns integer or float value, or series of values:",
            "Binary `+` returns expr1 plus expr2.",
            "Unary `+` returns expr (does nothing added just for the symmetry with the unary - operator)."
          ],
          "remarks": "You may use arithmetic operators with numbers as well as with series variables. In case of usage with series the operators are applied elementwise."
        },
        {
          "name": "+",
          "desc": "Addition or unary plus. Applicable to numerical expressions or strings.",
          "kind": "Language Operator",
          "syntax": "+ expr",
          "returns": [
            "Binary `+` for strings returns concatenation of expr1 and expr2",
            "For numbers returns integer or float value, or series of values:",
            "Binary `+` returns expr1 plus expr2.",
            "Unary `+` returns expr (does nothing added just for the symmetry with the unary - operator)."
          ],
          "remarks": "You may use arithmetic operators with numbers as well as with series variables. In case of usage with series the operators are applied elementwise."
        },
        {
          "name": "-",
          "desc": "Subtraction or unary minus. Applicable to numerical expressions.",
          "kind": "Language Operator",
          "syntax": "expr1 - expr2",
          "returns": [
            "Returns integer or float value, or series of values:",
            "Binary `-` returns expr1 minus expr2.",
            "Unary `-` returns the negation of expr."
          ],
          "remarks": "You may use arithmetic operators with numbers as well as with series variables. In case of usage with series the operators are applied elementwise."
        },
        {
          "name": "-",
          "desc": "Subtraction or unary minus. Applicable to numerical expressions.",
          "kind": "Language Operator",
          "syntax": "- expr",
          "returns": [
            "Returns integer or float value, or series of values:",
            "Binary `-` returns expr1 minus expr2.",
            "Unary `-` returns the negation of expr."
          ],
          "remarks": "You may use arithmetic operators with numbers as well as with series variables. In case of usage with series the operators are applied elementwise."
        },
        {
          "name": "[]",
          "desc": "Series subscript. Provides access to previous values of series expr1. expr2 is the number of bars back, and must be numerical. Floats will be rounded down.",
          "kind": "Language Operator",
          "syntax": "expr1[expr2]",
          "returns": "A series of values.",
          "seeAlso": "[math.floor](#fun_math.floor)",
          "examples": "//@version=5\nindicator(\"[]\")\n// [] can be used to \"save\" variable value between bars\na = 0.0 // declare `a`\na := a[1] // immediately set current value to the same as previous. `na` in the beginning of history\nif high == low // if some condition - change `a` value to another\n    a := low\nplot(a)"
        },
        {
          "name": ":=",
          "desc": "Reassignment operator. It is used to assign a new value to a previously declared variable.",
          "kind": "Language Operator",
          "syntax": "<var_name> := <new_value>",
          "examples": "//@version=5\nindicator(\"My script\")\n\nmyVar = 10\n\nif close > open\n    // Modifies the existing global scope `myVar` variable by changing its value from 10 to 20.\n    myVar := 20\n    // Creates a new `myVar` variable local to the `if` condition and unreachable from the global scope.\n    // Does not affect the `myVar` declared in global scope.\n    myVar = 30\n\nplot(myVar)"
        },
        {
          "name": "==",
          "desc": "Equal to. Applicable to expressions of any type.",
          "kind": "Language Operator",
          "syntax": "expr1 == expr2",
          "returns": "Boolean value, or series of boolean values."
        },
        {
          "name": "!=",
          "desc": "Not equal to. Applicable to expressions of any type.",
          "kind": "Language Operator",
          "syntax": "expr1 != expr2",
          "returns": "Boolean value, or series of boolean values."
        },
        {
          "name": ">",
          "desc": "Greater than. Applicable to numerical expressions.",
          "kind": "Language Operator",
          "syntax": "expr1 > expr2",
          "returns": "Boolean value, or series of boolean values."
        },
        {
          "name": "<",
          "desc": "Less than. Applicable to numerical expressions.",
          "kind": "Language Operator",
          "syntax": "expr1 < expr2",
          "returns": "Boolean value, or series of boolean values."
        },
        {
          "name": ">=",
          "desc": "Greater than or equal to. Applicable to numerical expressions.",
          "kind": "Language Operator",
          "syntax": "expr1 >= expr2",
          "returns": "Boolean value, or series of boolean values."
        },
        {
          "name": "<=",
          "desc": "Less than or equal to. Applicable to numerical expressions.",
          "kind": "Language Operator",
          "syntax": "expr1 <= expr2",
          "returns": "Boolean value, or series of boolean values."
        },
        {
          "name": "*",
          "desc": "Multiplication. Applicable to numerical expressions.",
          "kind": "Language Operator",
          "syntax": "expr1 * expr2",
          "returns": "Integer or float value, or series of values."
        },
        {
          "name": "/",
          "desc": "Division. Applicable to numerical expressions.",
          "kind": "Language Operator",
          "syntax": "expr1 / expr2",
          "returns": "Integer or float value, or series of values."
        },
        {
          "name": "%",
          "desc": "Modulo (integer remainder). Applicable to numerical expressions.",
          "kind": "Language Operator",
          "syntax": "expr1 % expr2",
          "returns": "Integer or float value, or series of values.",
          "remarks": [
            "In Pine Script®, when the integer remainder is calculated, the quotient is truncated, i.e. rounded towards the lowest absolute value. The resulting value will have the same sign as the dividend.",
            "Example: -1 % 9 = -1 - 9 * truncate(-1/9) = -1 - 9 * truncate(-0.111) = -1 - 9 * 0 = -1."
          ]
        },
        {
          "name": "+=",
          "desc": "Addition assignment. Applicable to numerical expressions or strings.",
          "kind": "Language Operator",
          "syntax": "expr1 += expr2",
          "returns": "For strings returns concatenation of expr1 and expr2. For numbers returns integer or float value, or series of values.",
          "remarks": "You may use arithmetic operators with numbers as well as with series variables. In case of usage with series the operators are applied elementwise.",
          "examples": "//@version=5\nindicator(\"+=\")\n// Equals to expr1 = expr1 + expr2.\na = 2\nb = 3\na += b\n// Result: a = 5.\nplot(a)"
        },
        {
          "name": "-=",
          "desc": "Subtraction assignment. Applicable to numerical expressions.",
          "kind": "Language Operator",
          "syntax": "expr1 -= expr2",
          "returns": "Integer or float value, or series of values.",
          "examples": "//@version=5\nindicator(\"-=\")\n// Equals to expr1 = expr1 - expr2.\na = 2\nb = 3\na -= b\n// Result: a = -1.\nplot(a)"
        },
        {
          "name": "*=",
          "desc": "Multiplication assignment. Applicable to numerical expressions.",
          "kind": "Language Operator",
          "syntax": "expr1 *= expr2",
          "returns": "Integer or float value, or series of values.",
          "examples": "//@version=5\nindicator(\"*=\")\n// Equals to expr1 = expr1 * expr2.\na = 2\nb = 3\na *= b\n// Result: a = 6.\nplot(a)"
        },
        {
          "name": "/=",
          "desc": "Division assignment. Applicable to numerical expressions.",
          "kind": "Language Operator",
          "syntax": "expr1 /= expr2",
          "returns": "Integer or float value, or series of values.",
          "examples": "//@version=5\nindicator(\"/=\")\n// Equals to expr1 = expr1 / expr2.\na = 3\nb = 3\na /= b\n// Result: a = 1.\nplot(a)"
        },
        {
          "name": "%=",
          "desc": "Modulo assignment. Applicable to numerical expressions.",
          "kind": "Language Operator",
          "syntax": "expr1 %= expr2",
          "returns": "Integer or float value, or series of values.",
          "examples": "//@version=5\nindicator(\"%=\")\n// Equals to expr1 = expr1 % expr2.\na = 3\nb = 3\na %= b\n// Result: a = 0.\nplot(a)"
        },
        {
          "name": "=>",
          "desc": [
            "The '=>' operator is used in user-defined function declarations and in [switch](#op_switch) statements.",
            "The function declaration syntax is:"
          ],
          "kind": "Language Operator",
          "syntax": "<identifier>([<parameter_name>[=<default_value>]], ...) =>\n    <local_block>\n    <function_result>",
          "remarks": "You can learn more about user-defined functions in the User Manual's pages on [Declaring functions](https://www.tradingview.com/pine-script-docs/en/v5/language/User-defined_functions.html) and [Libraries](https://www.tradingview.com/pine-script-docs/en/v5/concepts/Libraries.html).",
          "detailedDesc": [
            {
              "desc": "The <function_result> is a variable, an expression, or a tuple.",
              "examples": "//@version=5\nindicator(\"=>\")\n// single-line function\nf1(x, y) => x + y\n// multi-line function\nf2(x, y) => \n\tsum = x + y\n\tsumChange = ta.change(sum, 10)\n\t// Function automatically returns the last expression used in it\nplot(f1(30, 8) + f2(1, 3))"
            }
          ]
        }
      ]
    }
  ],
  "annotations": [
    {
      "docs": [
        {
          "name": "// @description",
          "kind": "Built-in @Annotation",
          "desc": "Sets a custom description for scripts that use the  [library](#fun_library) declaration statement. The text provided with this annotation will be used to pre-fill the \"Description\" field in the publication dialogue.",
          "examples": "//@version=5\n// @description Provides a tool to quickly output a label on the chart.\nlibrary(\"MyLibrary\")\n\n// @function Outputs a label with `labelText` on the bar\\`s high.\n// @param labelText (series string) The text to display on the label.\n// @returns Drawn label.\nexport drawLabel(string labelText) =>\n\tlabel.new(bar_index, high, text = labelText)"
        },
        {
          "name": "// @function",
          "kind": "Built-in @Annotation",
          "desc": [
            "If placed above a function declaration, it adds a custom description for the function.",
            "The Pine Editor\\`s autosuggest uses this description and displays it when a user hovers over the function name. When used in [library](#fun_library) scripts, the descriptions of all functions using the [export](#op_export) keyword will pre-fill the \"Description\" field in the publication dialogue."
          ],
          "examples": "//@version=5\n// @description Provides a tool to quickly output a label on the chart.\nlibrary(\"MyLibrary\")\n\n// @function Outputs a label with `labelText` on the bar\\`s high.\n// @param labelText (series string) The text to display on the label.\n// @returns Drawn label.\nexport drawLabel(string labelText) =>\n\tlabel.new(bar_index, high, text = labelText)"
        },
        {
          "name": "// @param",
          "kind": "Built-in @Annotation",
          "desc": [
            "If placed above a function declaration, it adds a custom description for a function parameter. After the annotation, users should specify the parameter name, then its description.",
            "The Pine Editor\\`s autosuggest uses this description and displays it when a user hovers over the function name. When used in [library](#fun_library) scripts, the descriptions of all functions using the [export](#op_export) keyword will pre-fill the \"Description\" field in the publication dialogue."
          ],
          "examples": "//@version=5\n// @description Provides a tool to quickly output a label on the chart.\nlibrary(\"MyLibrary\")\n\n// @function Outputs a label with `labelText` on the bar\\`s high.\n// @param labelText (series string) The text to display on the label.\n// @returns Drawn label.\nexport drawLabel(string labelText) =>\n\tlabel.new(bar_index, high, text = labelText)"
        },
        {
          "name": "// @returns",
          "kind": "Built-in @Annotation",
          "desc": [
            "If placed above a function declaration, it adds a custom description for what that function returns.",
            "The Pine Editor\\`s autosuggest uses this description and displays it when a user hovers over the function name. When used in [library](#fun_library) scripts, the descriptions of all functions using the [export](#op_export) keyword will pre-fill the \"Description\" field in the publication dialogue."
          ],
          "examples": "//@version=5\n// @description Provides a tool to quickly output a label on the chart.\nlibrary(\"MyLibrary\")\n\n// @function Outputs a label with `labelText` on the bar\\`s high.\n// @param labelText (series string) The text to display on the label.\n// @returns Drawn label.\nexport drawLabel(string labelText) =>\n\tlabel.new(bar_index, high, text = labelText)"
        },
        {
          "name": "// @variable",
          "kind": "Built-in @Annotation",
          "desc": [
            "If placed above a variable declaration, it adds a custom description for the variable.",
            "The Pine Editor\\`s autosuggest uses this description and displays it when a user hovers over the variable name."
          ],
          "examples": "//@version=5\nindicator(\"New high over the last 20 bars\", overlay = true)\n\n//@type A point on a chart.\n//@field index The index of the bar where the point is located, i.e., its `x` coordinate.\n//@field price The price where the point is located, i.e., its `y` coordinate.\ntype Point\n    int index\n    float price\n\n//@variable If the current `high` is the highest over the last 20 bars, returns a new `Point` instance, `na` otherwise.\nPoint highest = na\n\nif ta.highestbars(high, 20) == 0\n    highest := Point.new(bar_index, high)\n    label.new(highest.index, highest.price, str.tostring(highest.price))"
        },
        {
          "name": "// @type",
          "kind": "Built-in @Annotation",
          "desc": [
            "If placed above a type declaration, it adds a custom description for the type.",
            "The Pine Editor\\`s autosuggest uses this description and displays it when a user hovers over the type name. When used in [library](#fun_library) scripts, the descriptions of all types using the [export](#op_export) keyword will pre-fill the \"Description\" field in the publication dialogue."
          ],
          "examples": "//@version=5\nindicator(\"New high over the last 20 bars\", overlay = true)\n\n//@type A point on a chart.\n//@field index The index of the bar where the point is located, i.e., its `x` coordinate.\n//@field price The price where the point is located, i.e., its `y` coordinate.\ntype Point\n    int index\n    float price\n\n//@variable If the current `high` is the highest over the last 20 bars, returns a new `Point` instance, `na` otherwise.\nPoint highest = na\n\nif ta.highestbars(high, 20) == 0\n    highest := Point.new(bar_index, high)\n    label.new(highest.index, highest.price, str.tostring(highest.price))"
        },
        {
          "name": "// @field",
          "kind": "Built-in @Annotation",
          "desc": [
            "If placed above a type declaration, it adds a custom description for a field of the type. After the annotation, users should specify the field name, then its description.",
            "The Pine Editor\\`s autosuggest uses this description and displays it when a user hovers over the type or field name. When used in [library](#fun_library) scripts, the descriptions of all types using the [export](#op_export) keyword will pre-fill the \"Description\" field in the publication dialogue."
          ],
          "examples": "//@version=5\nindicator(\"New high over the last 20 bars\", overlay = true)\n\n//@type A point on a chart.\n//@field index The index of the bar where the point is located, i.e., its `x` coordinate.\n//@field price The price where the point is located, i.e., its `y` coordinate.\ntype Point\n    int index\n    float price\n\n//@variable If the current `high` is the highest over the last 20 bars, returns a new `Point` instance, `na` otherwise.\nPoint highest = na\n\nif ta.highestbars(high, 20) == 0\n    highest := Point.new(bar_index, high)\n    label.new(highest.index, highest.price, str.tostring(highest.price))"
        },
        {
          "name": "// @strategy_alert_message",
          "kind": "Built-in @Annotation",
          "desc": "If used within a [strategy](#fun_strategy) script, it provides a default message to pre-fill the \"Message\" field in the alert creation dialogue.",
          "examples": "//@version=5\nstrategy(\"My strategy\", overlay=true, margin_long=100, margin_short=100)\n//@strategy_alert_message Strategy alert on symbol {{ticker}}\n\nlongCondition = ta.crossover(ta.sma(close, 14), ta.sma(close, 28))\nif (longCondition)\n    strategy.entry(\"My Long Entry Id\", strategy.long)\nstrategy.exit(\"Exit\", \"My Long Entry Id\", profit = 10 / syminfo.mintick, loss = 10 / syminfo.mintick)"
        },
        {
          "name": "//@version=",
          "kind": "Built-in @Annotation",
          "desc": "Specifies the PineScript™ version that the script will use. The number in this annotation should not be confused with the script\\`s revision number, which updates on every saved change to the code.",
          "remarks": "The version should always be specified. Otherwise, for compatibility reasons, the script will be compiled using PineScript™ v1, which lacks most of the newer features and is bound to confuse.  \nThis annotation can be anywhere within a script, but we recommend placing it at the top of the code for readability.",
          "detailedDesc": [
            {
              "desc": "",
              "examples": "//@version=5\nindicator(\"Pine v5 Indicator\")\nplot(close)"
            },
            {
              "desc": "",
              "examples": "//This indicator has no version annotation, so it will try to use v1.\n//PineScript™ v1 has no function named `indicator()`, so the script\nindicator(\"Pine v1 Indicator\")\nplot(close)"
            }
          ]
        }
      ],
      "title": "Built-in @Annotation"
    }
  ],
  "fields": [
    {
      "docs": [
        {
          "name": "time",
          "desc": "The x-coordinate of the point, expressed as a UNIX time value.",
          "type": "series float",
          "parent": "chart.point"
        },
        {
          "name": "index",
          "desc": "The x-coordinate of the point, expressed as a bar index value.",
          "type": "series int",
          "parent": "chart.point"
        },
        {
          "name": "price",
          "desc": "The y-coordinate of the point.",
          "type": "series float",
          "parent": "chart.point"
        }
      ],
      "title": "Built-in chart.point fields"
    }
  ]
}